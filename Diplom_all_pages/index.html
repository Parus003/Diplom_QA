<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Дипломный проект</title>
</head>
<body>

    <p>
        Geekbrains
    </p>
    <p>
        Факультет тестирования ПО
    </p>
    <h1>Автоматизация тестирования UI с использованием Selenium и Pytest</h1>
    
    
    <p>
        <strong>Дипломная работа</strong>
    </p>
    <p>
        специальности "Инженер по тестированию ПО"
    </p>
    <p>
        Проскурин А.В.
    </p>
    <p>
        Белгород
    </p>
    <p>
        2023
    </p>
    <p>
        <strong>Дипломный проект “Автоматизация тестирования UI с использованием Selenium”</strong>
    </p>

    <h1 id="-">Базовое представление о тестировании</h1>
    <p>В этой главе попробуем понять что же такое тестирование.</p>
    <h2 id="-">Что такое тестирование?</h2>
    <p>Посмотрим, что нам об этом пишет wikipeia:</p>
    <blockquote>
    <p>Тестирование программного обеспечения — процесс исследования, испытания программного продукта, имеющий своей целью проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе тестов, выбранных определённым образом.</p>
    <p><a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">wikipedia</a></p>
    </blockquote>
    <p>Вот еще одна цитата из другого ресурса:</p>
    <blockquote>
    <p>Тестирование ПО — это процесс проверки программного обеспечения на соответствие определенным требованиям, ожиданиям и стандартам. Основная цель тестирования заключается в обнаружении дефектов, ошибок и недостатков в программном продукте, а также убеждении в том, что ПО работает в соответствии с его задачами и требованиями.</p>
    <p><a href="https://qaevolution.ru/testirovanie-po/">qaevolution</a></p>
    </blockquote>
    <p>Из этого выходит, что основная цель тестирования - это поиск ошибок, непредсказуемого поведения, соответствие стандартам у ПО.
    Итак мы узнали, что тестирование - это поиск дефектов (багов). Как же эти баги находятся?</p>
    <p>Как найти дефекты:</p>
    <ol>
    <li><a href="https://vladislaveremeev.gitbook.io/qa_bible/testovaya-dokumentaciya-i-artefakty-test-deliverablestest-artifacts/testovyi-orakul-test-oracle">Тестовые оракулы</a> - это механизм для определения того, прошел тест или нет. В роли оракула может выступать уже имеющаяся система (для эталонного тестирования), руководство пользователя, профессиональные знания специалиста, однако им не может быть программный код.</li>
    <li>Дальше нужно поработать с ПО (ориентируясь на тестовый оракул) и посмотреть, как оно будет реагировать на действия.</li>
    <li>Сравниманием два результата, тот что получился и тот что нужен.</li>
    </ol>
    <p>Не стоит также отбрасывать здравый смысл.
    Если система по всем требования работает правильно, но очень не логично для пользователя, то вероятно нужно описать этот момент.</p>
    <h2 id="-">Кто такой тестировщик?</h2>
    <p>Цитата из wikipedia:</p>
    <blockquote>
    <p>Тестировщик (Испытатель) — специалист, принимающий участие в тестировании компонента или системы.[1] В его обязанность входит поиск вероятных ошибок и сбоев в функционировании объекта тестирования (продукта, программы). Тестировщик моделирует различные ситуации, которые могут возникнуть в процессе использования предмета тестирования, чтобы разработчики смогли исправить обнаруженные ошибки.</p>
    <p><a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA">wikipedia</a></p>
    </blockquote>
    <p>Тестировщику важно быть внимательным и дотошным, пригодится и хорошее структурное мышление. Также полезно разбираться в бизнес-процессах и досконально знать продукт, чтобы сохранять баланс между интересами пользователей, целями менеджмента компании и возможностями команды разработки.</p>
    <p>Примерная структура работы тестировщика:</p>
    <ol>
    <li>Изучить документацию, уточнить непонятные вещи в ней. Чтобы понимать, какую функциональность продукта нужно будет тестировать.</li>
    <li>Разработка тестов. Готовится набор тестов для проверки или обновляются существующие.</li>
    <li>Проверка продукта. Ориентируясь на разработанные тесты проверка результата и его фиксация.</li>
    </ol>
    <h2 id="7-">7 основных принципов тестирования</h2>
    <ol>
    <li>Исчерпывающее тестирование невозможно: нельзя протестировать всё</li>
    <li>Кластеризация дефектов</li>
    <li>Парадокс пестицида</li>
    <li>Тестирование показывает наличие дефектов</li>
    <li>Отсутствие ошибок может быть обманчивым</li>
    <li>Раннее тестирование</li>
    <li>Тестирование зависит от контекста</li>
    </ol>
    <p>Источник: <a href="https://testengineer.ru/sem-glavnyh-principov-testirovaniya/">testengineer.ru</a></p>
    
    <h1 id="-">Тестирование на основе требований</h1>
    <p>Чтобы понять на сколько вы поняли основы теории тестирования, выполните задание и передайте результат его выполнения
    коллегам, друзьям или студентам на курсе, на котором вы проходите обучение.</p>
    <h2 id="-1-">Предмет 1. Бутылка пластиковая, прозрачная</h2>
    <h2 id="-">Свойства предмета:</h2>
    <ul>
    <li>внешняя и внутренняя поверхности бутылок должны быть чистыми, прозрачными, без следов смазки, сквозных отверстий,
    пузырей, грата и трещин;</li>
    <li>вместимость: 0.5 л;</li>
    <li>должна присутствовать крышка, которая позволяет предотвратить вытекание жидкости из тары;</li>
    <li>бутылка должна устойчиво стоять в вертикальном положении как пустая, так и наполненная жидкостью;</li>
    <li>на дне бутылки допустимо иметь уплотнение в виде твердой пластиковой точки;</li>
    <li>бутылка должна сохранять внешний вид, не деформироваться и не растрескиваться при температуре (70±5)°С в течение 10-15
    мин;</li>
    <li><p>заполненная водой температурой (20±5)°С бутылка должна выдерживать не менее двух падений с высоты 0.8 м на
    металлическую или бетонную поверхности. При двукратном сбрасывании на бутылке не должно наблюдаться механических
    повреждений, приводящих к потере герметичности.</p>
    </li>
    <li><p>Ознакомьтесь с представленными ниже предметами и их свойствами. Описание предметов на естественном языке является его
    спецификацией (или требованиями к предмету). Предполагается, что как минимум один из объектов есть в том помещении, в
    котором вы проходите курс.</p>
    </li>
    <li>Выберите один из представленных объектов для тестирования. Опишите, как бы вы тестировали этот объект, но уже с
    учетом полученных требований.</li>
    <li><p>Представьте описание тестирования в следующем виде:</p>
    </li>
    <li><p>Название объекта, выбранного для тестирования: <strong>__</strong></p>
    </li>
    <li><p>Описание процесса тестирования и (по возможности) его результатов. Если выполнение теста невозможно - укажите это в
    документе: <strong>__</strong></p>
    </li>
    <li><p>Передайте полученное описание тестов для оценивания коллегам и оцените работы ваших коллег по критериям,
    перечисленным ниже.</p>
    </li>
    </ul>
    <h2 id="-">Критерии оценки выполнения задания.</h2>
    <ol>
    <li>Понятно ли описание тестов (изложены понятным языком, формулировки не подразумевают двояких трактовок)? (Да – 1 балл
    /Нет – 0 баллов)</li>
    <li>Воспроизводимо ли описание тестирования? (Да – 1 балл /Нет – 0 баллов)</li>
    <li>Соответствуют ли тесты представленным требованиям к выбранному объекту? (Да – 1 балл /Нет – 0 баллов)</li>
    <li>Позволяет ли описание тестов сделать вывод о корректности свойств и функционирования предмета тестирования? (Да – 1
    балл /Нет – 0 баллов)</li>
    </ol>

    
    <h1 id="-">Классификация тестирования</h1>
    <p>Существует много различных классификаций тестирования и каждый автор обладает своим мнением по классификации
    тестирования. Поэтому когда вас спрашивают о той или иной классификации тестирования необходимо уточнять согласно какому
    источнику.</p>
    <p>Первый способ классификации, который мы рассмотрим, это классификация <strong>по
    объекту тестирования</strong>. Согласно такому способу тестирование может быть:</p>
    <ul>
    <li><strong>Функциональное</strong> – проверяется функциональность ПО – способность решать
    возложенные на него задачи.</li>
    <li><strong>Производительности</strong> – насколько хорошо ПО справляется со своими задачами:
    скорость, количество запросов в единицу времени и иные количественные
    характеристики.</li>
    <li><strong>Конфигурационное</strong> – рассматривается то, насколько ПО корректно работает в
    различных конфигурациях. Сюда относят то, на каком оборудовании и
    операционных системах работает ПО, насколько хорошо оно конфигурируется,
    настраивается и исполняет свои задачи с различными настройками.</li>
    <li><strong>UI (интерфейса)</strong> – тестируется исключительно интерфейс, а не функциональность
    самого продукта. Проверяется расположены ли кнопки на своих местах, выполняют
    ли они свои задачи, правильно ли работает анимация. Наверняка, вы хотя бы раз
    сталкивались с программами, интерфейс которых не проходил эту фазу.</li>
    <li><strong>Security/Compliance</strong> – проверка соответствия различным политикам от регуляторов
    и организаций, которые накладывают те или иные ограничения на производимый
    софт. Это могут быть в частности стандарты безопасности или документы тех или
    иных государственных структур.</li>
    </ul>
    <p>Теперь посмотрим на то, какие виды тестирования могут возникать на пересечении
    или быть подвидами ранее рассмотренных нами типов.</p>
    <p><strong>Тестирование производительности</strong> может быть:</p>
    <ul>
    <li><strong>Нагрузочное</strong> – проверяется работоспособность компонента или системы в целом
    под определенной постоянной нагрузкой.</li>
    <li><strong>Стресс</strong> – проверяется моментально высокая нагрузка на ПО. В случае баз данных
    это может быть высокое количество запросов в единицу времени. В случае
    пользовательских интерфейсов это может быть большое количество нажатий на
    одну и ту же кнопку.</li>
    <li><strong>Стабильности</strong> – проверяется то, насколько хорошо ПО работает под определенной
    нагрузкой в течение длительного промежутка времени.</li>
    </ul>
    <p>На пересечении <strong>конфигурационного</strong> и <strong>UI тестирования</strong> может возникнуть
    <strong>тестирование совместимости</strong>, направленное на проверку того, что интерфейс корректно
    работает при различных конфигурациях ПО и платформ (например, разработчики ПО часто
    самостоятельно решают, насколько одинаково будет выглядеть создаваемый продукт в
    различных версиях операционных систем).</p>
    <p>Также в рамках <strong>UI тестирования</strong> иногда отдельно проводят:</p>
    <ul>
    <li><strong>UI функциональное тестирование</strong>, направленное на проверку того, что все
    элементы интерфейса действительно выполняют свою работу (не просто
    отображаются, но и запускают те действия, которые они должны запускать).</li>
    <li><strong>Юзабилити тестирование</strong> – проверка того, что пользователь действительно сможет
    пользоваться созданным ПО. Тестируется то, что иногда не входит в формальные
    требования: скорость реакции интерфейса, место положения кнопок друг
    относительно друга (например, для большинства локаций кнопка «вперед»
    находится справа, а кнопка «назад» - слева). Сюда же входит целый класс
    мероприятий, направленный на то, какая из двух конфигураций интерфейса больше
    подходит пользователям.</li>
    </ul>
    <p>На срезе <strong>UI тестирования</strong> и <strong>Security/Compliance</strong> тестирования проводят
    <strong>тестирование локализации</strong>, к которому относится проверка того, что все внешние и
    внутренние компоненты системы корректно переведены, надписи помещаются в кнопках,
    а кнопки находятся на своих местах.</p>
    <p><strong>Функциональное тестирование</strong> можно разделять в зависимости от степени
    изолированности компонентов следующим образом:</p>
    <ul>
    <li>тестирование продукта целиком – проверяется то, как продукт справляется со
    своими задачами;</li>
    <li>тестирование отдельных компонент;</li>
    <li>тестирование классов;</li>
    <li>тестирование методов или функций.</li>
    </ul>
    <p>Чаще всего процесс тестирования выстраивается снизу-вверх по представленному
    выше списку. Сначала тестируются функции, затем классы, затем классы, объединенные в
    компоненты, затем компоненты, объединенные в продукт.</p>
    <p>Тестирование продукта целиком или групп модулей иногда называют <strong>системным,
    «сквозным» или end-to-end тестированием</strong>. Система проверяется сценариями, действие
    которых проходит через весь компонент или всю систему, например, начинается и
    заканчивается где-то в пользовательском интерфейсе и никаких проверок «внутри»
    системы не выполняется.</p>
    <p>Тестирование продукта, модулей и классов может быть <strong>интеграционным</strong> – в том
    случае, когда проверяется интеграция модулей в продукт, классов в модули, а функций в
    классы.</p>
    <p>Тестирование модулей, классов и функций может быть <strong>unit или модульным
    тестированием</strong> – проверкой на работоспособность некоторой условной «единицы». Важно
    отметить, что тестирование отдельного компонента или модуля unit-тестированием
    называется редко. Модуль состоит из большого количества компонент и крайне сложно
    воспринимать его как отдельную единицу. Однако существует определенный класс тестов,
    которые достаточно просты, но проверяют функциональность целого модуля. Такие тесты
    формально могут называться unit-тестами.</p>
    <p><strong>Unit-тестирование</strong> – это часто первый уровень тестирования, который выполняется
    самими разработчиками, которые пишут во многих случаях автоматизированные тесты,
    выполняемые при каждом действии по созданию/изменению кода. При создании unit-тестов
    часто используются дополнительные фреймворки, «заглушки», вспомогательные драйверы
    и фейковые (mock) объекты. Заглушки необходимы для того, чтобы изолировать
    тестируемый объект. Если тестируемый класс или метод зависит от поведения сторонних
    классов или методов, то в рамках unit-тестирования мы можем отказаться от развертывания
    всей необходимой инфраструктуры и вместо этого использовать заглушки с
    предопределенным поведением. Например, если тестируется коннектор к базе данных, то в
    рамках unit тестирования можно не подключаться к реальной базе, а создать объектзаглушку, которая отвечает от имени
    базы предопределенными ответами.</p>
    <p><strong>Интеграционное тестирование</strong> предполагает проверку нескольких компонент,
    объединенных друг с другом. Основная задача такого тестирования – выявление ошибок во
    взаимодействии: протоколах, обмене данными, несоответствии методов и вызовов. В этом
    типе тестирования также используются заглушки.</p>
    <p>При <strong>системном тестировании</strong> проверяются сложные сценарии: например, при
    нажатии кнопки пользователем данные проходят через всю систему, попадают в базу,
    распределяются, выполняется обработка данных, пользователю демонстрируется результат.</p>
    <p>При <strong>end-to-end или сквозном тестировании</strong> проверяется вся собранная система, а
    также взаимосвязанные системы, через которые проходят принимаемые и отправляемые
    данные.</p>
    <p>Поговорим теперь о видах тестирования по знаниям о продукте:</p>
    <ul>
    <li><strong>Black-box тестирование (методом «черного ящика»)</strong> – подход, при котором в
    процессе тестирования мы не можем заглядывать «внутрь» компонента. Чаще используется
    в рамках системного или при определенных видах интеграционного тестирования.</li>
    <li><strong>White-box тестирование (методом «белого ящика»)</strong> – подход, при котором в
    процессе тестирования мы можем заглядывать «внутрь» компонента. Чаще используется
    при unit-тестировании, а также определенных типах интеграционного.</li>
    <li><strong>Grey-box тестирование (методом «серого ящика»)</strong> – промежуточный вид
    тестирования, при котором у нас есть доступ лишь к ряду компонентов системы.</li>
    </ul>

    <h1 id="-">Классификация тестирования. Практика</h1>
    <p>Чтобы понять на сколько вы поняли основы классификации тестирования, выполните задание и передайте результат его
    выполнения коллегам, друзьям или студентам на курсе, на котором вы проходите обучение.</p>
    <h2 id="-">Объект тестирования: ручка шариковая, прозрачная.</h2>
    <ol>
    <li><p>Свойства объекта тестирования:</p>
    </li>
    <li><p>компоненты ручки: стержень с чернилами, колпачок откручивающийся, колпачок, защищающий ручку от высыхания, корпус;</p>
    </li>
    <li>цвет чернил: синий;</li>
    <li>возможность замены стержня: присутствует;</li>
    <li>диаметр шарика: 1 мм;</li>
    <li>толщина линии письма: 0,7 мм;</li>
    <li>материал корпуса: пластик;</li>
    <li>цвет корпуса: прозрачный;</li>
    <li>материал колпачков: пластик;</li>
    <li>цвет колпачков: синий;</li>
    <li>условия использования:<ul>
    <li>атмосферное давление: 500 – 770 мм. рт.ст.;</li>
    <li>температура воздуха: -15 - +45 градусов Цельсия;</li>
    </ul>
    </li>
    <li>длительность письма: линия длиной не менее 400 м при последовательности нагрузок на ручку продолжительностью от 10 до
    15 секунд каждая;</li>
    <li>на наружной поверхности должен быть нанесен товарный знак предприятия-изготовителя;</li>
    <li>пригодность к использованию после свободного падения с высоты 1 м боковой поверхностью (отсутствие сколов,
    повреждений, царапин);</li>
    <li><p>ожидаемый срок службы: не менее 3 месяцев с момента первого открытия колпачка.</p>
    </li>
    <li><p>Ознакомьтесь с типами предлагаемых тестов.</p>
    </li>
    <li><p>модульные тесты;</p>
    </li>
    <li>интеграционные тесты;</li>
    <li>системные тесты;</li>
    <li>end-to-end тесты;</li>
    <li>стресс тесты;</li>
    <li><p>тесты на производительность.</p>
    </li>
    <li><p>Проведите тестирование предлагаемого объекта или любой из ее компонент на основе 2-3 типов тестов, которые вы можете
    выбрать сами.</p>
    </li>
    <li><p>Представьте результаты тестирования для каждого из тестов в следующем виде:</p>
    </li>
    </ol>
    <p>Название объекта, выбранного для тестирования: <strong><strong><strong>__</strong></strong></strong></p>
    <p>Идентификатор теста: <strong><strong><strong>__</strong></strong></strong></p>
    <p>Тип тестирования: <strong><strong><strong>__</strong></strong></strong></p>
    <p>Последовательность выполняемых действий при тестировании:</p>
    <ol>
    <li>_<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></li>
    <li>_<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></li>
    <li>_<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></li>
    </ol>
    <p>Актуальный результат: <strong><strong><strong><strong><strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
    <p>Ожидаемый результат: <strong><strong><strong><strong><strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
    <h2 id="-">Критерии оценки выполнения задания.</h2>
    <ol>
    <li><p>Понятно ли описание результатов тестирования (результаты изложены понятным языком, формулировки не подразумевают
    двояких трактовок)? (Да – 1 балл /Нет – 0 баллов)</p>
    </li>
    <li><p>Воспроизводимо ли описание результатов тестирования? (Да – 1 балл /Нет – 0 баллов)</p>
    </li>
    <li><p>Соответствуют ли тесты представленным требованиям к выбранному объекту? (Да – 1 балл /Нет – 0 баллов)</p>
    </li>
    <li><p>Позволяет ли описание тестов сделать вывод о корректности свойств и функционирования предмета тестирования? (Да – 1
    балл /Нет – 0 баллов)</p>
    </li>
    <li><p>Присутствует ли в тесте описание ожидаемого и актуального результата? (Да – 1 балл /Нет – 0 баллов)</p>
    </li>
    <li><p>Присутствует ли в идентификатор теста в результатах тестирования? (Да – 1 балл /Нет – 0 баллов)</p>
    </li>
    <li><p>Соответствуют ли приведенные тесты выбранным типам тестирования? (Да – 1 балл /Нет – 0 баллов)</p>
    </li>
    </ol>

    <h1 id="-">Написание тестовой документации</h1>
    <p>Рассмотрим основную тестовую документацию:</p>
    <ul>
    <li>чек-лист;</li>
    <li>тест-кейс;</li>
    <li>тестовый набор;</li>
    <li>отчет о дефекте.</li>
    </ul>
    <h2 id="-">Чек-лист</h2>
    <blockquote>
    <p>Тестировщику приходится работать с огромным количеством информации, выбирать из множества вариантов
    решения задач и изобретать новые. В процессе этой деятельности объективно невозможно удержать в голове все мысли, а
    потому продумывание и разработку тест-кейсов рекомендуется выполнять с использованием «чек-листов».</p>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    </blockquote>
    <p>Чек-лист - это список проверок, который может обладать низкой детализацией и зачастую понятен для глубоко погруженных в
    проект специалистов и трудно воспринимаем новыми сотрудниками.</p>
    <p>Святослав Куликов дает такое понятие чек-листа:</p>
    <blockquote>
    <p>Чек-лист (checklist) — набор идей [тест-кейсов]. Последнее слово не зря
    взято в скобки, т.к. в общем случае чек-лист — это просто набор идей:
    идей по тестированию, идей по разработке, идей по планированию и
    управлению — любых идей.</p>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    </blockquote>
    <p>Чек-лист обычно представляет из себя хорошо известный всем список.</p>
    <ul>
    <li>Этот список может быть маркированны, где последовательность пунктов не важна для проведения проверок.</li>
    <li>Нумерованный связный список, где каждая последующая проверка строится на результате предыдущей. В таком чписке важна
    очередность выполнения пунктов.</li>
    <li>Многоуровневый список. В котором выделены отдельные компоненты, чтобы отразить иерархию и структуру проверок.</li>
    </ul>
    <h3 id="-">Правила составления чек-листа</h3>
    <ol>
    <li>Один пункт – одна операция.</li>
    <li>Пункты всегда начинаются с существительного или
    глагола неопределенной формы.</li>
    <li>Соблюдать структуру.</li>
    <li>Опираться на требования.</li>
    <li>Давать пунктам чек-листа названия по форме, общей
    для всех членов команды.</li>
    </ol>
    <p>Так может выглядеть многоуровневый несвязный чек-лист:</p>
    <p><img src="../img/qase_check-list.png" width="400" height="600" alt="check-list qase"></p>
    <h3 id="-">Резолюция чек-листа</h3>
    <ol>
    <li>passed – кейс прошел проверку;</li>
    <li>failed – кейс не прошел проверку;</li>
    <li>skipped – пропуск проверки;</li>
    <li>blocked – нет возможности проверить;</li>
    <li>untested – еще не брали в работу.</li>
    </ol>
    <h3 id="-">Преимущества и недостатки чек-листов</h3>
    <h4 id="-">Преимущества.</h4>
    <ul>
    <li>Чек-листы затрагивают большее количество кейсов, так как
    при прохождении их можно по-разному выполнять.</li>
    <li>Сокращают затраты на содержание и поддержку тестов.</li>
    <li>Обеспечивают высокую скорость тестирования: не нужно отмечать результат
    каждого шага тестировщика, достаточно общего результата проверки.</li>
    <li>Чек-листы затрагивают большее количество кейсов, так как
    при прохождении их можно по-разному выполнять.</li>
    <li>Сокращают затраты на содержание и поддержку тестов.</li>
    <li>Обеспечивают высокую скорость тестирования: не нужно отмечать результат
    каждого шага тестировщика, достаточно общего результата проверки.</li>
    <li>Позволяют проходить и комбинировать тесты по-разному, в зависимости
    от предпочтений сотрудников.</li>
    <li>Показывают статистику: кто, когда и что проходил — с детализацией
    по сборке продукта и окружению, на котором проводилось тестирование.</li>
    <li>Улучшают представление о системе в целом, показывают статус
    ее готовности.</li>
    <li>Показывают объем проделанной и предстоящей работы по тестированию.</li>
    </ul>
    <h4 id="-">Недостатки.</h4>
    <ul>
    <li>Начинающие тестировщики не всегда эффективно проводят тесты
    без достаточно подробной документации.</li>
    <li>Чек-листы невозможно использовать для обучения
    начинающих сотрудников, так как в них недостаточно
    подробных сведений.</li>
    <li>Заказчику или руководству может быть недостаточно
    того уровня детализации, который предлагают чек-листы.</li>
    <li>Неопределенность тестового набора: каждый тестировщик
    выполняет пункт чек-листа по-своему.</li>
    </ul>
    <h2 id="-">Тест-кейс</h2>
    <blockquote>
    <p>Тест-кейс (test case) — набор входных данных, условий выполнения и
    ожидаемых результатов, разработанный с целью проверки того или иного
    свойства или поведения программного средства.
    Под тест-кейсом также может пониматься соответствующий документ,
    представляющий формальную запись тест-кейса.</p>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    </blockquote>
    <p>Тест-кейс содержит обязательные атрибуты:</p>
    <ul>
    <li>уникальный идентификатор;</li>
    <li>название, отражающее суть проверки;</li>
    <li>шаги воспроизведения;</li>
    <li>ожидаемый результат;</li>
    <li>тестовые данные;</li>
    <li>фактический результат;</li>
    <li>статус (резолюция).</li>
    </ul>
    <p>Обязательные атрибуты чаще всего дополняются следующими атрибутами:</p>
    <ul>
    <li>приоритет тест-кейса;</li>
    <li>предусловия;</li>
    <li>постусловия;</li>
    <li>связанное с тест-кейсом требование;</li>
    <li>модуль и подмодуль приложения.</li>
    </ul>
    <h3 id="-">Резолюция тест-кейса</h3>
    <ol>
    <li>passed – кейс прошел проверку;</li>
    <li>failed – кейс не прошел проверку;</li>
    <li>skipped – пропуск проверки;</li>
    <li>blocked – нет возможности проверить;</li>
    <li>untested – еще не брали в работу.</li>
    </ol>
    <h3 id="-">Преимущества и недостатки тест-кейсов</h3>
    <h4 id="-">Преимущества</h4>
    <ul>
    <li>За счет полной детализации шагов тест-кейсы может проходить
    новичок, а также по тест-кейсам довольно удобно знакомиться
    с продуктом.</li>
    <li>Достаточно подробное описание бизнес-логики. При неидеальной
    организации хранения требований, уточнение некоторых моментов
    проще будет найти в тест-кейсах.</li>
    </ul>
    <h4 id="-">Недостатки</h4>
    <ul>
    <li>В сравнении с чек-листами требуют много времени на написание.</li>
    <li>Сложно поддерживать. При изменении бизнес-логики,
    переименовании разделов и прочих изменениях, затрагивающих
    пользовательский интерфейс и сценарии использования системы,
    нужно актуализировать все тест-кейсы, затрагивающие измененную
    часть.</li>
    </ul>
    <p>О том как правильно писать тест-кейсы и чек-листы, какие свойства качественной тестовой документации хорошо написано в
    книге «Тестирование программного обеспечения. Базовый курс.».</p>
    <h3 id="-">Список качественных свойст:</h3>
    <blockquote>
    <p>Правильный технический язык, точность и единообразие формулировок.</p>
    <ul>
    <li>пишите лаконично, но понятно;</li>
    <li>используйте безличную форму глаголов (например, «открыть» вместо «откройте»);</li>
    <li>обязательно указывайте точные имена и технически верные названия элементов приложения;</li>
    <li>не объясняйте базовые принципы работы с компьютером (предполагается,
    что ваши коллеги знают, что такое, например, «пункт меню» и как с ним работать);</li>
    <li>везде называйте одни и те же вещи одинаково (например, нельзя в одном
    тест-кейсе некий режим работы приложения назвать «графическое представление», а в другом тот же режим —
      «визуальное
    отображение», т.к. многие
    люди могут подумать, что речь идёт о разных вещах);</li>
    <li>следуйте принятому на проекте стандарту оформления и написания тесткейсов (иногда такие стандарты могут быть весьма
    жёсткими: вплоть до регламентации того, названия каких элементов должны быть приведены в
    двойных кавычках, а каких — в одинарных).</li>
    </ul>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    <p>Баланс между специфичностью и общностью.</p>
    <p>Почему плоха излишняя специфичность (тест-кейс 1):</p>
    <ul>
    <li>при повторных выполнениях тест-кейса всегда будут выполняться строго
      одни и те же действия со строго одними и теми же данными, что снижает
      вероятность обнаружения ошибки;</li>
    <li>возрастает время написания, доработки и даже просто прочтения тест-кейса;</li>
    <li>в случае выполнения тривиальных действий опытные специалисты тратят
      дополнительные мыслительные ресурсы в попытках понять, что же они упустили из виду, т.к. они привыкли, что так
      описываются только самые сложные
      и неочевидные ситуации.</li>
    </ul>
    <p>Почему плоха излишняя общность (тест-кейс 2):</p>
    <ul>
    <li>тест-кейс сложен для выполнения начинающими тестировщиками или даже
      опытными специалистами, лишь недавно подключившимися к проекту;</li>
    <li>недобросовестные сотрудники склонны халатно относиться к таким тест-кейсам;</li>
    <li>тестировщик, выполняющий тест-кейс, может понять его иначе, чем было задумано автором (и в итоге будет выполнен
      фактически совсем другой тесткейс).</li>
    </ul>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    <p>Баланс между простотой и сложностью.</p>
    <p>Преимущества простых тест-кейсов:</p>
    <ul>
    <li>их можно быстро прочесть, легко понять и выполнить;</li>
    <li>они понятны начинающим тестировщикам и новым людям на проекте;</li>
    <li>они делают наличие ошибки очевидным (как правило, в них предполагается
      выполнение повседневных тривиальных действий, проблемы с которыми
      видны невооружённым взглядом и не вызывают дискуссий);</li>
    <li>они упрощают начальную диагностику ошибки, т.к. сужают круг поиска.</li>
    </ul>
    <p>Преимущества сложных тест-кейсов:</p>
    <ul>
    <li>при взаимодействии многих объектов повышается вероятность возникновения ошибки;</li>
    <li>пользователи, как правило, используют сложные сценарии, а потому сложные тесты более полноценно эмулируют работу
      пользователей;</li>
    <li>программисты редко проверяют такие сложные случаи (и они совершенно не
      обязаны это делать).</li>
    </ul>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    <p>«Показательность» (высокая вероятность обнаружения ошибки).
    Начиная с уровня тестирования критического пути , можно утверждать, что тест-кейс
    является тем более хорошим, чем он более показателен (с большей вероятностью
    обнаруживает ошибку). Именно поэтому мы считаем непригодными слишком простые тест-кейсы — они непоказательны.</p>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    <p>Последовательность в достижении цели.
    Суть этого свойства выражается
    в том, что все действия в тест-кейсе направлены на следование единой логике и
    достижение единой цели и не содержат никаких отклонений.</p>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    <p>Отсутствие лишних действий.
    Чаще всего это свойство подразумевает, что
    не нужно в шагах тест-кейса долго и по пунктам расписывать то, что можно заменить одной фразой.</p>
    <p><a href="https://svyatoslav.biz/software_testing_book/">«Тестирование программного обеспечения. Базовый курс.»</a></p>
    </blockquote>
    <h2 id="-">Регрессионное тестирование и ретест</h2>
    <p>Регрессионное тестирование (regression testing) —
    тестирование уже проверенной функциональности
    после внесения изменений в код приложения
    для уверенности, что эти изменения не внесли
    или не активизировали ошибки в областях,
    которые не подвергались изменениям.</p>
    <p>Ре-тест или подтверждающее тестирование (re-test, acceptance testing) — проводится в случае, если фича/функциональность
    уже имела дефекты, и эти дефекты были недавно исправлены.</p>
    <p>Подробнее о таких видах тестирования как &quot;дымовое&quot;, «санитарное тестирование», «ре-тест» и регрессионное тестирование
    можно прочитать в
    статье <a href="https://habr.com/ru/post/358142/">В чём разница Smoke, Sanity, Regression, Re-test и как их различать?</a></p>

    <h1 id="-">Техники тест-дизайна</h1>
    <h2 id="-">Методы разработки тестов</h2>
    <p>Существует несколько методов разработки тестов, которые обычно используются инженерами по обеспечению качества. Наиболее
    распространенные из них:</p>
    <ol>
    <li>Эквивалентное разбиение (классы эквивалентности). Этот метод включает в себя разделение входных данных на группы,
    которые должны вести себя одинаково. Затем каждая группа тестируется с репрезентативным тестовым случаем.</li>
    <li>Анализ граничных значений. Этот метод включает проверку входных данных, которые находятся на границах входной
    области. Это делается для того, чтобы проверить поведение системы, когда оно получает входные данные,
    на границах допустимых к обработке значений и выходящих за эти пределы.</li>
    <li>Тестирование с помощью таблиц принятия решений. Этот метод включает создание таблицы, в которой перечислены все
    возможные комбинации входных условий и соответствующих им действий. Это полезно для тестирования сложных
    бизнес-правил и логики.</li>
    <li>Тестирование на основе переходов из одного состояния в другое. Этот метод включает проверку поведения системы при
    переходе из одного состояния в другое. Это полезно для тестирования систем со сложной моделью состояний.</li>
    <li>Попарное тестирование. Этот метод включает в себя выбор набора входных комбинаций, которые охватывают все пары
    входных
    параметров. Это полезно для уменьшения количества необходимых тестовых случаев, при этом обеспечивая хорошее тестовое
    покрытие.</li>
    <li>Исследовательское тестирование. Этот метод включает в себя тестирование программного обеспечения без заранее
    определенного плана тестирования. Тестировщики используют свои знания и опыт для изучения программного обеспечения и
    выявления дефектов.</li>
    <li>Пользовательское приёмочное тестирование. Этот метод включает в себя тестирование программного обеспечения с точки
    зрения конечного пользователя. Пользователям предоставляются сценарии для тестирования и предоставления отзывов об
    удобстве использования и функциональности программного обеспечения.</li>
    </ol>
    <p>Эти методы можно использовать по отдельности или в сочетании для разработки эффективных тестовых сценариев,
    обеспечивающих хорошее тестовое покрытие и помогающих выявлять дефекты на ранних этапах жизненного цикла разработки
    программного обеспечения.</p>
    <h2 id="-">Примеры использования техник тест-дизайна</h2>
    <p>Приведем примеры использования различных техник тест-дизайна для разных объектов тестирования и ситуаций.</p>
    <h3 id="-">Применение классов эквивалентности</h3>
    <p>Предположим, что в кинотеатре есть возрастной фильтр для фильмов, который разрешает смотреть фильмы только людям старше
    18 лет с рейтингом R. Возрастной фильтр реализован в виде текстового поля, в которое пользователи могут ввести свой
    возраст. Технику эквивалентного разбиения можно использовать для получения тестовых примеров для этого возрастного
    фильтра следующим образом:</p>
    <ul>
    <li><strong>Разделение входных данных на допустимые и недопустимые возрастные диапазоны.</strong></li>
    <li>Допустимый возрастной диапазон: от 18 до 120 лет (при условии максимальной продолжительности жизни
    человека). [18, 120]</li>
    <li>Неверный возрастной диапазон: отрицательные числа и от 0 до 17, 121 и выше. (-00, 17], [121, +00]</li>
    </ul>
    <ul>
    <li><strong>Выбор репрезентативных значений из каждого класса эквивалентности для создания тестовых случаев.</strong></li>
    <li>Валидные тестовые случаи: 18, 25, 50, 100, 120.</li>
    <li><p>Невалидные тестовые случаи: -1, 0, 17, 121, 200.</p>
    </li>
    <li><p><strong>Тестирование каждого тестового примера, чтобы убедиться, что фильтр работает правильно.</strong></p>
    </li>
    <li>Валидные тестовые примеры должны позволять пользователю смотреть фильмы с рейтингом R.</li>
    <li>Невалидные тестовые примеры должны препятствовать просмотру пользователем фильмов с рейтингом R.</li>
    </ul>
    <p>Используя технику эквивалентного разбиения, мы создали набор тестовых случаев, которые охватывают входные данные и
    обеспечивают хорошее тестовое покрытие для возрастного фильтра. Это гарантирует правильную работу возрастного фильтра и
    не позволяет пользователям младше 18 или старше 120 лет смотреть фильмы с рейтингом R.</p>
    <h3 id="-">Применение анализа граничных значений</h3>
    <p>Предположим, что форма заявления о приеме на работу требует, чтобы соискатели указали свой многолетний опыт работы в
    соответствующей области. Форма имеет правило проверки, которое требует, чтобы соискатели имели опыт работы не менее 3
    лет. Технику анализа граничных значений можно использовать для получения тестовых примеров для этого поля следующим
    образом:</p>
    <ul>
    <li><strong>Определение граничного значения для этого поля.</strong></li>
    <li>Нижняя граница: 2 года опыта.</li>
    <li>Допустимое граничное значение: 3 года опыта.</li>
    <li>Верхнее граничное значение: 4 года опыта.</li>
    </ul>
    <ul>
    <li><strong>Создание тест-кейсов для каждого граничного значения.</strong></li>
    <li>Контрольный пример 1: укажите 2 года опыта работы. Это должно привести к сообщению об ошибке, поскольку заявитель не
    соответствует минимальным требованиям.</li>
    <li>Контрольный пример 2: введите 3 года опыта - это должно быть принято формой, поскольку оно соответствует минимальным
    требованиям.</li>
    <li>Контрольный пример 3: введите 4 года опыта - это должно быть принято формой, поскольку превышает минимальное
    требование.</li>
    </ul>
    <p>Используя анализ граничных значений, мы создали набор тест-кейсов, которые охватывают граничные значения и
    обеспечивают хорошее тестовое покрытие для поля. Это гарантирует, что форма заявки работает правильно, и не позволяет
    кандидатам, не отвечающим минимальным требованиям, подавать заявки на работу.</p>
    <h3 id="-">Тестирование с помощью таблиц принятия решений</h3>
    <p>Предположим, что веб-сайт позволяет пользователям покупать билеты на самолет. На веб-сайте представлены различные
    варианты ценообразования в зависимости от таких факторов, как дата поездки, класс поездки и возраст пассажира. Технику
    тестирования таблицы решений можно использовать для получения тестовых примеров для различных вариантов ценообразования
    следующим образом:</p>
    <ul>
    <li><strong>Определиние различных входных условий, влияющих на варианты ценообразования.</strong></li>
    <li>Условие 1: Дата поездки</li>
    <li>Условие 2: Класс путешествия</li>
    <li>Условие 3: Возраст пассажира</li>
    </ul>
    <ul>
    <li><strong>Определение различных действий, которые веб-сайт может выполнять в зависимости от входных условий.</strong></li>
    <li>Действие 1: Цена А</li>
    <li>Действие 2: Цена B</li>
    <li>Действие 3: Цена C</li>
    <li><p>Действие 4: Цена D</p>
    </li>
    <li><p><strong>Создание таблицы решений, в которой перечислены все возможные комбинации входных условий и соответствующих им
    действия.</strong></p>
    </li>
    </ul>
    <table>
    <thead>
    <tr>
    <th>Условие 1</th>
    <th>Условие 2</th>
    <th>Условие 3</th>
    <th>Действие</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>Дата A</td>
    <td>Класс A</td>
    <td>Возраст A</td>
    <td>Цена A</td>
    </tr>
    <tr>
    <td>Дата A</td>
    <td>Класс A</td>
    <td>Возраст B</td>
    <td>Цена B</td>
    </tr>
    <tr>
    <td>Дата A</td>
    <td>Класс B</td>
    <td>Возраст A</td>
    <td>Цена C</td>
    </tr>
    <tr>
    <td>Дата A</td>
    <td>Класс B</td>
    <td>Возраст B</td>
    <td>Цена D</td>
    </tr>
    <tr>
    <td>Дата B</td>
    <td>Класс A</td>
    <td>Возраст A</td>
    <td>Цена B</td>
    </tr>
    <tr>
    <td>Дата B</td>
    <td>Класс A</td>
    <td>Возраст B</td>
    <td>Цена C</td>
    </tr>
    <tr>
    <td>Дата B</td>
    <td>Класс B</td>
    <td>Возраст A</td>
    <td>Цена D</td>
    </tr>
    <tr>
    <td>Дата B</td>
    <td>Класс B</td>
    <td>Возраст B</td>
    <td>Цена C</td>
    </tr>
    </tbody>
    </table>
    <ul>
    <li><strong>Создание тест-кейсов для каждой комбинации входных условий и соответствующих им действий.</strong></li>
    <li>Тест-кейс 1: дата A, класс A, возраст A - это должно привести к цене A.</li>
    <li>Тест-кейс 2: дата A, класс A, возраст B - это должно привести к цене B.</li>
    <li>Тест-кейс 3: дата A, класс B, возраст A - это должно привести к цене C.</li>
    <li>Тест-кейс 4: дата A, класс B, возраст B - это должно привести к цене D.</li>
    <li>Тест-кейс 5: дата B, класс A, возраст A - это должно привести к цене B.</li>
    <li>Тест-кейс 6: дата B, класс A, возраст B - это должно привести к цене C.</li>
    <li>Тест-кейс 7: дата B, класс B, возраст A - это должно привести к цене D.</li>
    <li>Тест-кейс 8: дата B, класс B, возраст B - это должно привести к цене C.</li>
    </ul>
    <p>Используя тестирование с помощью таблиц принятия решений, мы создали набор тестовых случаев, которые охватывают все
    возможные комбинации входных условий и соответствующих им действий. Это гарантирует, что веб-сайт работает правильно, и
    предоставляет пользователям точные варианты ценообразования в зависимости от их входных условий.</p>
    <h3 id="-">Применение техники на основе состояний и переходов</h3>
    <p>Предположим, что компания-разработчик программного обеспечения имеет систему сообщений об ошибках, которая позволяет
    пользователям сообщать об ошибках в программном обеспечении. Система сообщений об ошибках имеет различные состояния,
    такие как «Новый», «В процессе», «Решено» и «Закрыто». Технику на основе состояний и переходов можно использовать для
    получения тестовых случаев для системы сообщений об ошибках следующим образом:</p>
    <ul>
    <li><strong>Определение различных состояний системы сообщений об ошибках.</strong></li>
    <li>Состояние 1: Новый — начальное состояние отчета об ошибке при его первом создании.</li>
    <li>Состояние 2: В процессе — состояние отчета об ошибке, когда над ним работает разработчик.</li>
    <li>Состояние 3: Решено — состояние сообщения об ошибке, когда оно исправлено и ожидает проверки.</li>
    <li>Состояние 4: Закрыто — окончательное состояние сообщения об ошибке, когда оно проверено и закрыто.</li>
    </ul>
    <ul>
    <li><strong>Определите различные переходы между состояниями.</strong></li>
    <li>Переход 1: Новый → В процессе - когда разработчик начинает работать над отчетом об ошибке.</li>
    <li>Переход 2: В процессе → Решено - когда разработчик исправил отчет об ошибке.</li>
    <li><p>Переход 3: Решено → Закрыто - когда тестировщик подтвердил, что сообщение об ошибке было исправлено.</p>
    </li>
    <li><p><strong>Создание диаграммы, которая показывает различные состояния и переходы.</strong></p>
    </li>
    </ul>
    <pre><code><span class="hljs-comment">Новый</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">В</span> <span class="hljs-comment">процессе</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">Решено</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span>&gt; <span class="hljs-comment">Закрыто</span>
    </code></pre><ul>
    <li><strong>Создание тестовых случаев для каждого перехода.</strong></li>
    <li>Тест-кейс 1: Новый → В процессе. Это должно перевести отчет об ошибке в состояние «В процессе».</li>
    <li>Тест-кейс 2: В процессе → Решено. Это должно перевести отчет об ошибке в состояние «Решено».</li>
    <li>Тест-кейс 3: Решено → Закрыто. Это должно перевести отчет об ошибке в состояние «Закрыто».</li>
    </ul>
    <p>Используя технику на основе состояний и переходов, мы создали набор тестовых случаев, которые охватывают все возможные
    переходы между различными состояниями системы отчетов об ошибках. Это гарантирует, что система работает правильно, а
    отчеты об ошибках обрабатываются должным образом по мере того, как они перемещаются по различным состояниям.</p>
    <h3 id="-">Применение техники попарного тестирования</h3>
    <p>Предположим, что на веб-сайте есть поисковая форма. Допускаются к вводу символы на латинице, кириллице и цифры.
    Разрешенные способы ввода: клавиатура и буфер обмена. Можно активировать и деактивировать чекбокс точного поиска. Длина
    поисковой строки ограничена 256 символами [1, 256].</p>
    <p>Технику
    попарного тестирования можно использовать для получения тест-кейсов для
    этой веб-формы следующим образом:</p>
    <ul>
    <li><strong>Определение различных параметров, влияющих на поисковый запрос.</strong></li>
    <li>Параметр 1: Тип данных</li>
    <li>Параметр 2: Способ ввода</li>
    <li>Параметр 3: Чекбокс</li>
    <li>Параметр 4: Длина</li>
    </ul>
    <ul>
    <li><strong>Определите различные значения, которые может принимать каждый параметр.</strong></li>
    <li>Тип данных: кириллица, латиница, цифры;</li>
    <li>Способ ввода: клавиатура, буфер обмена;</li>
    <li>Чекбокс: активирован, не активирован;</li>
    <li>Длина: 1-256.</li>
    </ul>
    <ul>
    <li><strong>Создание таблицы попарного тестирования, в которой перечислены все возможные комбинации значений параметров.</strong></li>
    </ul>
    <table>
    <thead>
    <tr>
    <th>Тип данных</th>
    <th>Способ ввода</th>
    <th>Чекбокс</th>
    <th>Длина</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>кириллица</td>
    <td>клавиатура</td>
    <td>активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>кириллица</td>
    <td>клавиатура</td>
    <td>не активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>кириллица</td>
    <td>буфер обмена</td>
    <td>активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>кириллица</td>
    <td>буфер обмена</td>
    <td>не активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>латиница</td>
    <td>клавиатура</td>
    <td>активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>латиница</td>
    <td>клавиатура</td>
    <td>не активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>латиница</td>
    <td>буфер обмена</td>
    <td>активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>латиница</td>
    <td>буфер обмена</td>
    <td>не активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>цифры</td>
    <td>клавиатура</td>
    <td>активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>цифры</td>
    <td>клавиатура</td>
    <td>не активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>цифры</td>
    <td>буфер обмена</td>
    <td>активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>цифры</td>
    <td>буфер обмена</td>
    <td>не активирован</td>
    <td>1-256</td>
    </tr>
    </tbody>
    </table>
    <p>Эту таблицу можно дополнить следующими проверками, которые добавляют негативные тест-кейсы:</p>
    <table>
    <thead>
    <tr>
    <th>Тип данных</th>
    <th>Способ ввода</th>
    <th>Чекбокс</th>
    <th>Длина</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>кириллица</td>
    <td>рисование</td>
    <td>не активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>латиница</td>
    <td>голос</td>
    <td>активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>спец символы</td>
    <td>буфер обмена</td>
    <td>не активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>пробелы</td>
    <td>клавиатура</td>
    <td>активирован</td>
    <td>1-256</td>
    </tr>
    <tr>
    <td>пустое поле</td>
    <td></td>
    <td></td>
    <td></td>
    </tr>
    <tr>
    <td>кириллица</td>
    <td>буфер обмена</td>
    <td>не активирован</td>
    <td>256&lt;</td>
    </tr>
    </tbody>
    </table>
    <p>С помощью техники попарного тестирования мы создали набор тест-кейсов, которые охватывают все возможные комбинации
    значений параметров в поисковом поле. Это гарантирует, что поле поиска будет тщательно протестировано, а любые ошибки
    или проблемы будут выявлены и исправлены до запуска веб-сайта.</p>
    <h3 id="-">Применение техники исследовательского тестирования</h3>
    <p>Предположим, что производитель карандашей хочет проверить долговечность своей новой конструкции карандашей. Технику
    исследовательского тестирования можно использовать для получения тестовых случаев для этого карандаша следующим образом:</p>
    <ul>
    <li><strong>Определение различных аспектов карандаша, характеризующих его долговечность.</strong></li>
    <li>Аспект 1: Целостность грифеля карандаша.</li>
    <li>Аспект 2: Материал корпуса карандаша.</li>
    <li>Аспект 3: Качество карандашного ластика.</li>
    </ul>
    <ul>
    <li><strong>Определение различных способов проверки карандаша.</strong></li>
    <li>Тест 1: тест на падение. Падение карандаша с разной высоты для проверки его прочности.</li>
    <li>Тест 2: тест на заточку. Заточка карандаша до разного диаметра кончика грифеля для проверки его стойкости.</li>
    <li>Тест 3: тест материала. Проверка размещения карандаша в руке и на различных поверхностях.</li>
    <li>Тест 4: тест ластика. Проверка качества ластика путем стирания различных типов меток на разных поверхностях.</li>
    </ul>
    <ul>
    <li><strong>Проведение тестов в исследовательской манере, делая наблюдения и записывая результаты.</strong></li>
    <li>Тест 1: тест на падение. Бросайте карандаш с разной высоты и наблюдайте за любым повреждением грифеля или корпуса
    карандаша.</li>
    <li>Тест 2: тест на заточку. Заточите карандаш в разной степени и наблюдайте за любой поломкой или ослаблением кончика
    карандаша.</li>
    <li>Тест 3: тест материала. Проверьте удобство размещения карандаша в руке и на различных поверхностях, обратите внимание
    на скатываемость карандаша с поверхностей под углом.</li>
    <li>Тест 4: тест ластика. Проверьте качество ластика, стирая различные типы меток на разных поверхностях и наблюдая за
    пятнами или остатками ластика.</li>
    </ul>
    <ul>
    <li><strong>Используйте наблюдения и результаты для создания новых тестов или изменения существующих тестов, чтобы дополнительно
    изучить долговечность карандаша.</strong></li>
    <li>Тест 5: тест на долговечность. Проверьте долговечность карандаша с течением времени, регулярно используя его в течение
    нескольких недель или месяцев.</li>
    <li>Тест 6: испытание под давлением. Проверьте прочность карандаша, прикладывая давление к стержню во время использования.</li>
    </ul>
    <p>Используя исследовательское тестирование, мы создали набор тестов, которые охватывают различные аспекты долговечности
    карандаша и позволяют нам делать наблюдения и записывать результаты в исследовательской манере. Это гарантирует, что
    карандаш будет тщательно протестирован, а любые недостатки или проблемы будут выявлены и устранены до того, как он будет
    выпущен на рынок.</p>
    <h3 id="-">Применение техники пользовательского приёмочного тестирования</h3>
    <p>Предположим, что компания-разработчик игр создала новую карточную игру для консоли и хочет провести приёмочное
    пользовательское тестирование, прежде чем выпустить ее на рынок. Технику пользовательского приемочного тестирования
    можно использовать для получения тестовых примеров для консольной карточной игры следующим образом:</p>
    <ul>
    <li><strong>Определение различных особенностей и функциональных возможностей консольной карточной игры.</strong></li>
    <li>Особенность 1: правила игры и механика.</li>
    <li>Особенность 2: графика и дизайн карт.</li>
    <li>Особенность 3: Пользовательский интерфейс и навигация.</li>
    <li>Особенность 4: Мультиплеер.</li>
    </ul>
    <ul>
    <li><strong>Определение различных пользовательских сценариев для тестирования консольной карточной игры.</strong></li>
    <li>Сценарий 1: одиночная игра - один игрок играет против компьютера.</li>
    <li>Сценарий 2: многопользовательская игра - два игрока играют друг против друга.</li>
    <li>Сценарий 3: обучение игре - новые игроки учатся играть в игру.</li>
    <li>Сценарий 4: настройки игры - настройка параметров игры, таких как уровень сложности и звук.</li>
    </ul>
    <ul>
    <li><strong>Провести тесты в реальных условиях, когда в игру играют реальные пользователи и оставляют отзывы.</strong></li>
    <li>Тест 1: одиночная игра. Попросите пользователей сыграть в игру против компьютера и оставить отзыв об игровой механике,
    графике карт и пользовательском интерфейсе.</li>
    <li>Тест 2: Многопользовательская игра. Попросите пользователей сыграть в игру друг против друга и оставить отзыв о
    многопользовательской игре и общем игровом процессе.</li>
    <li>Тест 3: Обучение игре. Предложите новым игрокам пройти обучение игре и оставить отзыв о ясности и эффективности
    обучения.</li>
    <li>Тест 4: Настройки игры. Попросите пользователей настроить параметры игры и оставить отзыв о простоте использования и
    эффективности параметров.</li>
    </ul>
    <ul>
    <li><strong>Используйте отзывы и результаты, чтобы внести необходимые улучшения или изменения в карточную игру.</strong></li>
    <li>Внести изменения в правила и механику игры на основе отзывов пользователей.</li>
    <li>Улучшите графику и дизайн карт, чтобы улучшить общий игровой процесс.</li>
    <li>Внесите изменения в пользовательский интерфейс и навигацию на основе отзывов пользователей.</li>
    <li>Улучшите функциональность многопользовательской игры, чтобы обеспечить плавный и увлекательный многопользовательский
    опыт.</li>
    </ul>
    <p>С помощью пользовательского приёмочного тестирования мы создали набор тестов, которые охватывают различные функции
    карточной игры и позволяют нам собирать отзывы реальных пользователей. Это гарантирует, что
    карточная игра соответствует ожиданиям пользователей и тщательно тестируется перед выпуском на рынок.</p>

    <h1 id="-ui">Тестирование UI</h1>
    <p>UI тестирование, также известное как тестирование пользовательского интерфейса, представляет
    собой тип тестирования программного обеспечения, которое фокусируется на графическом пользовательском интерфейсе
    приложения. Тестирование пользовательского интерфейса полезно для обеспечения того, чтобы интерфейс приложения работал
    должным образом, а также чтобы им было легко пользоваться и ориентироваться.</p>
    <p>Тестирование пользовательского интерфейса важно для выявления проблем с пользовательским интерфейсом, таких как
    неработающие ссылки, неправильное форматирование или некорректное поведение при взаимодействии с интерфейсом. Оно также
    может помочь убедиться в том, что приложение соответствует ожиданиям пользователя и является удобным для использования.</p>
    <p>Тестирование пользовательского интерфейса может быть полезно для множества различных приложений, таких как
    веб-приложения, мобильные приложения и настольные приложения. Его можно использовать для тестирования широкого спектра
    элементов пользовательского интерфейса, включая кнопки, меню, формы и другие интерактивные элементы.</p>
    <h2 id="-ui-">Несколько примеров UI тестирования:</h2>
    <ol>
    <li><p>Функциональное тестирование. Этот тип тестирования гарантирует, что компоненты пользовательского интерфейса, такие
    как кнопки и формы, работают должным образом. Например, если пользователь нажимает кнопку, UI должен выполнить
    ожидаемое действие.</p>
    </li>
    <li><p>Юзабилити-тестирование. Этот тип тестирования гарантирует, что пользовательский интерфейс прост в использовании и
    навигации. Например, проверяется подходящий размер шрифта и визуально привлекательная цветовая схема.</p>
    </li>
    <li><p>Тестирование производительности. Этот тип тестирования гарантирует, что пользовательский интерфейс отзывчив и хорошо
    работает в различных условиях. Например, проверяется насколько быстро загружается интерфейс и как он работает при
    одновременном доступе к нему нескольких пользователей.</p>
    </li>
    <li><p>Тестирование совместимости. Этот тип тестирования гарантирует, что пользовательский интерфейс хорошо работает на
    различных устройствах и платформах. Например, проверяется правильность отображения приложения на экранах разных
    размеров и разрешений.</p>
    </li>
    <li><p>Тестирование доступности. Этот тип тестирования гарантирует, что пользовательский интерфейс доступен для
    пользователей с ограниченными возможностями. Например, он проверяет, можно ли использовать приложение с программой
    чтения с экрана и что используемые цвета доступны пользователям с цветовой слепотой.</p>
    </li>
    </ol>
    <p>Это всего лишь несколько примеров типов тестирования пользовательского интерфейса, которые можно выполнить, чтобы
    убедиться, что пользовательский интерфейс приложения работает должным образом.</p>

    <h1 id="-">Ссылки на дополнительные материалы</h1>
    <h2 id="-">Теория тестирования</h2>
    <ul>
    <li><a href="https://glossary.istqb.org/en_US/search">ISTQB Glossary</a></li>
    <li><a href="https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения">wikipedia</a></li>
    <li><a href="https://habr.com/ru/post/549054/">Фундаментальная теория тестирования</a></li>
    <li><a href="https://habr.com/ru/post/699990/">Принципы тестирования: нас 7</a></li>
    <li><a href="https://svyatoslav.biz/software_testing_book/">Книга «Тестирование программного обеспечения. Базовый курс.»</a></li>
    <li><a href="https://youtu.be/jFDMhgcvDh4?list=LL">QA Manual. Full Course for Beginners 2022</a></li>
    <li><a href="https://youtu.be/3kgdKE7ndvI?list=LL">Тестировщик с нуля за 6 часов / QA / Тестирование по полный курс</a></li>
    <li><a href="https://openedu.ru/course/spbstu/SOFTTEST/?session=spring_2023">Введение в тестирование программного обеспечения</a></li>
    <li><a href="https://stepik.org/course/16478/syllabus">Тестирование ПО: подготовка к сертификации ISTQB Foundation</a></li>
    <li><a href="https://vladislaveremeev.gitbook.io/qa_bible/">Библия QA</a></li>
    </ul>
    <h2 id="-">Чек-лист</h2>
    <ul>
    <li><a href="https://habr.com/ru/post/577448/">Чек-лист — как тестировать поиск</a></li>
    <li><a href="https://habr.com/ru/post/534190/">Чек-лист тестирования мобильных приложений</a></li>
    <li><a href="https://habr.com/ru/post/542422/">Чек-лист тестирования WEB приложений</a></li>
    <li><a href="https://habr.com/ru/company/surfstudio/blog/575360/">Структура, содержание и процесс написания проверок</a></li>
    </ul>
    <h2 id="-">Тест-кейс</h2>
    <ul>
    <li><a href="https://www.software-testing.ru/library/testing/general-testing/1991-2014-08-25-11-55-39">Что такое тест-кейс и как его писать</a></li>
    <li><a href="https://habr.com/ru/post/246463/">Пишем максимально эффективный тест-кейс</a></li>
    </ul>
    <h2 id="-">Регрессионное тестирование</h2>
    <ul>
    <li><a href="https://crashtest.by/regression-testing/">ЧТО ТАКОЕ РЕГРЕССИОННОЕ ТЕСТИРОВАНИЕ?</a></li>
    <li><a href="https://habr.com/ru/company/typeable/blog/583062/">Антирегрессионное тестирование – минимизируйте затраты</a></li>
    <li><a href="https://habr.com/ru/post/358142/">В чём разница Smoke, Sanity, Regression, Re-test и как их различать?</a></li>
    </ul>
    <h2 id="-">Техники тест-дизайна</h2>
    <ul>
    <li><a href="https://www.youtube.com/watch?v=i7PkPzRU6EI">Техники тест дизайна Лёша Маршал</a></li>
    <li><a href="https://youtu.be/-Lu27061BiY">Попарное тестирование / Pairwise testing Artsiom Rusau QA Life</a></li>
    <li><a href="https://youtu.be/e84cyz2HC24">Тестирование состояний и переходов / Таблица принятия решений</a></li>
    <li><a href="https://quality-lab.ru/blog/roles-and-responsibilities-of-test-designer/">Кто такие тест-дизайнеры и зачем они нужны</a></li>
    <li><a href="https://crashtest.by/test-analysis-and-test-design/">АНАЛИЗ ТЕСТИРОВАНИЯ И ТЕСТ ДИЗАЙН</a></li>
    <li><a href="https://www.pairwise.org/tools.html">Тулы для комбинаторных техник тест-дизайна</a></li>
    <li><a href="https://pairwise.teremokgames.com/">Инструмент для попарного тестирования онлайн</a></li>
    </ul>

    <hr>

    <h1 id="-">Фундаментальные веб-технологии</h1>
    <p>Чтобы тестировщик лучше понимал, из чего состоят и как устроены современные веб-страницы, будет крайне полезно иметь хотя бы базовое представление о HTML, CSS, JavaScript. Эти знания также помогут локализовывать ошибки, связанные с конкретными элементами на странице, быстро находить их и при необходимости менять на клиентской стороне. </p>
    <p>Также важно уметь использовать консоль разработчика в браузере (как минимум работать с элементами на странице и сетевыми запросами).</p>

    <h1 id="-html">Основы HTML</h1>
    <h2 id="-html">Что такое HTML</h2>
    <p>HTML (Hypertext Markup Language) - это код, который используется для структурирования и отображения вебстраницы и её
    контента. Например, контент (какой-то текст) может быть представлен в виде множества параграфов, маркированных списков
    или с использованием изображений и таблиц данных.</p>
    <p>Тут будет краткое знакомство с разметкой, так как цель этого руководства только познакомить с ней.
    Более подробно уже надо будет смотреть документацию, читать статьи от специалистов в этой теме.</p>
    <p>HTML-элементы — основа языка HTML. Каждый HTML-документ состоит из дерева HTML-элементов и текста. Каждый HTML-элемент обозначается начальным (открывающим) и конечным (закрывающим) тегом. Открывающий и закрывающий теги содержат имя элемента.</p>
    <p>Все HTML-элементы делятся на пять типов:</p>
    <ol>
    <li>пустые элементы — <code>&lt;area&gt;</code>, <code>&lt;base&gt;</code>, <code>&lt;br&gt;</code>, <code>&lt;col&gt;</code>, <code>&lt;embed&gt;</code>, <code>&lt;hr&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;menuitem&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;param&gt;</code>, <code>&lt;source&gt;</code>, <code>&lt;track&gt;</code>, <code>&lt;wbr&gt;</code>;</li>
    <li>элементы с неформатированным текстом — <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code>;</li>
    <li>элементы, выводящие неформатированный текст — <code>&lt;textarea&gt;</code>, <code>&lt;title&gt;</code>;</li>
    <li>элементы из другого пространства имён — MathML и SVG;</li>
    <li>обычные элементы — все остальные элементы (<code>&lt;p&gt;text&lt;/p&gt;</code>, <code>&lt;b&gt;text&lt;/b&gt;</code> и т.д.).</li>
    </ol>
    <h2 id="-html-">Примеры HTML элементов</h2>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Это параграф<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../img/html_element.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Альтернативный текст"</span>&gt;</span>
    </code></pre>
    <h3 id="-">Главными частями нашего элемента являются:</h3>
    <ol>
    <li><strong>Открывающий тег (Opening tag)</strong>. Состоит из имени элемента (в данном случае, <code>p</code>), заключённого в
    открывающие и закрывающие угловые скобки. Открывающий тег указывает, где элемент начинается
    или начинает действовать, в данном случае — где начинается абзац.</li>
    <li><strong>Закрывающий тег (Closing tag)</strong>. Это то же самое, что и открывающий тег, за исключением того, что он
    включает в себя косую черту перед именем элемента. Закрывающий элемент указывает, где элемент
    заканчивается, в данном случае — где заканчивается абзац. Отсутствие закрывающего тега является
    одной из наиболее распространённых ошибок начинающих и может приводить к странным
    результатам.</li>
    <li><strong>Контент (Content)</strong>. Это контент элемента, который в данном случае является просто текстом.</li>
    <li><strong>Элемент(Element)</strong>. Открывающий тег, закрывающий тег и контент вместе составляют элемент.</li>
    </ol>
    <h3 id="-">Элементы также могут иметь атрибуты, которые выглядят так:</h3>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://yandex.ru"</span>&gt;</span>Яндекс<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    </code></pre>
    <p>У тегов могут быть какие-либо свойства. Например, у ссылки есть атрибут <code>href</code> со значением <code>https://yandex.ru</code> в кавычках.</p>
    <h3 id="-">Атрибут всегда должен иметь:</h3>
    <ol>
    <li>пробел между ним и именем элемента (или предыдущим атрибутом, если элемент уже имеет один или несколько атрибутов);</li>
    <li>имя атрибута, за которым следует знак равенства;</li>
    <li>значение атрибута, заключённое с двух сторон в кавычки.</li>
    </ol>
    <h2 id="-">Вложенные элементы</h2>
    <p>Вы также можете располагать элементы внутри других элементов — это называется вложением. Если мы хотим заявить, что наша кошка очень раздражена, мы можем заключить слово &quot;очень&quot; в элемент <code>&lt;strong&gt;</code> , который указывает, что слово должно быть сильно акцентированно:</p>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Это слово выделено<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>жирным<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> шрифтом<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    </code></pre>
    <p>Будет выглядеть в браузере так:</p>
    <blockquote>
    <p>Это слово выделено <strong>жирным</strong> шрифтом</p>
    </blockquote>
    <h2 id="-">Пустые элементы</h2>
    <p>Некоторые элементы не имеют контента, и называются пустыми элементами.</p>
    <pre><code class="lang-html">&lt;<span class="hljs-selector-tag">img</span> src=<span class="hljs-string">"https://i.gifer.com/2GU.gif"</span> alt=<span class="hljs-string">"Моё тестовое изображение"</span>&gt;
    </code></pre>
    <p>Он содержит два атрибута, но не имеет закрывающего тега <code>&lt;/img&gt;</code>, и никакого внутреннего контента. Это потому, что элемент изображения не оборачивает контент для влияния на него. Его целью является вставка изображения в HTML страницу в нужном месте.</p>
    <h2 id="-html-">Анатомия HTML документа</h2>
    <p>Мы завершили изучение основ отдельных HTML элементов, но они не очень полезны сами по себе. Теперь посмотрим, как
    отдельные элементы объединяются в целую HTML страницу.</p>
    <p>Давайте откроем текстовый файл <code>demo-1.html</code>:</p>
    <pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Моя тестовая страница<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://loremflickr.com/600/600"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Моё тестовое изображение"</span>&gt;</span>
    
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
    </code></pre>
    <p>Здесь мы имеем:</p>
    <ul>
    <li><code>!DOCTYPE html</code> — доктайп. В прошлом, когда HTML был молод (около 1991/1992), доктайпы должны были выступать в качестве ссылки на набор правил, которым HTML страница должна была следовать, чтобы считаться хорошим HTML, что могло означать автоматическую проверку ошибок и другие полезные вещи. Однако в наши дни, никто не заботится об этом, и они на самом деле просто исторический артефакт, который должен быть включён для того, что бы все работало правильно. На данный момент это все, что вам нужно знать.</li>
    <li><code>html</code> — Этот элемент оборачивает весь контент на всей странице, и иногда известен как корневой элемент.</li>
    <li><code>head</code> — Этот элемент выступает в качестве контейнера для всего, что вы пожелаете включить на HTML страницу, но не являющегося контентом, который вы показываете пользователям вашей страницы. К ним относятся такие вещи, как ключевые слова и описание страницы, которые будут появляться в результатах поиска, CSS стили нашего контента, кодировка и многое другое.</li>
    <li><code>body</code> —  В нем содержится весь контент, который вы хотите показывать пользователям, когда они посещают вашу страницу, будь то текст, изображения, видео, игры, проигрываемые аудиодорожки или что-то ещё.</li>
    <li><code>meta charset=&quot;utf-8&quot;</code> — этот элемент устанавливает UTF-8 кодировку вашего документа, которая включает в себя большинство символов из всех известных человечеству языков. По сути, теперь документ может обрабатывать любой текстовый контент, который вы в него вложите. Нет причин не устанавливать её, так как это может помочь избежать некоторых проблем в дальнейшем.</li>
    <li><code>title</code> —  Этот элемент устанавливает заголовок для вашей страницы, который является названием, появляющимся на вкладке браузера загружаемой страницы, и используется для описания страницы, когда вы добавляете её в закладки/избранное.</li>
    </ul>
    <p>Можно открыть документ demo-1.html в браузере и посмотреть, как он выглядит.</p>
    <h2 id="-">Изображения</h2>
    <p>Давайте снова обратим наше внимание на элемент изображения:</p>
    <pre><code class="lang-html">&lt;<span class="hljs-selector-tag">img</span> src=<span class="hljs-string">"https://loremflickr.com/600/600"</span> alt=<span class="hljs-string">"Моё тестовое изображение"</span>&gt;
    </code></pre>
    <p>Как было сказано раньше, код встраивает изображение на нашу страницу в нужном месте. Это делается с
    помощью атрибута <code>src</code> (source, источник), который содержит путь к нашему файлу изображения. Путь может
    быть указан ссылкой на любую картинку из Интернета как в нашем случае или связывать файл, находящийся
    на вашем диске. </p>
    <p>Мы также включили атрибут <code>alt</code> (alternative, альтернатива). В этом атрибуте, вы указываете поясняющий текст
    для пользователей, которые не могут увидеть изображение, возможно, по следующим причинам:</p>
    <ol>
    <li>У них присутствуют нарушения зрения. Пользователи со значительным нарушением зрения часто
    используют инструменты, называемые Screen Readers (экранные дикторы), которые читают для них
    альтернативный текст.</li>
    <li>Что-то пошло не так, в результате чего изображение не отобразилось.</li>
    </ol>
    <p>Альтернативный текст - это &quot;пояснительный текст&quot;. Он должен предоставить читателю достаточно
    информации, чтобы иметь представление о том, что передаёт изображение. В этом примере наш текст &quot;Моё
    тестовое изображение&quot; не годится. Намного лучшей альтернативой для нашей картинки будет &quot;gif with a cat&quot;.</p>
    <h2 id="-">Заголовки</h2>
    <p>Элементы заголовка позволяют указывать определённые части контента в качестве заголовков или
    подзаголовков. Точно так же, как книга имеет название, названия глав и подзаголовков, HTML документ
    может содержать то же самое. HTML включает шесть уровней заголовков: <code>h1</code>, <code>h2</code>, <code>h3</code>...</p>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Мой главный заголовок<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Мой заголовок верхнего уровня<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Мой подзаголовок<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>Мой под-подзаголовок<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
    </code></pre>
    <h2 id="-">Абзацы</h2>
    <p>Как было сказано ранее, элемент p предназначен для абзацев текста; вы будете использовать их регулярно
    при разметке текстового контента:</p>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Это одиночный абзац<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    </code></pre>
    <h2 id="-">Списки</h2>
    <p>Большая часть веб-контента является списками и HTML имеет специальные элементы для них. Разметка
    списка всегда состоит по меньшей мере из двух элементов. Наиболее распространёнными типами списков
    являются нумерованные и ненумерованные списки:</p>
    <ol>
    <li><em>Ненумерованные списки</em> - это списки, где порядок пунктов не имеет значения, как в списке
    покупок. Они оборачиваются в элемент <code>ul</code>.</li>
    <li><em>Нумерованные списки</em> - это списки, где порядок пунктов имеет значение, как в рецепте. Они
    оборачиваются в элемент <code>ol</code>.</li>
    </ol>
    <p>Каждый пункт внутри списков располагается внутри элемента <code>li</code> (list item, элемент списка).
    Например, если мы хотим включить часть следующего фрагмента абзаца в список:</p>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Купить в магазине:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Чай<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Кофе<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Сахар<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Занести домой.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    </code></pre>
    <h2 id="-">Ссылки</h2>
    <p>Ссылки очень важны — это то, что делает Интернет Интернетом. Чтобы добавить ссылку, нам нужно
    использовать простой элемент — <code>a</code> — a это сокращение от &quot;anchor&quot; (&quot;якорь&quot;). Чтобы текст в вашем абзаце
    стал ссылкой, выполните следующие действия:</p>
    <ol>
    <li>Выберите текст.</li>
    <li>Обернем текст в элемент a, например так:</li>
    </ol>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>Текст ссылки<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    </code></pre>
    <ol>
    <li>Зададим элементу a атрибут <code>href</code>, например так:</li>
    </ol>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">""</span>&gt;</span>Текст ссылки<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    </code></pre>
    <ol>
    <li>Заполним значение этого атрибута веб-адресом, на который хотим указать ссылку:</li>
    </ol>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://yandex.ru"</span>&gt;</span>Текст ссылки<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    </code></pre>
    <p>Это была вводная краткая часть о html. В нём гораздо больше элементов, чем тут перечислено, это выйдет на целую книгу.</p>
    <p>Дополнительно про HTML вы можете прочитать тут:</p>
    <p><a href="https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/HTML_basics">developer.mozilla.org</a>
    <a href="https://html5css.ru/html/default.php">html5css.ru</a>
    <a href="https://html5book.ru/html-html5/">html5book.ru</a></p>

    <h1 id="-css">Основы CSS</h1>
    <p>CSS (Cascading Style Sheets) — это код, который вы используете для стилизации вашей веб-страницы. Основы
    CSS помогут сделать текст черным или красным, поставить контент в определённом месте на экране,
    украсить веб-страницу с помощью фоновых изображений и цветов.</p>
    <p>Как и HTML, CSS на самом деле не является языком программирования. Это не язык разметки - это язык
    таблицы стилей. Это означает, что он позволяет применять стили выборочно к элементам в документах HTML.
    Например, чтобы выбрать все элементы абзаца на HTML странице и изменить текст внутри них с чёрного
    на красный, необходимо написать этот CSS код:</p>
    <pre><code class="lang-css"><span class="hljs-selector-tag">p</span> {
     <span class="hljs-attribute">color</span>: red;
    }
    </code></pre>
    <p>Давайте вставим эти три строки CSS в новый файл в ваш текстовый редактор, а затем сохраним файл
    как <code>style.css</code> в вашей папке <code>styles</code> (в ту же папку, где находится наша страница «первая HTML-страница.html»).</p>
    <p>Но нам всё равно нужно применить CSS к нашему HTML документу. В противном случае, CSS стиль не повлияет на то, как ваш
    браузер отобразит HTML документ.</p>
    <p>Сначала подготовьте проект для работы.</p>
    <p>Создайте папку, например <code>lesson-css</code>.</p>
    <p>В ней создайте файл <code>demo-2.html</code> и <code>style.css</code>.</p>
    <p>В файл <code>style.css</code> поместите и сохраните следующее:</p>
    <pre><code class="lang-css"><span class="hljs-selector-tag">p</span> {
        <span class="hljs-attribute">color</span>: red;
    }
    </code></pre>
    <p>Откройте <code>demo-2.html</code> в любом текстовом редакторе и вставьте следующую строку куда-нибудь в шапку, между <code>head</code> тегами:</p>
    <pre><code class="lang-html">
    &lt;link href=<span class="hljs-string">"style.css"</span> <span class="hljs-keyword">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"text/css"</span>&gt;
    </code></pre>
    <p>Сохраните <code>demo-2.html</code> и загрузите его в вашем браузере.</p>
    <p>Если текст вашего абзаца теперь красный, примите наши поздравления! Вы написали свой первый успешный CSS!</p>
    <h2 id="-css">Анатомия набора правил CSS</h2>
    <p>Давайте взглянем на вышеупомянутый CSS немного более подробно:</p>
    <pre><code class="lang-css"><span class="hljs-selector-tag">p</span> {
        <span class="hljs-attribute">color</span>: red;
    }
    </code></pre>
    <p>Вся структура называется набором правил (но зачастую для краткости &quot;правило&quot;). Отметим также имена отдельных частей:</p>
    <ul>
    <li><p><strong>Селектор (Selector)</strong></p>
    <p>Имя HTML-элемента в начале набора правил. Он выбирает элемент(ы) для применения стиля (в данном
    случае, элементы <code>p</code>). Для стилизации другого элемента, просто измените селектор.</p>
    </li>
    <li><p><strong>Объявление (Declaration)</strong></p>
    <p>Единственное правило, например color: red; указывает, какие из свойств элемента вы хотите стилизовать.</p>
    </li>
    <li><p><strong>Свойства (Properties)</strong></p>
    <p>Способы, которыми вы можете стилизовать определённый HTML-элемент (в данном случае, color является
    свойством для элементов <code>p</code>). В CSS вы выбираете, какие свойства вы хотите затронуть в вашем правиле.</p>
    </li>
    <li><p><strong>Значение свойства (Property value)</strong></p>
    <p>Справа от свойства, после двоеточия, у нас есть значение свойства, которое выбирает одно из множества
    возможных признаков для данного свойства (существует множество значений color, помимо red)</p>
    </li>
    </ul>
    <p>Обратите внимание на важные части синтаксиса:</p>
    <ul>
    <li>Каждый набор правил (кроме селектора) должен быть обёрнут в фигурные скобки <code>{}</code>.</li>
    <li>В каждом объявлении необходимо использовать двоеточие <code>:</code>, чтобы отделить свойство от его
    значений.</li>
    <li>В каждом наборе правил вы должны использовать точку с запятой <code>;</code>, чтобы отделить каждое
    объявление от следующего.</li>
    </ul>
    <p>Таким образом, чтобы изменить несколько значений свойств сразу, вам просто нужно написать их, разделяя
    точкой с запятой, например так:</p>
    <pre><code class="lang-css"><span class="hljs-selector-tag">p</span> {
     <span class="hljs-attribute">color</span>: red;
     <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
     <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
    }
    </code></pre>
    <h2 id="-">Выбор нескольких элементов</h2>
    <p>Вы также можете выбрать несколько элементов разного типа и применить единый набор правил для всех из
    них. Добавьте несколько селекторов, разделённых запятыми. Например:</p>
    <pre><code class="lang-css"><span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">li</span>,<span class="hljs-selector-tag">h1</span> {
     <span class="hljs-attribute">color</span>: red;
    }
    </code></pre>
    <h2 id="-">Разные типы селекторов</h2>
    <p>Существует множество различных типов селектора. Выше мы рассматривали только селектор элементов,
    который выбирает все элементы определённого типа в HTML документе. Но мы можем сделать выбор более
    конкретным. Вот некоторые из наиболее распространённых типов селекторов:</p>
    <table>
    <thead>
    <tr>
    <th>Имя селектора</th>
    <th>Что выбирает</th>
    <th>Пример</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>Селектор элемента (иногда называемый селектором тега или типа)</td>
    <td>Все HTML-элемент(ы) указанного типа.</td>
    <td>p Выбирает <code>&lt;p&gt;</code></td>
    </tr>
    <tr>
    <td>ID селектор</td>
    <td>Элемент на странице с указанным ID на данной HTML. Лучше всего использовать один элемент для каждого ID (и конечно один ID для каждого элемента), даже если вам разрешено использовать один и тот же ID для нескольких элементов.</td>
    <td>#my-id Выбирает <code>&lt;p id=&quot;my-id&quot;&gt;</code> или <code>&lt;a id=&quot;my-id&quot;&gt;</code></td>
    </tr>
    <tr>
    <td>Селектор класса</td>
    <td>Элемент(ы) на странице с указанным классом (множество экземпляров класса может объявляться на странице).</td>
    <td>.my-class Выбирает <code>&lt;p class=&quot;myclass&quot;&gt;</code> и <code>&lt;a class=&quot;my-class&quot;&gt;</code></td>
    </tr>
    <tr>
    <td>Селектор атрибута</td>
    <td>Элемент(ы) на странице с указанным атрибутом.</td>
    <td>img[src] Выбирает <code>&lt;img src=&quot;myimage.png&quot;&gt;</code> но не <code>&lt;img&gt;</code></td>
    </tr>
    <tr>
    <td>Селектор псевдокласса</td>
    <td>Указанные элемент(ы), но только в случае определённого состояния, например, при наведении курсора.</td>
    <td>a:hover Выбирает <code>&lt;a&gt;</code>, но только тогда, когда указатель мыши наведён на ссылку.</td>
    </tr>
    </tbody>
    </table>
    <p>Существует ещё много селекторов для изучения. В Интернете можно найти описание для каждого из них.</p>
    <h2 id="-">Шрифты и текст</h2>
    <p>Теперь, когда мы изучили некоторые основы CSS, давайте добавим ещё несколько правил и информацию в
    наш файл <code>style.css</code>, чтобы наш пример хорошо выглядел. Прежде всего, давайте сделаем, чтобы наши шрифты
    и текст выглядели немного лучше.</p>
    <ol>
    <li>Давайте зададим шрифт нашей страницы. По умолчанию браузер задает всему тексту шрифт Times
    NewRoman, но как-то это не современно. Мы свяжем наш сайт со шрифтом Roboto взятый
    с <a href="https://fonts.google.com/">Google Font</a>. Для этого просто добавьте элемент <code>&lt;link&gt;</code> где-нибудь внутри шапки
    вашего <code>index.html</code> (снова, в любом месте между тегами <code>&lt;head&gt;</code> и <code>&lt;/head&gt;</code>). Это будет выглядеть примерно
    так:</li>
    </ol>
    <pre><code class="lang-html">
    &lt;<span class="hljs-keyword">link</span> href=<span class="hljs-string">"https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"</span> rel=<span class="hljs-string">"stylesheet"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">'text/css'</span>&gt;
    </code></pre>
    <p>Этот код связывает вашу страницу с таблицей стилями, которая загружает семейство шрифтов
    Roboto вместе с вашей страницей и позволяет вам применять их к вашим HTML-элементам
    используя свою собственную таблицу стилей.</p>
    <ol>
    <li>Затем, удалите существующее правило в вашем <code>style.css</code> файле. Это был хороший тест, но красный
    текст, на самом деле, не очень хорошо выглядит.</li>
    <li>Добавьте следующие строки в нужное место. Это правило устанавливает глобальный базовый шрифт
    и размер шрифта для всей страницы (поскольку <code>&lt;html&gt;</code> является родительским элементом для всей
    страницы, и все элементы внутри него наследуют такой же <code>font-size</code> и <code>font-family</code>):</li>
    </ol>
    <pre><code class="lang-css"><span class="hljs-selector-tag">html</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">25px</span>; <span class="hljs-comment">/* px значит 'пиксели': базовый шрифт будет 10 пикселей в
    высоту */</span>
    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">"Open Sans"</span>, sans-serif;
    }
    </code></pre>
    <ol>
    <li>Примечание: Все в CSS документе между <code>/*</code> и <code>*/</code> является CSS комментарием, который браузер
    игнорирует при исполнении кода. Это место, где вы можете написать полезные заметки о том, что вы
    делаете.</li>
    </ol>
    <p>В <code>demo-2.html</code> содержится рабочий пример.</p>
    <h2 id="-">Блоки, блоки и ещё раз блоки</h2>
    <p>Одна вещь, которую вы заметите в написании CSS, заключается в том, что многое из этого касается блоков -
    настройка их размера, цвета, положения и т.д. Большинство HTML-элементов на странице
    можно рассматривать как блоки, расположенные друг над другом.</p>
    <p>Не удивительно, макет CSS основан, главным образом, на блочной модели (box model). Каждый из блоков,
    занимающий пространство на вашей странице имеет такие свойства, как:</p>
    <ul>
    <li>padding, пространство только вокруг контента (например, вокруг абзаца текста);</li>
    <li>border, сплошная линия, которая расположена рядом с padding;</li>
    <li>margin, пространство вокруг внешней стороны элемента.</li>
    </ul>
    <p>У CSS очень обширные возможности по их оформлению.
    Плюс что-то устаревает, что-то добавляется новое.
    Тут было затронуто лишь вводное знакомство с стилями.</p>
    <p>Дополнительно про CSS вы можете прочитать тут:</p>
    <p><a href="https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics">developer.mozilla.org</a>
    <a href="https://html5css.ru/css/default.php">html5css.ru</a>
    <a href="https://html5book.ru/css-css3/">html5book</a></p>

    <h1 id="-javascript">Основы JavaScript</h1>
    <h2 id="-js">Подключение JS</h2>
    <p>Чтобы добавлять js-программки (скрипты) на html-страницу, необходим тег <code>&lt;script&gt;</code>.</p>
    <pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Это обычный HTML документ<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">"JavaScript"</span>&gt;</span><span class="actionscript">
     alert (<span class="hljs-string">"Привет, мир!"</span>);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Выходим обратно в HTML<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
    </code></pre>
    <p>Браузер читает HTML-документ сверху вниз, и начинает отображать страницу, показывая часть документа до
    тега <code>&lt;script&gt;</code>. Встретив тег <code>&lt;script&gt;</code>, переключается в JavaScript-режим и выполняет сценарий. В нашем коде он
    встречает оператор <code>alert</code> и понимает, что нужно вывести на экран все то, что заключено в кавычки.</p>
    <p>Как только браузер закончил выполнение, он возвращается обратно в HTML-режим и отображает оставшуюся
    часть документа.
    Если JavaScript-кода много, его выносят в отдельный файл, который, как правило, имеет расширение <code>*.js</code>.</p>
    <p>Чтобы JavaScript-кoд включить в HTML-документ из внешнего файла, нужно использовать атрибут <code>src</code> (source)
    тега <code>&lt;script&gt;</code>. Его значением должен быть URL-aдpec файла, в котором содержится JS-код:</p>
    <pre><code class="lang-html">
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/scripts/script.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    </code></pre>
    <p>В этом примере указан путь к файлу с именем <code>script.js</code>, который содержит скрипт. Принцип указания пути
    аналогичен тому случаю, когда мы вставляли картинки в html-документ с помощью тега <code>&lt;img&gt;</code>. При этом файл
    <code>script.js</code> должен содержать только JavaScript-кoд, который в другом бы случае располагался бы между
    тегами <code>&lt;script&gt;</code> и <code>&lt;/script&gt;</code>.</p>
    <h2 id="-">Примитивные типы данных</h2>
    <p>Значение в JavaScript всегда относится к данным определённого типа. Например, это может быть строка или
    число. В JavaScript имеются следующие примитивные типы данных: <code>number</code>, <code>boolean</code>, <code>string</code>, <code>undefined</code>, <code>null</code>.</p>
    <p>Переменная в JavaScript может содержать любые данные. Там может быть строка вначале, а далее, например
    – число:</p>
    <pre><code class="lang-javascript">// Это не ошибка
    let message = <span class="hljs-string">"string"</span><span class="hljs-comment">;</span>
    <span class="hljs-attribute">message</span> = <span class="hljs-number">1234</span><span class="hljs-comment">;</span>
    </code></pre>
    <p>Языки программирования, в которых так можно, называются «динамически типизированными». Это значит,
    что типы данных есть, но переменные не привязаны ни к одному из них.</p>
    <h2 id="-">Числа</h2>
    <pre><code class="lang-javascript"><span class="hljs-attribute">let n</span> = 321;
    <span class="hljs-attribute">n</span> = 54.321;
    </code></pre>
    <p>В этой конструкции <code>let</code> – зарезервированное слово, которое аналогично математическому: «Пусть n = 123».
    Вместо <code>let</code> еще можно встретить <code>var</code>.</p>
    <p>Числовой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой
    (для представления дробей). С числами можно осуществлять арифметические операции, например,
    умножение <code>*</code>, деление <code>/</code>, сложение <code>+</code>, вычитание <code>-</code> и так далее.</p>
    <p>Кроме обычных чисел, в js существуют спецефические числовые значения: <code>Infinity</code> и <code>NaN</code>. Они относятся к
    типу «число». Конечно, это не числа в привычном значении этого слова.</p>
    <ul>
    <li><code>Infinity</code> представляет собой математическую бесконечность <code>∞</code>.</li>
    </ul>
    <p>Это особое значение, которое больше любого числа.</p>
    <p>Мы можем получить его в результате деления на ноль:</p>
    <pre><code class="lang-javascript">alert( <span class="hljs-number">5</span> / <span class="hljs-number">0</span> ); <span class="hljs-comment">// Infinity</span>
    </code></pre>
    <p>Или задать его явно:</p>
    <pre><code class="lang-javascript">alert<span class="hljs-comment">( Infinity )</span>; <span class="hljs-comment">// Infinity</span>
    </code></pre>
    <ul>
    <li><p><code>NaN</code> (Not a Number) означает вычислительную ошибку.</p>
    </li>
    <li><p>Это результат неправильной или неопределённой математической операции, например:</p>
    </li>
    </ul>
    <pre><code class="lang-javascript"><span class="hljs-selector-tag">alert</span>( <span class="hljs-string">"не число"</span> / <span class="hljs-number">4</span> ); <span class="hljs-comment">// NaN, такое деление является ошибкой</span>
    </code></pre>
    <p>Значение <code>NaN</code> «прилипчиво». Любая операция с <code>NaN</code> возвращает <code>NaN</code>:</p>
    <pre><code class="lang-javascript">alert( <span class="hljs-string">"не число"</span> / <span class="hljs-number">4</span> + <span class="hljs-number">5</span> ); <span class="hljs-comment">// NaN</span>
    </code></pre>
    <p>Если в математическом выражении присутствует переменная с типом <code>NaN</code>, то результатом вычислений также
    будет <code>NaN</code>. Это не сложно понять, например, делишь «не число» на число, результатом будет «не число».</p>
    <p>Помните, мы говорили о том, что JS не считался серьезным языком? Именно потому, что математические
    операции в JavaScript «безопасны». Можно делить на нуль, вычислять невычисляемые выражения и от этого
    ничего не перестанет работать.</p>
    <h2 id="-">Строки</h2>
    <p>Строка (string) в JavaScript заключается в кавычки.</p>
    <pre><code class="lang-javascript"><span class="hljs-attribute">let str</span> = <span class="hljs-string">"Это строка"</span>;
    </code></pre>
    <p>В JavaScript можно встретить три типа кавычек:</p>
    <ul>
    <li>Двойные кавычки: &quot;Это строковый тип данных&quot;.</li>
    <li>Одинарные кавычки: &#39;Это строковый тип данных&#39;.</li>
    <li>Обратные кавычки: `Это строковый тип данных`.</li>
    </ul>
    <p>Между двойными и одинарными кавычками для JS разницы не существует. Обратные же кавычки имеют
    расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в <code>${…}</code>.
    Например:</p>
    <pre><code class="lang-javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">"Student"</span>;
    <span class="hljs-comment">// Вставим переменную</span>
    alert( `Привет, ${name}!` ); <span class="hljs-comment">// Привет, Саша!</span>
    <span class="hljs-comment">// Вставим выражение</span>
    alert( `результат: ${<span class="hljs-number">2</span> + <span class="hljs-number">2</span>}` ); <span class="hljs-comment">// результат: 4</span>
    </code></pre>
    <p>Выражение внутри <code>${…}</code> вычисляется, и его результат становится частью строки. Мы можем положить туда всё,
    что угодно: переменную <code>name</code>, или выражение <code>2 + 2</code>, или что-то более сложное.
    Все данные, которые мы вводим с клавиатуры по умолчанию для JS принадлежат строковому типу.</p>
    <h2 id="-">Булевый (логический) тип</h2>
    <p>Булевый тип <code>boolean</code> принимает только два значения: истина <code>true</code> и ложь <code>false</code>.
    Такой тип, как правило, используется для хранения значений да/нет – <code>true/false</code>. Можно провести двоичную
    аналогию 1 и 0.
    Например:</p>
    <pre><code class="lang-javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-literal">true</span>; <span class="hljs-comment">// да, поле отмечено</span>
    <span class="hljs-keyword">let</span> age = <span class="hljs-literal">false</span>; <span class="hljs-comment">// нет, поле не отмечено</span>
    </code></pre>
    <p>Булевые значения также могут быть результатом сравнений:</p>
    <pre><code class="lang-javascript"><span class="hljs-built_in">let</span> <span class="hljs-built_in">compare</span> = <span class="hljs-number">5</span> &gt; <span class="hljs-number">2</span>;
    alert( <span class="hljs-built_in">compare</span> ); // <span class="hljs-literal">true</span> (результатом сравнения будет <span class="hljs-string">"да"</span>)
    </code></pre>
    <h2 id="-null-">Значение «null»</h2>
    <p>Специальное значение <code>null</code> не относится ни к одному из типов, описанных выше.
    Оно формирует отдельный тип, который содержит только значение <code>null</code>:</p>
    <pre><code class="lang-javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span> = <span class="hljs-literal">null</span>;
    </code></pre>
    <p>В JavaScript <code>null</code> – это просто специальное значение, которое представляет собой «ничего», «пусто» или
    «значение неизвестно».</p>
    <p>В приведённом выше коде указано, что значение переменной age неизвестно.</p>
    <h2 id="-undefined-">Значение «undefined»</h2>
    <p>Специальное значение <code>undefined</code> также стоит особняком. Оно формирует тип из самого себя так же, как и <code>null</code>.
    Оно означает, что «значение не было присвоено».
    Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет <code>undefined</code>:</p>
    <pre><code class="lang-javascript">let age<span class="hljs-comment">;</span>
    alert(age)<span class="hljs-comment">; // выведет "undefined"</span>
    </code></pre>
    <h2 id="-alert-prompt-confirm">Взаимодействие: alert, prompt, confirm</h2>
    <p>Познакомимся с несколькими функциями браузера для удобного ввода и вывода
    данных: <code>alert</code>, <code>prompt</code> и <code>confirm</code>.</p>
    <h3 id="alert">alert</h3>
    <p>С этой функцией мы уже знакомы. Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».
    Например:</p>
    <pre><code class="lang-javascript">alert(<span class="hljs-string">"Привет"</span>)<span class="hljs-comment">;</span>
    </code></pre>
    <p>Небольшое окно с сообщением, вылезающее поверх остальных называется модальным окном. Пользователь
    не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до
    тех пор, пока взаимодействует этим с окном. В нашем случае – пока не будет нажата кнопка «Закрыть».</p>
    <h3 id="prompt">prompt</h3>
    <pre><code class="lang-javascript"><span class="hljs-built_in">let</span> <span class="hljs-built_in">test</span> = prompt(<span class="hljs-string">"Test"</span>);
    </code></pre>
    <p>Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK (Проложить)/Отмена.</p>
    <p>Функция <code>prompt</code> принимает два аргумента.
    Синтаксис:</p>
    <pre><code class="lang-javascript"><span class="hljs-attribute">result</span> = prompt(title, [default]);
    </code></pre>
    <p><code>title</code> - текст для отображения в окне.
    <code>default</code> - необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.</p>
    <p>Пользователь напечатает что-либо в поле ввода и нажмет «Продолжить». В нашем примере введённый текст
    будет присвоен переменной <code>result</code>. Можно также отменить ввод нажатием на кнопку «Отмена» или нажав на
    клавишу <code>Esc</code>. В этом случае <code>result</code> присвоится значение <code>null</code>.</p>
    <p><code>Title</code> лучше ставить всегда, чтобы пользователь понимал, какой ввод данных от него ожидается.</p>
    <h3 id="confirm">confirm</h3>
    <p>Синтаксис:</p>
    <pre><code class="lang-javascript"><span class="hljs-attribute">result</span> = confirm(question)<span class="hljs-comment">;</span>
    </code></pre>
    <p>Функция <code>confirm</code> отображает модальное окно с текстом вопроса <code>question</code> и двумя кнопками: Да и Нет.
    Результат – <code>true</code>, если нажата кнопка Да. В других случаях – <code>false</code>.</p>
    <p>Например:</p>
    <pre><code class="lang-javascript"><span class="hljs-attribute">let isConfirm</span> = confirm(<span class="hljs-string">"Подтвердить действие?"</span>);
    </code></pre>
    <pre><code class="lang-javascript">alert( isConfirm ); <span class="hljs-regexp">//</span> <span class="hljs-keyword">true</span>, если нажата OK
    </code></pre>
    <p>Знание работы элементов взаимодействия с пользователем очень важно, для тестирования веб форм, работы с всплывающими
    подсказками и окнами.</p>
    <p>Так же важно то как происходит загрузка JS скриптов на страницах сайтов и работа сайтов полностью реализованных на
    JavaScript, но об этом мы поговорим позже.</p>
    <p>Javascript ещё более обширная тема, чем html &amp; css и затронуты совсем крохи знаний.
    Дополнительно вы можете прочитать тут:</p>
    <p><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Introduction">developer.mozilla.org</a>
    <a href="https://learn.javascript.ru/">learn.javascript.ru</a></p>

    <h1 id="-">Ссылки на дополнительные материалы</h1>
    <h2 id="html-css">HTML + CSS</h2>
    <ul>
    <li><p><a href="https://developer.mozilla.org/ru/docs/Web/HTML">Руководство по html</a></p>
    </li>
    <li><p><a href="https://validator.w3.org/#validate_by_input">HTML валидатор</a></p>
    </li>
    <li><p><a href="https://html5book.ru/html-tags/">Список html тегов</a></p>
    </li>
    <li><p><a href="https://html5book.ru/css-css3/">Руководство по CSS</a></p>
    </li>
    <li><p><a href="https://caniuse.com/">Проверка кроссбраузерности CSS свойств</a></p>
    </li>
    <li><p><a href="https://www.youtube.com/watch?v=GFqCX2AefQk&amp;list=PLMB6wLyKp7lV9YoWTMCztq-KXYhYPB09K">Курс HTML &amp; CSS в yotube</a></p>
    </li>
    <li><p><a href="https://stepik.org/course/52164/promo#toc">Курс на stepic</a></p>
    </li>
    </ul>
    <h2 id="javascript">JavaScript</h2>
    <ul>
    <li><a href="https://learn.javascript.ru/">Современный учебник JavaScript</a></li>
    </ul>
    
    <hr>

    <h1 id="-c-git">Сиcтема контроля версий. Git</h1>
    <h2 id="-">Что такое система контроля версий</h2>
    <p>Система контроля версий — это программное обеспечение, которое позволяет хранить историю изменений в любом документе или
    файле. Таким образом, вы можете легко просматривать и откатывать изменения, сделанные каким-либо участником проекта. Это
    очень полезно, когда необходимо восстановить старую версию документа или сравнить две разные версии файла. Кроме того,
    она позволяет отслеживать, кто и что изменил в документе или файле и помогает избежать конфликтов при одновременном
    редактировании одним и тем же файлом.</p>
    <p>Система контроля версий Git является распределенной, она используется для отслеживания изменений в файлах и директориях
    проекта. Позволяет разработчикам контролировать и отслеживать изменения в проекте.</p>
    <p>Чтобы работать с Git, необходимо инициализировать репозиторий в папке с проектом. После этого можно добавлять изменения
    в репозиторий, создавая различные версии проекта. Можно также просматривать историю изменений и откатываться к любой
    предыдущей версии. Также можно объединять работы различных разработчиков в один проект.</p>
    <h2 id="-">Инструменты</h2>
    <ul>
    <li><p>Скачать <a href="https://git-scm.com/downloads">git</a> можно с оффициального сайта разработчиков, выбрав свою ОС.</p>
    </li>
    <li><p>Для закомства с системой контроля версий рекоммендуется использовать среду
    разработки <a href="https://www.jetbrains.com/pycharm/download">PyCharm</a>.</p>
    </li>
    <li><p>Также нам понадобится аккаунт <a href="https://github.com/">GitHub</a> для размещения репозиториев.</p>
    </li>
    </ul>
    <h2 id="-">С чего начать изучение?</h2>
    <ul>
    <li><a href="https://learngitbranching.js.org/?locale=ru_RU">LearnGitBranching</a>: приложение, которое позволит вам в игровой форме
    изучить основные возможности и команды <code>git</code>.</li>
    <li>Создать репозиторий и начать практиковаться
    <a href="https://docs.github.com/ru/repositories/creating-and-managing-repositories/creating-a-new-repository">Создание репозитория</a>.</li>
    <li>Поскольку мы в дальнейшем будем делать упор на языке программирования Python, то при создании репозитория не забывайте
    указывать соответствующий файл <code>.gitignore</code>. Правилом хорошего тона является добавление к репозиторию сопроводительной
    документации <code>README.md</code>, написанного с использованием языка разметки Markdown, о которой мы поговорим позже.</li>
    </ul>

    <h1 id="-github">Создание репозитория в GitHub</h1>
    <h2 id="-">Подготовительные действия</h2>
    <ul>
    <li>Установить <a href="https://git-scm.com/downloads">git</a>.</li>
    <li>Установить <a href="https://www.jetbrains.com/pycharm/download">PyCharm</a>.</li>
    <li>Установить интерпретатор <a href="https://www.python.org/downloads/">Python</a> версии не ниже 3.10.6.</li>
    <li>Зарегистироваться в <a href="https://github.com/">GitHub</a>.</li>
    </ul>
    <h2 id="-">Создание репозитория</h2>
    <h3 id="-">Создание удалённого репозитория</h3>
    <ol>
    <li><p>Открыть страницу своего профиля GitHub.</p>
    </li>
    <li><p>Нажать на таб &quot;Repositories&quot;.</p>
    </li>
    <li><p>Нажать на кнопку &quot;New&quot;.</p>
    </li>
    <li><p>Заполнить обязательные поля. Не забываем добавить <code>README.md</code> и <code>.gitignore</code> (Python).</p>
    </li>
    <li><p>Нажать кнопку &quot;Create repository&quot;.</p>
    </li>
    </ol>
    <h3 id="-">Клонирование удалённого репозитория в локальный</h3>
    <ol>
    <li><p>Открыть PyCharm.</p>
    </li>
    <li><p>Нажать &quot;File&quot;, выбрать &quot;New Project...&quot;.</p>
    </li>
    <li><p>Заполнить форму создания проекта. Обязательно указать виртуальное окружение и интерпретатор Python.</p>
    </li>
    <li><p>Нажать &quot;Create&quot;.</p>
    </li>
    <li><p>Нажать &quot;Terminal&quot; в нижней панели PyCharm. Должно отображаться название созданного проекта в круглых скобках. Если
    отображается ошибка, иожно погуглить решение или переключиться на другой терминал. Если у вас не отображается ошибка
    можно пропустить следующие 2 шага.</p>
    </li>
    <li><p>Чтобы сменить терминал по умолчанию (powershell) на cmd нажать &quot;File&quot; -&gt; &quot;Settings&quot; -&gt; ввести в поле поиска &quot;
    terminal&quot; -&gt; выбрать настройки терминала -&gt; в выпадающем списке выбрать терминал cmd -&gt; OK.</p>
    </li>
    <li><p>Если у вас не отображается терминал как на изображении в шаге 5 закройте PyCharm и откройте его заново.</p>
    </li>
    <li><p>Зайти на страницу GitHub своего репозитория -&gt; Нажать на кнопку &quot;Code&quot; -&gt; Скопировать HTTPS адрес репозитория.</p>
    </li>
    <li><p>Открыть таб &quot;Terminal&quot; в нижней панеле PyCarm -&gt; Ввести команду:</p>
    </li>
    </ol>
    <pre><code class="lang-shell">git clone <span class="hljs-link">https://github.com/</span>[<span class="hljs-string">your-username</span>]/best-rep-of-the-world.git
    </code></pre>
    <ol>
    <li>Нажать Enter. Скопируются файлы с удалённого репозитория. Проект будет выглядеть следующим образом:</li>
    </ol>
    <p>Как видно, скопировался проект с удалённого репозитория внутрь локального. Склонировались .gitignore и README.md
    файлы, которые были внутри удалённого репозитория.</p>

    <h1 id="-git">Основные команды git</h1>
    <h2 id="-git-">Разберем самые важные команды git, которые используются постоянно:</h2>
    <ul>
    <li>коммиты;</li>
    <li>создание веток;</li>
    <li>переключения между ветками;</li>
    <li>пул реквесты;</li>
    <li>слияния веток;</li>
    <li>разрешение конфликтов.</li>
    </ul>
    <h3 id="-">Создание веток</h3>
    <p>Работать будем в PyCharm. Использовать консольные команды не будем, разработчики постарались сделать интуитивно понятный
    интерфейс для работы с системой контроля версий, которым грех не воспользоваться. Но знать консольные команды
    необходимо, это пригодится в работе с ОС без графического интерфейса.</p>
    <ul>
    <li><p>Отделим новую ветку от ветки main. Для этого переключимся на таб Git в нижней панели PyCharm -&gt; ПКМ на main.</p>
    </li>
    <li><p>В выпадающем меню выбираем пункт &quot;New Branch from &#39;main&#39;...&quot;.</p>
    </li>
    <li><p>Вводим имя нашей новой ветки и нажимаем кнопку &quot;Create&quot;.</p>
    </li>
    <li><p>Все изменения принято вносить в главную ветку через слияния второстепенных. К тому же этот механизм позволяет работать
    с репозиторием одновременно нескольким разработчикам. Убеждаемся, что мы действительно перешли на новую ветку: в
    правом нижнем углу PyCharm отображается текущая активная ветка, в панели Git, можно ввести консольную команду:</p>
    </li>
    </ul>
    <pre><code class="lang-shell"><span class="hljs-attribute">git branch</span>
    </code></pre>
    <h3 id="-python">Создадим нашу первую программу на языке Python</h3>
    <ul>
    <li><p>ПКМ по имени репозитория -&gt; New -&gt; Python File.</p>
    </li>
    <li><p>Я назвал свой новый файл <code>python_program</code>, вы можете назвать его как угодно. Но есть нюансы, с которыми будет лучше,
    если вы сами столкнетесь. Далее IDE спросит добавить ли файл в отслеживаемые. Соглашаемся.</p>
    </li>
    <li><p>Обратите внимание, что файл сейчас выделяется зелёным цветом.</p>
    </li>
    </ul>
    <p>Это значит, что это новый контент, которые ещё не зафиксирован.</p>
    <ul>
    <li>Давайте зафиксируем новое изменение нашего репозитория в новой ветке. Говорят &quot;закоммитимся&quot;.</li>
    <li><p>Перейдем во вкладку &quot;Commit&quot; в левом сайдбаре IDE -&gt; Отметим изменение, которое мы хотим зафиксировать в чекбоксе -&gt;
    нашишем адекватное сообщение о коммите (принято писать осмысленные сообщения на английском языке) -&gt; Нажать кнопку &quot;
    Commit&quot;.</p>
    </li>
    <li><p>Обратите внимание, что файл перестал выделяться зелёным цветом. Это заначит, что изменения сохранены.</p>
    </li>
    <li><p>Напишем классическую программу о приветствии мира внутри файла <code>python_program.py</code>.</p>
    </li>
    </ul>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">'Hello World!'</span>)
    
    
    hello_world()
    </code></pre>
    <ul>
    <li><p>Сразу заострим внимание на нескольких вещах:</p>
    <ul>
    <li><p>Пропущенные строчки. Позже вы познакомитесь с особенностями языка Python и правилами написания кода. Пока
    используйте автоформатирование, которое предлагает IDE PyCharm. Можете посмотреть в настройках комбинацию клавиш
    для своей машины.</p>
    </li>
    <li><p>Если у вас установлен интерпретатор Python, то подсвечивается синтаксис языка.</p>
    </li>
    <li>Скрипт можно запустить используя сочетание клавиш или нажав на зеленый треугольник на любой из панелей открытого
    файла.</li>
    </ul>
    </li>
    <li><p>Закоммитим изменения.</p>
    </li>
    <li><p>Отправим изменения на удалённый репозиторий.</p>
    </li>
    <li><p>В нижней панели клик на таб Git -&gt; ПКМ на текущей ветке <code>first_pytho_program</code> -&gt; Push... -&gt; Push.</p>
    </li>
    <li><p>В этот момент git может попросить вас представиться ему (от чьего имени будут отправленны данные, вводите актуальную
    почту и своё настоящее имя на английском языке. Так другие разработчики смогут идентифицировать, кому принадлежит
    код, - это очень важно.), PyCharm может попросить у вас авторизоваться в GitHub.</p>
    </li>
    <li><p>Можно убедиться, что изменения были отправлены в удаленный репозиторий.</p>
    <ul>
    <li><p>Отроем наш репозиторий.</p>
    </li>
    <li><p>Выберем другую ветку, кликнув на &quot;2 branches&quot; или на выпадающий список main.</p>
    </li>
    <li><p>Выберите ветку, в которой вы писали код. У меня это <code>firs_python_program</code>.</p>
    </li>
    <li><p>Посмотрите код в файле <code>puthon_program.py</code> кликнув по названию.</p>
    </li>
    </ul>
    </li>
    </ul>
    <h3 id="-">Пул-реквест, разрешение конфликтов</h3>
    <ul>
    <li>Переключимся на ветку main. В нижней панели клик на таб Git -&gt; ПКМ main -&gt; Checkout.</li>
    <li>Как видите, никаких изменений в этой ветке нет.</li>
    <li>Давайте создадим точно такой же файл и другую программу внутри него.</li>
    </ul>
    <pre><code class="lang-python"><span class="hljs-keyword">def</span> sum_two_numbers(<span class="hljs-string">f_number:</span> <span class="hljs-keyword">int</span>, <span class="hljs-string">sec_number:</span> <span class="hljs-keyword">int</span>) -&gt; <span class="hljs-string">int:</span>
        <span class="hljs-keyword">return</span> f_number + sec_number
    
    
    print(sum_two_numbers(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))
    </code></pre>
    <p>Эта программа выводит в консоль сумму двух чисел.</p>
    <ul>
    <li><p>Закоммитим изменения и запушим их в удалённый репозиторий.</p>
    </li>
    <li><p>К этому моменту у нас есть 2 ветки в удалённом репозитории, с одинаковым файлом внутри и разным его содержанием.</p>
    </li>
    <li><p>Попробуем сделать пулл-реквест.</p>
    <ul>
    <li><p>Открыть репозиторий.</p>
    </li>
    <li><p>Нажать кнопку &quot;Compare &amp; pull request&quot;.</p>
    </li>
    <li><p>Нажать &quot;Create pull request&quot;.</p>
    </li>
    <li><p>Возникли конфликты при слиянии веток. Сейчас мы их разрешим в GitHub. Этим можно заняться и в IDE, где вам больше
    нравится. Обязательно попробуйте это сделать самостоятельно в разных средах.</p>
    </li>
    <li><p>Нажать &quot;Resolve conflicts&quot;.</p>
    </li>
    <li><p>Смысл тут такой: GitHub отображает нам участок кода, где возник конфликт и предлагает решить, какой код мы
    оставим. Остальное нужно удалить. Решение будет примерно таким:</p>
    </li>
    <li><p>Станет доступна кнопка пометки конфликта как разрешенного, она появится в правой верхней части окна. Я для
    удобства поместил ее рядом.</p>
    </li>
    <li><p>Не будем сохранять изменения и попробуем теперь разрешить конфликт в IDE PyCharm.</p>
    <ul>
    <li><p>Убеждаемся, что мы находимся на ветке main или переключаемся на неё.</p>
    </li>
    <li><p>В нижней панели нажимаем на таб &quot;Git&quot; -&gt; ПКМ на второй ветке -&gt; Merge &#39;[имя_ветки]&#39; into &#39;main&#39;.</p>
    </li>
    <li><p>Появится окно разрешения конфликтов.</p>
    </li>
    <li><p>Клик &quot;Merge...&quot;.</p>
    </li>
    <li><p>Откроется окно сравнения кода из разных веток: слева - main, справа - first_python_program и результат слияния
    ветов по центру. Принимаем изменения нажимая &gt;&gt;, отменяем изменения нажимая X.</p>
    </li>
    <li><p>Когда конфликты будут разрешены PyCharm подскажет об этом всплывающим уведомлением.</p>
    </li>
    <li><p>Нажать Apply, чтобы изменения вступили в силу.</p>
    </li>
    <li><p>Закоммитим слияние и запушим изменения в main.</p>
    </li>
    <li><p>Теперь, когда мы посмотрим на графическое представление изменений версий нашего репозитория, мы убедимся, что
    пуш прошел успешно и удалённый репозиторий принял изменения.</p>
    </li>
    <li><p>Зайдем на GitHub - увидим, что наш пул-реквест успешно закрыт. Ветки объединены в одной main.</p>
    </li>
    </ul>
    </li>
    </ul>
    </li>
    </ul>
    <p>Мы познакомились с наиболее часто используемыми командами git.</p>

    <h1 id="-readme-md-markdown">Файл README.md и разметка Markdown</h1>
    <p><code>README.md</code> — это файл в репозитории GitHub, который служит файлом документации для репозитория. Он написан в формате
    Markdown и предоставляет информацию о назначении репозитория, инструкции по установке, примеры использования и любую
    другую соответствующую информацию.</p>
    <p>Файл <code>README.md</code> важен, потому что он помогает пользователям понять назначение и использование репозитория. Он также
    предоставляет важную информацию, которая может помочь пользователям быстро и легко начать работу с репозиторием. Кроме
    того, наличие хорошо написанного файла <code>README.md</code> может помочь привлечь участников в репозиторий и улучшить совместную
    работу.</p>
    <p>Мы создали такой файл сразу же при создании репозитория.</p>
    <h2 id="-readme-md">Написание содержания для вашего файла README.md</h2>
    <p>Содержимое вашего файла <code>README.md</code> должно включать следующую информацию:</p>
    <ul>
    <li>Название: название вашего проекта или репозитория.</li>
    <li>Описание: краткое описание того, что делает ваш проект или репозиторий.</li>
    <li>Оглавление: список разделов в вашем файле <code>README.md</code>.</li>
    <li>Установка: Инструкции по установке и настройке вашего проекта или репозитория.</li>
    <li>Использование: Инструкции по использованию вашего проекта или репозитория.</li>
    <li>Участие: рекомендации о том, как внести свой вклад в ваш проект или репозиторий. (Опцинально)</li>
    <li>Лицензия: информация о лицензии вашего проекта или репозитория.</li>
    </ul>
    <p>Вы можете использовать синтаксис Markdown для форматирования контента и добавления заголовков, списков, изображений,
    ссылок и других элементов.</p>
    <p>Я перевел на русский язык удобную и информативную инструкцию по применению
    разметки <a href="https://github.com/Lexxx42/Markdown-Cheatsheet">Markdown</a> специально для тех, кому комфортнее читать
    актуальную документацию на родном языке. Обязательно советую ознакомиться с ней или другими источниками.</p>
    <h2 id="-readme-md">Предварительный просмотр и редактирование файла README.md</h2>
    <p>Вы можете предварительно просмотреть файл <code>README.md</code>, нажав кнопку «Предварительный просмотр» в редакторе GitHub. Это
    покажет, как будет выглядеть файл при отображении в Markdown. Вы также можете отредактировать файл, нажав кнопку
    «Редактировать». PyCharm поддерживает редактирование и отображение файлов с разметкой Markdown.</p>
    <h2 id="-readme-md">Внесение изменений в файл README.md</h2>
    <p>После внесения изменений в файл <code>README.md</code> вам необходимо зафиксировать изменения в своем репозитории. Для этого
    нажмите на кнопку «Зафиксировать изменения».</p>
    <h2 id="-readme-md">Использование файла README.md</h2>
    <p>Теперь ваш файл <code>README.md</code> будет отображаться на главной странице вашего репозитория. Он предоставит важную информацию
    о вашем проекте или репозитории пользователям, которые посещают ваш репозиторий. Вы также можете включить ссылку на
    файл <code>README.md</code> в документацию вашего проекта или на веб-сайт.</p>
    <h2 id="-readme-md-github-">Ознакомся с оформлением личного <code>README.md</code> файла для профиля GitHub.</h2>
    <p>Для примера, можете посмотреть на мой профиль <a href="https://github.com/Lexxx42">Lexxx42</a>
    Можно взять код его оформления за основу и изменить по своему вкусу или ознакомиться со статьёй по
    оформлению <a href="https://habr.com/ru/post/649363/">Оформляем README-файл профиля на GitHub</a></p>
    <p>Кроме того, вы можете разместить свой <code>README.md</code> в качестве страницы, используя
    <a href="https://docs.github.com/ru/pages/getting-started-with-github-pages/creating-a-github-pages-site">Создание сайта GitHub Pages</a>.
    Для этого придется перевести язык разметки Markdown в язык разметки HTML.</p>
    <p>Рекомендую для этих целей использовать уже готовые решения:</p>
    <ul>
    <li><a href="https://markdowntohtml.com/">Convert Markdown to HTML</a></li>
    <li><a href="https://codebeautify.org/markdown-to-html">Markdown to HTML</a></li>
    </ul>
    <p>Я надеюсь, что это поможет вам приступить к созданию и использованию файла <code>README.md</code> в своих репозиториях GitHub.</p>

    <h1 id="-">Ссылки на дополнительные материалы</h1>
    <h2 id="git">Git</h2>
    <ul>
    <li><a href="https://gb.ru/posts/soveti-pro-git">Советы для тех, кто осваивает Git</a></li>
    <li><a href="https://learngitbranching.js.org/?locale=ru_RU">LearnGitBranching</a></li>
    <li><a href="https://habr.com/ru/company/yandex_praktikum/blog/700708/">Работаем с Git: первые шаги в GitHub</a></li>
    </ul>
    <h2 id="markdown">Markdown</h2>
    <ul>
    <li><a href="https://daringfireball.net/projects/markdown/">Markdown original spec</a></li>
    <li><a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">Markdown-Cheatsheet by Adam Pritchard</a></li>
    <li><a href="https://github.com/Lexxx42/Markdown-Cheatsheet">Lexxx42 перевод Markdown-Cheatsheet</a></li>
    <li><a href="https://docs.github.com/ru/get-started/writing-on-github">Создание документов на GitHub</a></li>
    <li><a href="https://docs.github.com/ru/pages/getting-started-with-github-pages/creating-a-github-pages-site">Создание сайта GitHub Pages</a></li>
    <li><a href="https://markdowntohtml.com/">Convert Markdown to HTML</a></li>
    <li><a href="https://codebeautify.org/markdown-to-html">Markdown to HTML</a></li>
    </ul>

    <hr>

    <h1 id="-python">Знакомство с ЯП Python</h1>
    <h2 id="-python">Основные понятия программирования и их применение в Python</h2>
    <p>Программирование - это, по сути, процесс предоставления компьютеру инструкций для выполнения конкретной задачи. Для
    этого нам нужно использовать язык программирования, который, по сути, представляет собой способ общения с компьютером
    таким образом, чтобы он мог его понять.</p>
    <p>Python - популярный язык программирования, известный своей простотой в изучении и использовании. Некоторые из основных
    концепций программирования, применимых к Python, включают:</p>
    <ol>
    <li>Синтаксис. Синтаксис языка программирования относится к правилам и соглашениям по написанию кода на этом языке. В
    Python, например, мы используем отступы для обозначения блоков кода, и мы используем определенные ключевые слова,
    такие как <code>if</code>, <code>else</code> и <code>while</code>, чтобы управлять потоком программы.</li>
    <li>Типы и структуры данных. В Python мы можем работать с различными типами данных, включая числа, строки и списки. Мы
    также можем использовать структуры данных, такие как словари и множества, для организации данных и управления ими.</li>
    <li>Структуры управления и ветвления. Структуры управления используются для управления потоком программы. В Python мы
    можем использовать операторы <code>if</code> для выполнения определенного кода, только если выполняется определенное условие,
    циклы <code>while</code> для повторения блока кода, пока определенное условие выполняется, и циклы <code>for</code> для повторения
    последовательности элементов.</li>
    <li>Функции. Функции — это повторно используемые блоки кода, которые выполняют определенную задачу. В Python мы можем
    определить наши собственные функции с помощью ключевого слова <code>def</code>, а также можем использовать встроенные функции,
    такие как <code>print</code> и <code>len</code>.</li>
    <li>Объектно-ориентированное программирование. Объектно-ориентированное программирование — это парадигма
    программирования, в которой особое внимание уделяется использованию объектов для представления данных и поведения. В
    Python мы можем определять наши собственные классы и объекты, которые позволяют нам организовывать наш код и
    создавать более сложные программы.</li>
    </ol>
    <p>Это всего лишь несколько основных концепций программирования, применимых к Python. Продолжая учиться, вы откроете для
    себя гораздо больше!</p>
    <h2 id="-">Следующий важны шаг в обучении - это практика!</h2>
    <p>Несколько идей для первого проекта Python!</p>
    <p>Вот несколько предложений:</p>
    <ul>
    <li><strong>Калькулятор.</strong> Создайте простую программу-калькулятор, которая может выполнять основные арифметические операции,
    такие как сложение, вычитание, умножение и деление.</li>
    <li><strong>Игра в угадайку.</strong> Создайте программу, которая генерирует случайное число от 1 до 100 и просит пользователя угадать,
    что это за число. Программа должна давать подсказки типа «больше» или «меньше», пока пользователь не угадает
    правильно.</li>
    <li><strong>Список дел.</strong> Создайте программу, которая позволяет пользователю создавать список дел. Программа должна позволять
    пользователю добавлять, редактировать и удалять задачи, а также отмечать задачи как завершенные.</li>
    <li><strong>Приложение Погода.</strong> Используйте API для создания программы, которая извлекает и отображает текущие погодные условия
    для заданного местоположения. Например <a href="https://openweathermap.org/api">OpenWeather</a></li>
    </ul>
    <p>Попробуйте обсудить структуру приложения и идеи по реализации с коллегами, друзьями или другими студентами. Попробуйте
    скооперироваться и получить опыт совместной разработки, разделив работу приложения на части. Например: ввод данных,
    обработка данных, вывод данных в файл, вывод данных в консоль, красиво форматированный вывод и т.д.</p>
    <p>Это всего лишь несколько идей для начала. Выберите тот, который вас больше всего интересует, и получите удовольствие от
    его программирования! Помните, что лучший способ научиться программированию — это практиковаться и экспериментировать.</p>
    <p>Не забудьте создать для него отдельный репозиторий в GitHub и оформить README.md 🙂</p>
    <p>P.S.: поиск и изучение информации - это обычное свойство IT профессии. Приготовся, что тебе предстоит много искать
    различной информации и изучать что-то новое постоянно.</p>

    <h1 id="-python">Основы языка Python</h1>
    <h2 id="-">Содержание</h2>
    <p><a href="#типы_данных">Типы_данных</a>
    <a href="#переменные">Переменные</a>
    <a href="#условные_конструкции">Условные_конструкции</a>
    <a href="#циклы">Циклы</a>
    <a href="#функции">Функции</a></p>
    <p><a name="типы_данных"/></p>
    <h3 id="-_-">Типы_данных</h3>
    <p>Типы данных в Python относятся к типам значений, которые можно хранить и которыми можно манипулировать в наших
    программах. Python поддерживает множество встроенных типов данных, в том числе:</p>
    <ul>
    <li>Целые числа: целые числа, такие как <code>1</code>, <code>2</code>, <code>3</code> и т.д.</li>
    <li>Числа с плавающей точкой: десятичные числа, такие как <code>3.14</code>, <code>2.5</code> и т. д.</li>
    <li>Лигический тип данных: True или False.</li>
    <li>Строки: текстовые значения, заключенные в кавычки, например <code>&quot;Привет, мир!&quot;</code>.</li>
    <li>Списки: упорядоченные наборы значений, заключенные в квадратные скобки, например <code>[1, 2, 3]</code>.</li>
    <li>Кортежи: упорядоченные наборы значений, заключенные в круглые скобки, например <code>(1, 2, 3)</code>.</li>
    <li>Словари: наборы пар ключ-значение, заключенные в фигурные скобки, например <code>{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}</code>.</li>
    </ul>
    <p>Чтобы использовать эти типы данных в наших программах, нам просто нужно присвоить значения переменным, например:</p>
    <pre><code class="lang-python"><span class="hljs-attr">x</span> = <span class="hljs-number">5</span>  # целое число
    <span class="hljs-attr">y</span> = <span class="hljs-number">3.14</span>  # число с плавающей точкой
    <span class="hljs-attr">z</span> = <span class="hljs-literal">True</span>  # булев тип
    <span class="hljs-attr">name</span> = <span class="hljs-string">"John"</span>  # строка
    <span class="hljs-attr">numbers</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]  # список
    <span class="hljs-attr">person</span> = {<span class="hljs-string">"name"</span>: <span class="hljs-string">"John"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">30</span>}  # словарь
    </code></pre>
    <p>После того, как мы присвоили значения переменным, мы можем выполнять с ними различные операции в зависимости от их типа
    данных. Например, мы можем использовать арифметические операторы, такие как <code>+</code>, <code>-</code>, <code>*</code> и <code>/</code> для выполнения
    вычислений с целыми числами или числами с плавающей точкой, или мы можем использовать строковые методы, такие
    как <code>upper()</code> или <code>lower()</code>для управления строками.</p>
    <p>Понимание типов данных является важной частью программирования на Python, поскольку оно позволяет нам создавать более
    сложные программы, которые могут обрабатывать широкий спектр входных и выходных данных. Освоив использование типов
    данных, мы сможем создавать более мощные, гибкие и эффективные программы, способные решать самые разные задачи.</p>
    <p><a name="переменные"/></p>
    <h3 id="-">Переменные</h3>
    <p>Переменные - важная часть программирования на Python, поскольку они позволяют нам хранить данные и управлять ими в
    наших программах. В Python переменная - это просто имя, которое ссылается на значение.</p>
    <p>Чтобы создать переменную в Python, мы используем следующий синтаксис:</p>
    <pre><code class="lang-python"><span class="hljs-keyword">variable</span><span class="hljs-number">_n</span>ame = <span class="hljs-keyword">value</span>
    </code></pre>
    <p>Здесь <code>variable_name</code> — это имя, которое мы даем переменной, а <code>value</code> — это значение, которое мы хотим сохранить в
    переменной.</p>
    <p>Например, мы можем создать переменную с именем <code>x</code>, которая содержит значение <code>5</code> следующим образом:</p>
    <pre><code class="lang-python"><span class="hljs-attr">x</span> = <span class="hljs-number">5</span>
    </code></pre>
    <p>Затем мы можем использовать переменную <code>x</code> в нашей программе для выполнения различных операций. Например, мы можем
    добавить <code>x</code> к другой переменной следующим образом:</p>
    <pre><code class="lang-python"><span class="hljs-attr">y</span> = <span class="hljs-number">10</span>
    <span class="hljs-attr">z</span> = x + y
    </code></pre>
    <p>В этом примере мы создаем новую переменную <code>y</code>, которая содержит значение <code>10</code>, а затем создаем новую переменную <code>z</code>,
    которая содержит результат сложения <code>x</code> и <code>y</code>.</p>
    <p>Переменные также можно использовать для хранения более сложных структур данных, таких как списки или словари. Например,
    мы могли бы создать список чисел следующим образом:</p>
    <pre><code class="lang-python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    </code></pre>
    <p>Затем мы можем получить доступ к отдельным элементам списка с помощью индексации, например:</p>
    <pre><code class="lang-python"><span class="hljs-built_in">print</span>(my_list[<span class="hljs-number">0</span>])  <span class="hljs-meta"># prints 1</span>
    </code></pre>
    <p>В целом переменные являются важным инструментом для хранения данных и управления ими в программах Python. Эффективно
    используя переменные, мы можем создавать более сложные и мощные программы, способные решать самые разные задачи.</p>
    <p><a name="условные_конструкции"/></p>
    <h3 id="-_-">Условные_конструкции</h3>
    <p>Условные конструкции или операторы <code>if</code> используются в Python для выполнения различных блоков кода в зависимости от
    того, является ли определенное условие истинным или ложным.</p>
    <p>Основной синтаксис оператора <code>if</code> следующий:</p>
    <pre><code><span class="hljs-keyword">if</span> [условие]:
        <span class="hljs-comment"># код для выполнения, если условие истинно</span>
    </code></pre><p>Здесь <code>условие</code> - это условие, которое мы хотим проверить. Если условие истинно, то код внутри оператора <code>if</code> будет
    выполнен.</p>
    <p>Мы также можем использовать оператор <code>else</code> для выполнения другого блока кода, если условие ложно. Основной синтаксис
    оператора <code>if-else</code> следующий:</p>
    <pre><code><span class="hljs-keyword">if</span> [условие]:
        <span class="hljs-comment"># код для выполнения, если условие истинно</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># код для выполнения, если условие ложно</span>
    </code></pre><p>Например, мы можем использовать оператор if, чтобы проверить, является ли число четным или нечетным:</p>
    <pre><code class="lang-python"><span class="hljs-built_in">num</span> = <span class="hljs-number">5</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">num</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"четное"</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"нечетное"</span>)
    </code></pre>
    <p>В этом примере мы используем оператор <code>%</code>, чтобы проверить, делится ли <code>num</code> на 2 без остатка. Если это так, то мы
    печатаем &quot;четное&quot;. В противном случае мы печатаем &quot;нечетное&quot;.</p>
    <p>Мы также можем использовать операторы <code>elif</code> для проверки нескольких условий. Основной синтаксис
    оператора <code>if-elif-else</code> следующий:</p>
    <pre><code><span class="hljs-keyword">if</span> [условие1]:
        <span class="hljs-comment"># код для выполнения, если условие истинно</span>
    <span class="hljs-keyword">elif</span> [условие2]:
        <span class="hljs-comment"># код для выполнения, если условие истинно</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># код для выполнения, если условие1 и условие2 ложны</span>
    </code></pre><p>Например, мы можем использовать оператор <code>if-elif</code> для присвоения буквенной оценки на основе оценки учащегося:</p>
    <pre><code class="lang-python"><span class="hljs-attr">score</span> = <span class="hljs-number">85</span>
    <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span>:
        <span class="hljs-attr">grade</span> = <span class="hljs-string">"A"</span>
    elif score &gt;= <span class="hljs-number">80</span>:
        <span class="hljs-attr">grade</span> = <span class="hljs-string">"B"</span>
    elif score &gt;= <span class="hljs-number">70</span>:
        <span class="hljs-attr">grade</span> = <span class="hljs-string">"C"</span>
    elif score &gt;= <span class="hljs-number">60</span>:
        <span class="hljs-attr">grade</span> = <span class="hljs-string">"D"</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-attr">grade</span> = <span class="hljs-string">"F"</span>
    print(grade)
    </code></pre>
    <p>В этом примере мы используем несколько операторов <code>elif</code> для проверки оценки по разным диапазонам и соответственно
    присваиваем буквенную оценку.</p>
    <p>В целом, условные конструкции являются важным инструментом для создания гибких динамических программ, которые могут
    адаптироваться к различным входным данным и ситуациям.</p>
    <p><a name="циклы"/></p>
    <h3 id="-">Циклы</h3>
    <p>В Python существует два основных типа циклов или циклов: циклы <code>for</code> и циклы <code>while</code>. Циклы используются для
    многократного выполнения блока кода, пока не будет выполнено определенное условие.</p>
    <p>Цикл <code>for</code> используется для перебора последовательности значений, такой как список или строка. Основной синтаксис цикла
    for выглядит следующим образом:</p>
    <pre><code><span class="hljs-keyword">for</span> [переменная] <span class="hljs-keyword">in</span> [последовательность]:
        <span class="hljs-comment"># код для выполнения многократно</span>
    </code></pre><p>Здесь <code>переменная</code> - это новая переменная, которая создается для каждой итерации цикла, а <code>последовательность</code> - это
    последовательность значений, которые мы хотим перебрать. Например, мы можем использовать цикл for для вывода каждого
    элемента списка:</p>
    <pre><code class="lang-python">my_list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> my_list:
        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>)
    </code></pre>
    <p>Это распечатает числа от 1 до 5, по одному.</p>
    <p>Цикл <code>while</code> используется для повторения блока кода до тех пор, пока выполняется определенное условие. Основной
    синтаксис цикла <code>while</code> следующий:</p>
    <pre><code><span class="hljs-keyword">while</span> [условие]:
        <span class="hljs-comment"># код для выполнения многократно</span>
    </code></pre><p>Здесь <code>условие</code> - это условие, которое мы хотим проверять перед каждой итерацией цикла. Например, мы можем использовать
    цикл while для печати чисел от 1 до 10:</p>
    <pre><code class="lang-python"><span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">count</span> &lt;= <span class="hljs-number">10</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">count</span>)
        <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
    </code></pre>
    <p>Это будет печатать числа от 1 до 10, по одному.</p>
    <p>В целом, циклы — важный инструмент для решения самых разных задач программирования. Эффективно используя циклы, мы можем
    автоматизировать повторяющиеся задачи и с легкостью выполнять сложные вычисления.</p>
    <p><a name="функции"/></p>
    <h3 id="-">Функции</h3>
    <p>Функции — неотъемлемая часть программирования на Python, поскольку они позволяют нам группировать набор инструкций,
    которые можно вызывать несколько раз в нашей программе. Функции используются для разбиения сложных проблем на более
    мелкие, более управляемые части, а также для того, чтобы сделать наш код более модульным и пригодным для повторного
    использования.</p>
    <p>В Python мы можем определить наши собственные функции, используя ключевое слово <code>def</code>, за которым следует имя функции и
    набор круглых скобок, которые могут включать один или несколько аргументов. Основной синтаксис для определения функции
    следующий:</p>
    <pre><code><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_function</span><span class="hljs-params">([аргумент<span class="hljs-number">1</span>], [аргумент<span class="hljs-number">2</span>], ...)</span></span>:
        <span class="hljs-comment"># код для выполнения</span>
        <span class="hljs-keyword">return</span> [результат]
    </code></pre><p>Здесь <code>моя_функция</code> - это имя функции, <code>аргумент1</code>, <code>аргумент2</code> и т. д. - это аргументы, которые принимает функция, а
    <code>результат</code> - это значение, которое функция возвращает.</p>
    <p>Например, мы могли бы определить функцию для вычисления площади прямоугольника следующим образом:</p>
    <pre><code class="lang-python">def rectangle_area(<span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>):
        area = <span class="hljs-built_in">width</span> * <span class="hljs-built_in">height</span>
        <span class="hljs-built_in">return</span> area
    </code></pre>
    <p>Затем мы можем вызвать эту функцию из нашей основной программы, передав необходимые аргументы, например:</p>
    <pre><code class="lang-python">area = rectangle_area(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
    print(<span class="hljs-name">area</span>)  # prints <span class="hljs-number">20</span>
    </code></pre>
    <p>Функции также можно использовать для выполнения сложных вычислений, обработки данных или реализации определенных
    алгоритмов. Разбивая наш код на более мелкие, более управляемые функции, мы можем создавать более модульный и удобный
    для сопровождения код, который легче понимать и отлаживать.</p>
    <p>В целом, функции являются важным инструментом программирования на Python и могут использоваться в самых разных
    приложениях. Освоив использование функций, ты сможешь поднять свои навыки программирования на новый уровень и создавать
    более мощные, эффективные и гибкие программы.</p>

    <h1 id="-">Базовые принципы ООП</h1>
    <p>Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов,
    которые могут содержать данные (атрибуты) и функции (методы), работающие с этими данными. ООП — это мощная парадигма
    программирования, которую можно использовать для создания более модульного, повторно используемого и поддерживаемого
    кода.</p>
    <p>Существует четыре основных принципа ООП:</p>
    <ol>
    <li><p>Инкапсуляция. Относится к практике сокрытия внутренних деталей объекта от внешнего мира и раскрытия только
    общедоступного интерфейса, который можно использовать для взаимодействия с объектом. Это помогает защитить
    целостность объекта и упрощает поддержку и изменение кода с течением времени.</p>
    </li>
    <li><p>Абстракция. Относится к практике представления сложных систем или понятий с использованием более простых и общих
    понятий. Абстракция позволяет нам сосредоточиться на основных характеристиках объекта и игнорировать детали, которые
    не имеют отношения к нашей текущей задаче.</p>
    </li>
    <li><p>Наследование. Относится к практике создания новых классов, которые наследуют атрибуты и методы существующих
    классов. Наследование позволяет нам повторно использовать код и создавать более специализированные классы, основанные
    на функциональности более общих классов.</p>
    </li>
    <li><p>Полиморфизм. Относится к практике использования одного интерфейса для представления нескольких типов объектов.
    Полиморфизм позволяет нам писать более общий код, который может работать с широким спектром объектов, без
    необходимости знать конкретные детали каждого объекта.</p>
    </li>
    </ol>
    <p>В Python мы можем использовать принципы ООП для создания классов и объектов, которые инкапсулируют данные и
    функциональность. Мы можем определить классы, используя ключевое слово <code>class</code>, а затем создать экземпляры этих классов,
    используя имя класса, за которым следуют круглые скобки. Например:</p>
    <pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name, age)</span></span>:
            <span class="hljs-keyword">self</span>.name = name
            <span class="hljs-keyword">self</span>.age = age
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hello</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            print(f<span class="hljs-string">'Hello, my name is {self.name} and I am {self.age} years old.'</span>)
    
    
    person1 = Person(<span class="hljs-string">'John'</span>, <span class="hljs-number">30</span>)
    person2 = Person(<span class="hljs-string">'Jane'</span>, <span class="hljs-number">25</span>)
    
    person1.say_hello()  <span class="hljs-comment"># выводит в консоль "Hello, my name is John and I am 30 years old."</span>
    person2.say_hello()  <span class="hljs-comment"># выводит в консоль "Hello, my name is Jane and I am 25 years old."</span>
    </code></pre>
    <p>В этом примере мы определяем класс <code>Person</code>, который имеет два атрибута (<code>name</code> и <code>age</code>) и один метод (<code>say_hello</code>).
    Затем мы создаем два экземпляра класса <code>Person</code> (<code>person1</code> и <code>person2</code>) и вызываем метод <code>say_hello</code> для каждого
    экземпляра.</p>
    <p>В целом, принципы ООП являются важным инструментом для создания более модульного, повторно используемого и
    поддерживаемого кода в Python. Освоив использование ООП, ты сможешь поднять свои навыки программирования на новый
    уровень и создавать более мощные, гибкие и эффективные программы.</p>

    <h1 id="-">Ссылки на дополнительные материалы</h1>
    <h2 id="-stepik">Курсы STEPIK</h2>
    <ul>
    <li><a href="https://stepik.org/course/63085">Инди-курс программирования на Python</a></li>
    <li><a href="https://stepik.org/course/67">Программирование на Python</a></li>
    <li><a href="https://stepik.org/course/512">Python: основы и применение</a></li>
    </ul>
    <h2 id="-">Документация</h2>
    <ul>
    <li><a href="https://peps.python.org/pep-0008/">PEP 8 – Style Guide for Python Code</a></li>
    <li><a href="https://peps.python.org/pep-0257/">PEP 257 – Docstring Conventions</a></li>
    <li><a href="https://peps.python.org/pep-0020/">PEP 20 – The Zen of Python</a></li>
    </ul>
    <h2 id="-">Полезные статьи</h2>
    <ul>
    <li><a href="https://realpython.com/python-application-layouts/">Python Application Layouts: A Reference</a></li>
    <li><a href="https://semakin.dev/2020/06/type_hints/">Аннотации типов в Python</a></li>
    <li><a href="https://www.codecamp.ru/blog/python-manipulating-xml/">Работа с XML из Python</a></li>
    <li><a href="https://code.tutsplus.com/ru/tutorials/how-to-read-and-write-csv-files-in-python--cms-29907">Как читать и писать CSV-файлы в Python</a></li>
    <li><a href="https://pythonworld.ru/moduli/modul-json.html">Модуль json</a></li>
    </ul>

    <hr>

    <h2 id="-selenium-">Что такое Selenium?</h2>
    <p>Selenium — это среда тестирования программного обеспечения с открытым исходным кодом, которая используется для
    автоматизации веб-приложений. Он предоставляет набор инструментов и API-интерфейсов, которые позволяют QA-инженерам
    автоматизировать тестирование и решить задачи, такие как взаимодействие с пользователем, ввод данных и проверка вывода.
    Selenium поддерживает различные языки программирования, такие как Java, Python, C#, Ruby, JavaScript и другие.</p>
    <p>Selenium работает, имитируя действия пользователя в веб-браузере. Он использует компонент драйвера, который
    взаимодействует с веб-браузером и позволяет сценариям автоматизации взаимодействовать с веб-страницей. Драйвер Selenium
    WebDriver является наиболее часто используемым драйвером и поддерживает популярные браузеры, такие как Chrome, Firefox,
    Safari и Edge.</p>
    <p>Вот несколько способов использования Selenium для автоматизированного тестирования:</p>
    <p>Функциональное тестирование: Selenium можно использовать для автоматизации функциональных тестов, чтобы убедиться, что
    веб-приложения работают должным образом. Это включает в себя проверку того, что элементы пользовательского интерфейса
    отображаются правильно, что ссылки и кнопки работают должным образом, а поля формы принимают допустимый ввод.</p>
    <p>Регрессионное тестирование: Selenium можно использовать для автоматизации регрессионных тестов, чтобы гарантировать, что
    изменения, внесенные в веб-приложение, не приведут к появлению новых ошибок или проблем. Регрессионные тесты можно
    запускать несколько раз, чтобы убедиться, что приложение продолжает функционировать должным образом после внесения
    изменений.</p>
    <p>Интеграционное тестирование: Selenium можно использовать для автоматизации интеграционных тестов, чтобы убедиться, что
    различные части веб-приложения работают вместе правильно. Это включает в себя тестирование взаимодействия между
    интерфейсными и внутренними компонентами веб-приложения.</p>
    <p>Кросс-браузерное тестирование: Selenium можно использовать для автоматизации кросс-браузерного тестирования, чтобы
    убедиться, что веб-приложения работают согласованно в разных браузерах и версиях. Это помогает выявлять и устранять
    проблемы, связанные с браузером.</p>
    <p>В целом, Selenium — это мощный инструмент для автоматизации тестирования веб-приложений, который может помочь
    QA-инженерам сэкономить время и силы за счет автоматизации повторяющихся и трудоемких задач тестирования.</p>

    <h1 id="-selenium-webdriver">Настройка первого запуска браузера с помощью Selenium WebDriver</h1>
    <h2 id="-python">Прежде всего, в нашем окружении должен быть интерпретатор Python</h2>
    <p>Установите версию 3.11.2
    <a href="https://www.python.org/downloads/">Python</a></p>
    <p>Мы продолжим работу с нашим ранее созданным репозиторием best-rep-of-the-world, который мы создали в части знакомства с
    системой контроля версий Git.</p>
    <h2 id="-selenium-python">Установка Selenium для Python</h2>
    <p>В виртуальном окружении устанавливаем библиотеку Selenium</p>
    <pre><code class="lang-shell">pip <span class="hljs-keyword">install</span> selenium==<span class="hljs-number">4</span>.*
    </code></pre>
    <p>Можно проверить установку командой</p>
    <pre><code class="lang-shell">pip <span class="hljs-built_in">list</span>
    </code></pre>
    <h2 id="-">Установка драйвера для браузера</h2>
    <p>В этом курсе мы будем работать с драйвером для Chrome, так как на данный момент это самый популярный браузер, и в первую
    очередь следует убедиться, что веб-приложение работает для большинства пользователей.</p>
    <p><img src="img/browser_stats.png" width="800" height="600" alt="browser statistics"></p>
    <p><a href="https://gs.statcounter.com/">statcounter</a></p>
    <p>Драйвер для Chrome разрабатывается командой браузера и носит название ChromeDriver. Скачать нужную версию можно с
    официального сайта по ссылке: <a href="https://chromedriver.chromium.org/">ChromeDriver</a></p>
    <p>Подробности по установке ChromeDriver доступны по
    ссылке: <a href="https://selenium-python.com/install-chromedriver-chrome">Установка драйвера chromedriver для Chrome Selenium</a></p>
    <h2 id="-">Запуск браузера и первый скрипт</h2>
    <p>Далее мы создадим скрипт, который открывает базовую веб-страницу и заполняет форму. Чтобы получить более глубокое
    понимание каждой команды, мы предлагаем запускать их по одной. Не волнуйтесь, если вы не сразу полностью поймете каждую
    команду — мы рассмотрим их более подробно в следующих уроках.</p>
    <pre><code class="lang-python">import time
    
    <span class="hljs-meta"># webdriver это и есть набор команд для управления браузером</span>
    from selenium import webdriver
    
    <span class="hljs-meta"># импортируем класс By, который позволяет выбрать способ поиска элемента</span>
    from selenium.webdriver.common.by import By
    
    <span class="hljs-meta"># инициализируем драйвер браузера. После этой команды вы должны увидеть новое открытое окно браузера</span>
    driver = webdriver.Chrome()
    
    <span class="hljs-meta"># команда time.sleep устанавливает паузу в 5 секунд, чтобы мы успели увидеть, что происходит в браузере</span>
    time.sleep(<span class="hljs-number">5</span>)
    
    <span class="hljs-meta"># Метод get сообщает браузеру, что нужно открыть сайт по указанной ссылке</span>
    driver.<span class="hljs-keyword">get</span>(<span class="hljs-string">"https://suninjuly.github.io/text_input_task.html"</span>)
    time.sleep(<span class="hljs-number">5</span>)
    
    <span class="hljs-meta"># Метод find_element позволяет найти нужный элемент на сайте, указав путь к нему. Способы поиска элементов мы обсудим позже</span>
    <span class="hljs-meta"># Метод принимает в качестве аргументов способ поиска и значение, по которому мы будем искать</span>
    <span class="hljs-meta"># Ищем поле для ввода текста</span>
    textarea = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">".textarea"</span>)
    
    <span class="hljs-meta"># Напишем текст ответа в найденное поле</span>
    textarea.send_keys(<span class="hljs-string">"get()"</span>)
    time.sleep(<span class="hljs-number">5</span>)
    
    <span class="hljs-meta"># Найдем кнопку, которая отправляет введенное решение</span>
    submit_button = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">".submit-submission"</span>)
    
    <span class="hljs-meta"># Скажем драйверу, что нужно нажать на кнопку. После этой команды мы должны увидеть сообщение о правильном ответе</span>
    submit_button.click()
    time.sleep(<span class="hljs-number">5</span>)
    
    <span class="hljs-meta"># После выполнения всех действий мы должны не забыть закрыть окно браузера</span>
    driver.quit()
    </code></pre>
    <p>Запустите скрипт любым доступным способом (запуск из терминала, сочетанием клавиш, через UI).</p>
    <p><img src="img/script_run.png" width="600" height="100" alt="run script"></p>
    <p>Откроется окно браузера, контроллируемое средствами автоматизации.
    Пронаблюдайте за работой скрипта и затем еще раз проанализируйте код.</p>
    <h2 id="-">Зависимости</h2>
    <p>Добавим файл <code>requirements.txt</code>.
    Этот файл отвечает за зависимости, используемые в репозитории.</p>
    <p>Чтобы экспортировать зависимости в такой файл можно воспользоваться командой:</p>
    <pre><code class="lang-shell"><span class="hljs-selector-tag">pip</span> <span class="hljs-selector-tag">freeze</span> &gt; <span class="hljs-selector-tag">requirements</span><span class="hljs-selector-class">.txt</span>
    </code></pre>
    <p>Как видите, в файл <code>requirements.txt</code> добавились все зависимости нашего проекта. Однако не принято в таком файле
    оставлять зависимости нашей единственной библиотеки. Так как мы использовали только библиотеку <code>selenium==4.8.3</code>, а
    остальные зависимости были установлены автоматически для обеспечения ее работы, то мы в файле оставим только ее.</p>
    <p>Обратите внимание на два момента:</p>
    <ol>
    <li>Необходимо перенести файл <code>requirements.txt</code> в папку репозитория.</li>
    <li>Последняя строчка в файле <code>requirements.txt</code> должна быть пустой (загуглите почему).</li>
    </ol>
    <p>Сохраняем изменения в репозитории коммитами, пушим в удалённый репозиторий.</p>
    <p>Наша история коммитов в репозитории должна выглядеть примерно следующим образом:</p>
    <p><img src="img/commit_history.png" width="200" height="400" alt="commit history"></p>

    <h1 id="-">Поиск элементов</h1>
    <h2 id="-css-">Поиск элементов с помощью CSS-селекторов</h2>
    <p>Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:</p>
    <ul>
    <li>id</li>
    <li>tag</li>
    <li>значение атрибута</li>
    <li>name</li>
    <li>class</li>
    </ul>
    <p>Давайте откроем страницу <a href="http://suninjuly.github.io/cats.html">Cats album</a> и попробуем найти элемент, который содержит
    картинку с Котом-пулей (Bullet cat).</p>
    <p>Чтобы это сделать вам потребуется использовать DevTools вашего браузера. Я рекомендую вам
    использовать <a href="https://www.google.com/chrome/">Google Chrome</a>.</p>
    <p>Для включения DevTools можно нажать F12 на клавиатуре.</p>
    <p>Ниже приведён кусок html-кода страницы:</p>
    <pre><code class="lang-html">
    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"col-sm-4"</span>&gt;
        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"card mb-4 box-shadow"</span>&gt;
            &lt;img <span class="hljs-built_in">id</span>=<span class="hljs-string">"bullet"</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"bullet-cat"</span> data-type=<span class="hljs-string">"animal"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"card-img-top"</span> src=<span class="hljs-string">"images/bullet_cat.jpg"</span>&gt;
        &lt;/<span class="hljs-keyword">div</span>&gt;
    &lt;/<span class="hljs-keyword">div</span>&gt;
    </code></pre>
    <p>Для начала мы попробуем искать элементы вручную с помощью консоли браузера, а в следующем уроке научимся писать код,
    который выполняет ту же задачу поиска.</p>
    <h3 id="-id">Поиск по id</h3>
    <p>У элемента с нашей картинкой есть атрибут id=&quot;bullet&quot;, а значит, мы однозначно можем найти её с помощью
    селектора <code>#bullet</code> (знак <code>#</code> означает, что мы ищем по <strong>id</strong> со значением <strong>bullet</strong>).</p>
    <p>Можно проверить правильность подобранного селектора непосредственно в браузере в консоли разработчика. Откройте консоль
    разработчика и перейдите в ней на вкладку <code>Elements</code>. Затем нажмите <code>ctrl+F</code> и в открывшейся внизу поисковой строке
    введите <code>#bullet</code>. Если селектор написан правильно,
    то вы увидите подсвеченный элемент на веб-странице, а также элемент будет
    подсвечен жёлтым цветом в html-коде. Еще в поисковой строке вы увидите количество найденных элементов. Желательно писать
    уникальные селекторы, которые позволяют найти единственный элемент.</p>
    <p>Еще один способ открыть консоль разработчика в браузере: нажать правой кнопкой мыши на любой элемент страницы и выбрать
    пункт меню &quot;Посмотреть код&quot; (англ. &quot;Inspect&quot;) в контекстном меню. При этом на вкладке <code>Elements</code> сразу будет подсвечен
    кусок HTML-кода, описывающий данный элемент.</p>
    <p><img src="img/id_search.png" width="800" height="400" alt="id search"></p>
    <h3 id="-tag">Поиск по tag</h3>
    <p>Чтобы найти элемент по тегу, просто напишите название тега в поисковой строке, как мы делали это при поиске по <code>id</code> (
    только без знака <code>#</code>), например, <code>h1</code>. Поиск по <code>h1</code> найдёт для нас элемент с названием страницы. Поиск по тегам не
    очень удобен, т.к. разработчики используют небольшое количество тегов для разметки страниц, и скорее всего, одному тегу
    будет соответствовать несколько элементов.</p>
    <h3 id="-">Поиск по значению атрибута</h3>
    <p>Можно найти элемент, указав название атрибута и его значение. Например, можно переписать поиск по <code>id</code> в следующем
    виде <code>[id=&quot;bullet&quot;]</code> вместо <code>#bullet</code>.</p>
    <p>Лучше использовать вариант с квадратными скобками при поиске значения атрибута для тех атрибутов, у которых нет
    собственных коротких команд поиска. Например, давайте найдем элемент <code>h1</code> по значению его атрибута
    <code>value</code>: <code>[value=&quot;Cat memes&quot;]</code>.</p>
    <h3 id="-name">Поиск по name</h3>
    <p>Этот вариант поиска является разновидностью поиска по значению атрибута и записывается так же: <code>[name=&quot;bullet-cat&quot;]</code>. Мы
    выделяем этот вариант потому что он довольно часто используется, а также выделяется как отдельный вид поиска элементов в
    Selenium WebDriver.</p>
    <h3 id="-class">Поиск по class</h3>
    <p>Поиск по классу можно записать в виде <code>[class=&quot;jumbotron-heading&quot;]</code>, так как <code>class</code> тоже является атрибутом элемента.
    Но раз уж классы используются практически в каждой странице при задании стилей страниц, то для них также имеется свой
    короткий вариант поиска: <code>.jumbotron-heading</code>. То есть мы пишем значение класса и предваряем его точкой.</p>
    <p>Давайте рассмотрим важную разницу между двумя способами поиска по классу. Допустим, у элемента <code>article</code> задано больше
    одного класса, как на странице <a href="http://suninjuly.github.io/cats.html">Cats album</a>:</p>
    <pre><code class="lang-html">
    &lt;article <span class="hljs-built_in">id</span>=<span class="hljs-string">"moto"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"lead text-muted"</span> title=<span class="hljs-string">"one-thing"</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"moto"</span>&gt;If there's one thing <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> internet was made
        <span class="hljs-keyword">for</span>, <span class="hljs-keyword">it</span>'s funny cat memes.
    &lt;/article&gt;
    </code></pre>
    <p>Вариант <code>[class=&quot;lead&quot;]</code> не найдет нам этот элемент, так как он ищет по точному совпадению. Чтобы найти элемент, нам
    нужно будет написать <code>[class=&quot;lead text-muted&quot;]</code>, порядок классов при этом важен. <code>[class=&quot;text-muted lead&quot;]</code> — уже не
    найдет искомый элемент.</p>
    <p>Вариант <code>.lead</code> при этом позволит найти данный элемент, так как он ищет простое вхождение класса в элемент. Для
    уточнения селектора можно задать также оба класса, для этого нужно добавить второй класс к строке поиска без пробела и
    предварить его точкой: <code>.lead.text-muted</code>. Порядок классов в отличие от первого способа здесь не
    важен — <code>.text-muted.lead</code> так же найдет нужный элемент. Рекомендуем пользоваться вторым способом поиска классов, так
    как он является более гибким.</p>
    <p>Еще одно важное замечание. Поиск по классу чувствителен к регистру, то есть <code>.Lead</code> уже не найдет нужный элемент.</p>
    <p>В консоли браузера вы также можете искать по простому совпадению текста в HTML, например, запрос <code>lead</code> подсветит текст
    <code>lead</code>. Однако, не стоит пользоваться таким поиском для выбора элементов, так как он слишком общий и не может
    использоваться в качестве селектора.</p>
    <p>Мы рассмотрели разные варианты написания пути к элементу на странице, используя синтаксис CSS, т.е. научились писать
    CSS-селекторы. Слово &quot;селектор&quot; является буквальным переводом от английского слова selector. Selector в свою очередь
    происходит от глагола select, что переводится как &quot;выбирать&quot;. Так же часто используется термин &quot;локатор&quot;, что является
    синонимом &quot;селектор&quot; в контексте автоматизации UI.</p>
    <h2 id="-css-">Поиск элементов с помощью составных CSS-селекторов</h2>
    <p>Теперь предположим, что не можем найти элемент на странице, используя простой селектор, так как такой селектор находит
    сразу несколько элементов. Ниже мы привели часть кода простой HTML-страницы, описывающей блог. Саму страницу вы можете
    посмотреть по <a href="http://suninjuly.github.io/blog_example.html">ссылке</a>.</p>
    <p>Вопрос: как нам найти селектор для подписи у второй картинки? Вот здесь нам поможет иерархическая структура страницы и
    возможность комбинировать CSS-селекторы. CSS-селекторы позволяют использовать одновременно любые селекторы,
    рассмотренные ранее, а также имеют некоторые дополнительные возможности для уточнения поиска.</p>
    <pre><code class="lang-html">
    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"posts"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"post-list"</span>&gt;
        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"post1"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"item"</span>&gt;
            &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"title"</span>&gt;Как я провел лето&lt;/<span class="hljs-keyword">div</span>&gt;
            &lt;img src=<span class="hljs-string">"./images/summer.png"</span>&gt;
        &lt;/<span class="hljs-keyword">div</span>&gt;
        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"post2"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"item"</span>&gt;
            &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"title second"</span>&gt;Ходили купаться&lt;/<span class="hljs-keyword">div</span>&gt;
            &lt;img src=<span class="hljs-string">"./images/bad_dog.jpg"</span>&gt;
        &lt;/<span class="hljs-keyword">div</span>&gt;
        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"post3"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"item"</span>&gt;
            &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"title"</span>&gt;С друзьями&lt;/<span class="hljs-keyword">div</span>&gt;
            &lt;img src=<span class="hljs-string">"./images/friends.jpg"</span>&gt;
        &lt;/<span class="hljs-keyword">div</span>&gt;
    &lt;/<span class="hljs-keyword">div</span>&gt;
    </code></pre>
    <h3 id="-">Использование потомков</h3>
    <p>Попробуем найти элемент с текстом &quot;Ходили купаться&quot;. Для решения этой задачи мы можем взять элемент, стоящий выше в
    иерархии нужного нам элемента, и написать следующий селектор:</p>
    <p><code>#post2 .title</code></p>
    <p>Здесь символ <code>#</code> означает, что надо искать элемент с id <code>post2</code>, пробел - что также нужно найти элемент-потомок, а <code>.</code>,
    что элемент-потомок должен иметь класс со значением <code>title</code>.</p>
    <p>Элемент <code>.title</code> называется <strong>потомком</strong> (англ. <strong>descendant</strong>) элемента <code>#post2</code>. Потомок может находиться на любом
    уровне вложенности, все элементы с селектором <code>.title</code> также являются и потомками элемента <code>#posts</code>, хотя и расположены
    от него на два уровня ниже. <code>#posts .title</code> найдет все 3 элемента с классом <code>title</code>.</p>
    <p><strong>!Внимание</strong>. Символ пробела &quot; &quot; является значащим в CSS-селекторах. Это важный символ, который разделяет описание
    предка и потомка. Если бы мы записали селектор <code>#post2.title</code> без пробела, то в данном примере не было найдено ни одного
    элемента. Такая запись означала бы, что мы хотим найти элемент, который одновременно содержит id &quot;post2&quot; и класс &quot;
    title&quot;. Таким образом <code>#post2 .title</code> и <code>#post2.title</code> — это разные селекторы.</p>
    <h3 id="-">Использование дочерних элементов</h3>
    <p>Другой способ найти этот элемент:</p>
    <p><code>#post2 &gt; div.title</code></p>
    <p>Здесь мы указали еще тег элемента <code>div</code> и уточнили, что нужно взять элемент с тегом и классом: <code>div.title</code>, который
    находится строго на один уровень иерархии ниже чем элемент <code>#post2</code>. Для этого используется символ <code>&gt;</code>.</p>
    <p>Элемент <code>#post2</code> в этом случае называется <strong>родителем</strong> (англ. <strong>parent</strong>) для элемента <code>div.title</code>, а
    элемент <code>div.title</code> называется <strong>дочерним элементом</strong> (англ. <strong>child</strong>) для элемента <code>#post2</code>. Если символа <code>&gt;</code> нет, то
    будет выполнен поиск всех элементов <code>div.title</code> на любом уровне ниже первого элемента.</p>
    <p><strong>!Внимание</strong>. В данном случае символы пробела вокруг символа <code>&gt;</code> не несут важного значения в отличие от предыдущего
    примера, и могут быть опущены. Запись <code>#post2&gt;div.title</code> аналогична записи <code>#post2 &gt; div.title</code>.</p>
    <h3 id="-">Использование порядкового номера дочернего элемента</h3>
    <p>Еще один способ найти этот элемент:</p>
    <p><code>#posts &gt; .item:nth-child(2) &gt; .title</code></p>
    <p>Псевдо-класс <code>:nth-child(2)</code> — позволяет найти второй по порядку элемент среди дочерних элементов для <code>#posts</code>. Затем с
    помощью конструкции <code>&gt; .title</code> мы указываем, что нам нужен элемент <code>.title</code>, родителем которого является найденный ранее
    элемент <code>.item</code>.</p>
    <h3 id="-">Использование нескольких классов</h3>
    <p>Также мы можем использовать сразу несколько классов элемента, чтобы его найти. Для этого классы записываются подряд
    через точку: <code>.title.second</code></p>
    <h2 id="-xpath">Поиск элементов с помощью XPath</h2>
    <p>В работе с веб-страницами не всегда получается найти селектор, однозначно описывающий путь к нужному элементу. В такой
    ситуации для тестировщика лучшим решением проблемы будет пойти к фронтенд-разработчику проекта и договориться о
    специальном атрибуте, который будет использоваться в автотестах. Таким образом можно повысить тестируемость приложения.
    Увы, проекты бывают разные, и не всегда это возможно. И когда другого выхода больше нет, а автоматизировать как-то надо,
    можно обратиться к помощи языка запросов <strong>XPath</strong>.</p>
    <p>На тему XPath мнения расходятся, но, как бы то ни было, это мощный и гибкий инструмент, который позволяет писать сложные
    запросы для поиска элементов.</p>
    <p>Прежде всего, XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа. Проверять
    XPath-запросы можно точно так же как и CSS-селекторы — в консоли разработчика. Откройте консоль на странице с
    котиками <a href="http://suninjuly.github.io/cats.html">Cats album</a>, и давайте на её примере разберемся в основах синтаксиса.
    Попробуйте вбить каждый из запросов-примеров в строку поиска, чтобы увидеть, что именно находит поисковый запрос.</p>
    <ol>
    <li><strong>XPath запрос всегда начинается с символа / или //</strong></li>
    </ol>
    <p>Символ / аналогичен символу &gt; в CSS-селекторе, а символ // — пробелу. Их смысл:</p>
    <ul>
    <li>el1/el2 — выбирает элементы el2, являющиеся прямыми потомками el1;</li>
    <li>el1//el2 — выбирает элементы el2, являющиеся потомками el1 любой степени вложенности.</li>
    </ul>
    <p>Разница состоит в том, что в XPath, когда мы начинаем запрос с символа /, мы должны указать элемент, являющийся корнем
    нашего документа. Корнем всегда будет элемент с тегом <code>&lt;html&gt;</code>. Пример: <code>/html/body/header</code></p>
    <p>Мы можем начинать запрос и с символа //. Это будет означать, что мы хотим найти всех потомков корневого элемента без
    указания корневого элемента. В этом случае, для поиска того же хедера, мы можем выполнить запрос <code>//header</code>, так как
    других заголовков у нас нет.</p>
    <p>Важно! Такой поиск может быть неоднозначным. Например, запрос <code>//div</code> вернет вам все элементы с тегом <code>&lt;div&gt;</code>. Избегайте
    неоднозначных ситуаций, они плохо влияют на здоровье ваших автотестов.</p>
    <ol>
    <li><strong>Символ [ ] — это команда фильтрации</strong></li>
    </ol>
    <p>Если по запросу найдено несколько элементов, то будет произведена фильтрация по правилу, указанному в скобках.</p>
    <p>Правил фильтрации очень много:</p>
    <ul>
    <li>по любому <strong>атрибуту</strong>, будь то <code>id</code>, <code>class</code>, <code>title</code> (или любой другой). Например, мы хотим найти картинку с летящим
    котом, для этого можно выполнить запрос <code>//img[@id=&#39;bullet&#39;]</code></li>
    <li>по <strong>порядковому номеру</strong>. Допустим, мы хотим выбрать вторую по порядку карточку с котом. Для этого найдем элемент с
    классом &quot;row&quot; и возьмем его второго потомка: <code>//div[@class=&quot;row&quot;]/div[2]</code></li>
    <li>по <strong>полному совпадению текста</strong>. Да, XPath — это единственный способ найти элемент по внутреннему тексту. Если мы
    хотим найти блок текста с котом-Лениным, можно воспользоваться XPath селектором <code>//p[text()=&quot;Lenin cat&quot;]</code>. Такой
    селектор вернет элемент, только если текст полностью совпадет. Здесь важно сказать, что не всегда поиск по тексту —
    это хорошая практика, особенно в случае мультиязычных сайтов.</li>
    <li>по <strong>частичному совпадению</strong> текста или атрибута. Для этого нужна функция <code>contains</code>.
    Запрос <code>//p[contains(text(), &quot;cat&quot;)]</code>
    вернет нам все абзацы текста, которые содержат слово cat. Точно так же можно искать по частичному совпадению других
    атрибутов, это удобно, если у элемента несколько классов. Посмотрите на код навбара сайта с котами. Его можно найти
    селектором <code>//div[contains(@class, &quot;navbar&quot;)]</code></li>
    <li><p>в фильтрации еще можно использовать булевы операции (and, or, not) и некоторые простые арифметические выражения (но
    вообще не стоит, наверное). Допустим, мы хотим найти картинку обязательно с data-type &quot;animal&quot; и именем &quot;bullet-cat&quot;,
    для этого подойдет запрос: <code>//img[@name=&#39;bullet-cat&#39; and @data-type=&#39;animal&#39;]</code></p>
    </li>
    <li><p><strong>Символ * — команда выбора всех элементов</strong></p>
    </li>
    <li><p>Например можем найти текст в заголовке запросом <code>//div/*[@class=&quot;jumbotron-heading&quot;]</code>. Это может быть удобно, когда мы
    не знаем точно тег элемента, который ищем.</p>
    </li>
    <li><p>Поиск по классу в XPath регистрозависим</p>
    </li>
    </ul>
    <p>Также как и в случае поиска по CSS-селектором будьте внимательными к регистру при поиске по классам:</p>
    <p><code>//div/*[@class=&quot;Jumbotron-heading&quot;]</code> не найдет элемент на нашей странице.</p>
    <p>Что важно знать про XPath, чтобы пользоваться им безболезненно:</p>
    <ul>
    <li>Не используйте селекторы вида <code>//div[1]/div[2]/div[3]</code> без крайней нужды: по такому селектору невозможно с первого
    раза
    понять, что за элемент вы ищете. А когда структура страницы хоть немного изменится, то ваш селектор с большой
    вероятностью перестанет работать;</li>
    <li>Если есть возможность использовать CSS-селекторы: <code>сlass</code>, <code>id</code> или <code>name</code> — лучше использовать их вместо поиска по
    XPath;</li>
    <li>Можно искать по полному или частичному совпадению текста или любого атрибута;</li>
    <li>Можно использовать булевы операции и простую арифметику;</li>
    <li>Можно удобно перемещаться по структуре документа (переходить к потомкам и к родителям);</li>
    <li>Подойдет, когда у сайта всё плохо с атрибутами и нет возможности достучаться до разработчиков;</li>
    <li>Есть мнение, что поиск по XPath в среднем медленнее, чем по css. Но достоверно это неизвестно;</li>
    <li>Не стоит использовать разные расширения для браузеров по поиску XPath: они подбирают нечитабельные и переусложненные
    селекторы. Лучше потратить немного времени и разобраться в синтаксисе самостоятельно, тем более, что он не очень
    сложный.</li>
    </ul>
    <p>Мы рассмотрели базовые селекторы, которых будет достаточно для написания простых UI-тестов.</p>

    <h1 id="-">Практика в написании селекторов</h1>
    <h2 id="-">Задание: поиск по тегу</h2>
    <p>Откройте страницу с <a href="http://suninjuly.github.io/blog_example.html">блогом</a> в браузере в инкогнито режиме. Затем откройте
    консоль разработчика - вкладка Elements. Введите в строку поиска тег div.
    Сколько элементов было найдено?</p>
    <details>
      <summary>Правильный ответ</summary>
    
    + 7
    
    </details>
    
    <h2 id="-1">Задание: подбор селекторов 1</h2>
    <p>Для страницы <a href="http://suninjuly.github.io/cats.html">Cats album</a> сопоставьте селектор для поиска элемента, содержащего
    текст &quot;If there&#39;s one thing..&quot;, и тип селектора.</p>
    <ol>
    <li><code>#moto</code></li>
    <li><code>article</code></li>
    <li><code>[title=&quot;one-thing&quot;]</code></li>
    <li><code>[name=&quot;moto&quot;]</code></li>
    <li><code>.lead</code></li>
    <li><code>article.text-muted.lead</code></li>
    </ol>
    <blockquote>
    <p>Поиск по ID, Поиск по name, Поиск по attribute, Поиск по составному CSS-селектору, Поиск по tag, Поиск по class</p>
    </blockquote>
    <table>
    <thead>
    <tr>
    <th>CSS selector</th>
    <th>Type of search</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td><code>#moto</code></td>
    <td></td>
    </tr>
    <tr>
    <td><code>article</code></td>
    <td></td>
    </tr>
    <tr>
    <td><code>[title=&quot;one-thing&quot;]</code></td>
    <td></td>
    </tr>
    <tr>
    <td><code>[name=&quot;moto&quot;]</code></td>
    <td></td>
    </tr>
    <tr>
    <td><code>.lead</code></td>
    <td></td>
    </tr>
    <tr>
    <td><code>article.text-muted.lead</code></td>
    </tr>
    </tbody>
    </table>
    <details>
      <summary>Правильный ответ</summary>
    
    | CSS selector              | Type of search                    |
    |---------------------------|-----------------------------------|
    | <code>#moto</code>                   | Поиск по ID                       |
    | <code>article</code>                 | Поиск по tag                      |
    | <code>[title=&quot;one-thing&quot;]</code>     | Поиск по attribute                |
    | <code>[name=&quot;moto&quot;]</code>           | Поиск по name                     |
    | <code>.lead</code>                   | Поиск по class                    |
    | <code>article.text-muted.lead</code> | Поиск по составному CSS-селектору |
    
    </details>
    
    <h2 id="-">Задание: иерархия элементов в веб-странице</h2>
    <p>Откройте страницу <a href="http://suninjuly.github.io/cats.html">Cats album</a>. Откройте консоль разработчика и вкладку Elements в
    ней. Сопоставьте правильно селекторы элементов на странице и их роль в рамках семейного древа HTML-страницы.</p>
    <ol>
    <li><code>div.card-body</code></li>
    <li><code>p.card-text</code></li>
    <li><code>div.card</code></li>
    </ol>
    <blockquote>
    <p>потомок для &quot;div.col-sm-4&quot;, дочерний элемент для &quot;div.card-body&quot;, родитель для &quot;div.card-body&quot;</p>
    </blockquote>
    <table>
    <thead>
    <tr>
    <th>CSS selector</th>
    <th>Inheritance</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td><code>div.card-body</code></td>
    <td></td>
    </tr>
    <tr>
    <td><code>p.card-text</code></td>
    <td></td>
    </tr>
    <tr>
    <td><code>div.card</code></td>
    </tr>
    </tbody>
    </table>
    <details>
      <summary>Правильный ответ</summary>
    
    | CSS selector    | Inheritance                          |
    |-----------------|--------------------------------------|
    | <code>div.card-body</code> | потомок для &quot;div.col-sm-4&quot;           |
    | <code>p.card-text</code>   | дочерний элемент для &quot;div.card-body&quot; |
    | <code>div.card</code>      | родитель для &quot;div.card-body&quot;         |
    
    </details>
    
    <h2 id="-">Задание: поиск потомка</h2>
    <p>Откройте страницу <a href="http://suninjuly.github.io/cats.html">Cats album</a>. Откройте консоль разработчика и вкладку Elements в
    ней. Напишите минимально достаточный CSS-селектор, который найдет элемент с картинкой серьезного кота (Serious cat). Для
    поиска подходящего элемента в каталоге картинок используйте родительский элемент <code>div.col-sm-4</code> вместе с
    псевдо-классом <code>:nth-child(n)</code>, чтобы выбрать n-й по счету элемент, а также селектор для картинки по тегу <code>img</code>. При
    написании этого селектора не надо использовать символ <code>&gt;</code>, т.к. это задача на поиск потомка без использования дочерних
    элементов. Для решения достаточно тех селекторов, которые уже указаны в задании.</p>
    <p>Пожалуйста, не используйте селекторы, которые генерирует браузер по кнопке &quot;скопировать css селектор&quot; или расширения.
    Зачастую они строят полный путь, начиная от <code>body</code> — а это очень нестабильный селектор, писать такие в своем коде это
    плохая практика. При малейшем изменении структуры страницы все ваши селекторы потеряют актуальность.</p>
    <p>Не используйте в синтаксисе квадратные скобки — конструкции вида <code>[class=&quot;stepic&quot;]</code>.</p>
    <details>
      <summary>Правильный ответ</summary>
    
    + Решений у задачи много, если у вас получилось выбрать элемент и он единственный, то у вас все правильно получилось.
    + Вариант правильного решения: <code>div.col-sm-4:nth-child(2) img</code>
    
    </details>
    
    <h2 id="-2">Задание: подбор селекторов 2</h2>
    <p>Отметьте те селекторы, которые позволят найти только элемент с текстом &quot;Lenin cat&quot; на
    странице <a href="http://suninjuly.github.io/cats.html">Cats album</a>. Вы можете вводить приведенные здесь примеры селекторов в
    поиске в консоли разработчика, если составление сложных селекторов пока вызывает у вас затруднение.</p>
    <ul>
    <li><code>#politic</code></li>
    <li><code>p:nth-child(3)</code></li>
    <li><code>.card-body:nth-child(3) p</code></li>
    <li><code>[data-name=&quot;Vladimir&quot;]</code></li>
    <li><code>.col-sm-4:nth-child(3) p</code></li>
    <li><code>[name=&quot;Vladimir&quot;]</code></li>
    </ul>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>#politic</code>
    + <code>[data-name=&quot;Vladimir&quot;]</code>
    + <code>.col-sm-4:nth-child(3) p</code>
    
    </details>
    
    <h2 id="-3">Задание: подбор селекторов 3</h2>
    <p>Lenin cat продолжает скрываться. Снова отметьте только те уникальные селекторы, которые позволят найти элемент,
    содержащий текст &quot;Lenin cat&quot; на странице <a href="http://suninjuly.github.io/cats.html">Cats album</a>. Теперь набор правильных и
    неправильных селекторов стал другим.</p>
    <blockquote>
    <p>Обратите внимание: если селектор находит несколько элементов, то он не подходит в качестве ответа на эту задачу.</p>
    </blockquote>
    <ul>
    <li><code>.card-text</code></li>
    <li><code>.lenin-cat</code></li>
    <li><code>.card-text.lenin-cat</code></li>
    <li><code>[text=&quot;Lenin cat&quot;]</code></li>
    <li><code>.lenin_cat</code></li>
    </ul>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>.lenin-cat</code>
    + <code>.card-text.lenin-cat</code>
    
    </details>
    
    <h2 id="-xpath">Задание: поиск по XPath</h2>
    <p><a href="http://suninjuly.github.io/xpath_examples">xpath_examples</a></p>
    <p>У нас тут на странице кошмар авто-тестера: 8 одинаковых кнопок. Подберите такой XPath-селектор, чтобы выбрать только
    кнопку с текстом Gold. Используйте XPath-запрос с методом text().</p>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>//button[contains(text(), &quot;Gold&quot;)]</code>
    
    </details>
    
    <h2 id="-ex001-id-examples-">Задание ex001. ID-селекторы (папка examples)</h2>
    <p>CSS-селекторы используют фронтенд-разработчики, чтобы выбрать элементы на странице и применить к ним определенные стили,
    то есть правила для отрисовки. В автотестах мы пишем селекторы по тем же самым правилам, чтобы найти нужные нам элементы
    и произвести с ними какие-то действия с помощью Selenium WebDriver.</p>
    <p>Откройте файл <code>ex001.html</code>. Для этого можно открыть файл в PyCharm и нажать иконку браузера.</p>
    <p><img src="img/open_html_file.png" width="500" height="200" alt="open html file"></p>
    <p>Попробуйте написать селектор, который найдет элемент с заголовком в карточке первого кота.
    Используйте для этого ID элемента.</p>
    <p>Результат должен быть следующим:</p>
    <p><img src="img/ex001_result.png" width="300" height="400" alt="ex001 result"></p>
    <p>Вместо текста &quot;ваш селектор здесь&quot; в файле <code>ex001.css</code> напишите селектор:</p>
    <pre><code class="lang-css">ваш селектор здесь
    {
        <span class="hljs-attribute">color</span>:blue;
    }
    </code></pre>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>#polite</code>
    
    </details>
    
    <h2 id="-ex002-data-type-examples-">Задание ex002. Селектор с атрибутом data-type (папка examples)</h2>
    <p>Попробуйте написать селектор, который найдет элемент с текстом-описанием к карточке первого кота. Используйте
    специальный атрибут data-typе.</p>
    <p>Обратите внимание, что выбрать нужно только один элемент!</p>
    <p>Результат должен быть следующим:</p>
    <p><img src="img/ex002_result.png" width="300" height="400" alt="ex002 result"></p>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>.card-body &gt; [data-type]</code>
    
    </details>
    
    <h2 id="-ex003-examples-">Задание ex003. Селектор класса (папка examples)</h2>
    <p>Подберите селектор для текста в подзаголовке страницы, и добавьте ему синий цвет. Можно сделать это по-разному, но
    попробуйте использовать здесь класс элемента. Будьте внимательны и подберите уникальный селектор, чтобы по нему
    однозначно находился только один элемент.</p>
    <p>Результат должен быть следующим:</p>
    <p><img src="img/ex003_result.png" width="700" height="400" alt="ex003 result"></p>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>p.text</code>
    
    </details>
    
    <h2 id="-ex004-examples-">Задание ex004. Составной селектор из нескольких классов (папка examples)</h2>
    <p>Структура страницы еще немного поменялась. Подберите селектор к первому абзацу текста на карточке с арбузным котом (это
    последняя карточка). Текст который должен стать синим - &quot;Watermelon story&quot;. Будьте внимательны и выберите уникальный
    селектор, чтобы синим стал один и только один элемент!</p>
    <p>Результат должен быть следующим:</p>
    <p><img src="img/ex004_result.png" width="300" height="300" alt="ex004 result"></p>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>.watermelon &gt; p.description</code>
    
    </details>
    
    <h2 id="-ex005-examples-">Задание ex005. Составной селектор (папка examples)</h2>
    <p>Подберите селектор к описанию второй карточки с бананом и котом (элемент с текстом &quot;Cat doesn&#39;t like bananas!&quot;). Будьте
    внимательны и подберите уникальный селектор, чтобы по нему однозначно находился только один элемент.</p>
    <p>Результат должен быть следующим:</p>
    <p><img src="img/ex005_result.png" width="300" height="300" alt="ex005 result"></p>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>.banana [data-type]</code>
    
    </details>
    
    <h2 id="-ex006-">Задание ex006. Иерархическая структура + порядок элементов</h2>
    <p>С текстом вроде бы разобрались! Давайте теперь поиграем шрифтами на кнопках. Найдите вторую кнопку (она с текстом <strong>&quot;
    Edit&quot;</strong>) на карточке с котом и бананом. Напишите для неё уникальный селектор, так, чтобы никакие другие элементы не
    выделялись.</p>
    <p><img src="img/ex006_result.png" width="300" height="300" alt="ex006 result"></p>
    <details>
      <summary>Правильный ответ</summary>
    
    + <code>[name=&quot;banana&quot;] &gt; .btn-group &gt; .btn:nth-child(2)</code>
    
    </details>

    <h1 id="-selenium-webdriver">Поиск элементов с помощью Selenium WebDriver</h1>
    <h2 id="-selenium">Поиск элементов с помощью Selenium</h2>
    <p>Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий, позволяющих искать по атрибутам
    элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Для поиска Selenium предоставляет метод <code>find_element</code>,
    который принимает два аргумента - тип локатора и значение локатора. Существуют следующие методы поиска элементов:</p>
    <ul>
    <li><code>find_element(By.ID, value)</code> - поиск по уникальному атрибуту <code>id</code> элемента. Если ваши разработчики проставляют всем
    элементам в приложении уникальный <code>id</code>, то вам повезло, и вы чаще всего будет использовать этот метод, так как он
    наиболее стабильный;</li>
    <li><code>find_element(By.CSS_SELECTOR, value)</code> - поиск элемента с помощью правил на основе CSS. Это универсальный метод
    поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если
    <code>find_element_by_id</code> вам не подходит из-за отсутствия <code>id</code> у элементов, то скорее всего вы будете использовать именно
    этот метод в ваших тестах;</li>
    <li><code>find_element(By.XPATH, value)</code> - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск
    элементов;</li>
    <li><code>find_element(By.NAME, value)</code> - поиск по атрибуту name элемента;</li>
    <li><code>find_element(By.TAG_NAME, value)</code> - поиск элемента по названию тега элемента;</li>
    <li><code>find_element(By.CLASS_NAME, value)</code> - поиск по значению атрибута class;</li>
    <li><code>find_element(By.LINK_TEXT, value)</code> - поиск ссылки на странице по полному совпадению;</li>
    <li><code>find_element(By.PARTIAL_LINK_TEXT, value)</code> - поиск ссылки на странице, если текст селектора совпадает с любой частью
    текста ссылки.</li>
    </ul>
    <p>Например, мы хотим найти кнопку со значением <code>id=&quot;submit_button&quot;</code>:</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-keyword">browser </span>= webdriver.Chrome()
    <span class="hljs-keyword">browser.get("http://suninjuly.github.io/simple_form_find_task.html")
    </span><span class="hljs-keyword">button </span>= <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"submit"</span>)
    </code></pre>
    <p>Обратите внимание, что мы импортировали класс By, который содержит все возможные локаторы.</p>
    <p>Если страница у вас загрузилась, но дальше ничего не происходит, вернитесь обратно в консоль, в которой вы запускали ваш
    скрипт. Скорее всего, вы увидите там ошибку <code>NoSuchElementException</code>. Она будет выглядеть следующим образом:</p>
    <pre><code>selenium.common.exceptions.<span class="hljs-string">NoSuchElementException:</span> <span class="hljs-string">Message:</span> no such <span class="hljs-string">element:</span> Unable to locate <span class="hljs-string">element:</span>
    {<span class="hljs-string">"method"</span>:<span class="hljs-string">"id"</span>,<span class="hljs-string">"selector"</span>:<span class="hljs-string">"submit"</span>}
    </code></pre><p>Ошибка очевидна: мы неправильно указали локатор — значит, кнопки с таким <code>id</code> на странице нет.</p>
    <p>Исправим локатор, чтобы наш код проходил без ошибок:</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-keyword">browser </span>= webdriver.Chrome()
    <span class="hljs-keyword">browser.get("http://suninjuly.github.io/simple_form_find_task.html")
    </span><span class="hljs-keyword">button </span>= <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"submit_button"</span>)
    </code></pre>
    <h3 id="-">Поиск нескольких элементов</h3>
    <p>Вы можете столкнуться с ситуацией, когда на странице будет несколько элементов, подходящих под заданные вами параметры
    поиска. В этом случае WebDriver вернет вам только первый элемент, который встретит во время поиска по HTML. Если вам
    нужен не первый, а второй или следующие элементы, вам нужно либо задать более точный селектор для поиска, либо
    использовать методы <code>find_elements</code>, которые мы рассмотрим чуть позже.</p>
    <h2 id="-selenium">Работа с браузером в Selenium</h2>
    <p>Если вы уже пробовали запускать примеры скриптов, то могли заметить, что браузер не всегда закрывается после выполнения
    кода. Поэтому обратите внимание на то, что необходимо явно закрывать окно браузера в нашем коде при помощи команды
    <code>browser.quit()</code>. Каждый раз при открытии браузера <code>browser = webdriver.Chrome()</code> в системе создается процесс, который
    останется висеть, если вы вручную закроете окно браузера. Чтобы не остаться без оперативной памяти после запуска
    нескольких скриптов, всегда добавляйте к своим скриптам команду закрытия:</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-symbol">link</span> = <span class="hljs-string">"http://suninjuly.github.io/simple_form_find_task.html"</span>
    <span class="hljs-keyword">browser </span>= webdriver.Chrome()
    <span class="hljs-keyword">browser.get(link)
    </span><span class="hljs-keyword">button </span>= <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"submit_button"</span>)
    <span class="hljs-keyword">button.click()
    </span>
    # закрываем браузер после всех манипуляций
    <span class="hljs-keyword">browser.quit()</span>
    </code></pre>
    <p>Важно еще пояснить разницу между двумя командами: <code>browser.close()</code> и <code>browser.quit()</code>.
    Какая между ними разница, ведь на первый взгляд обе они осуществляют одно и то же?</p>
    <p>На самом деле, <code>browser.close()</code> закрывает текущее окно браузера.
    Это значит, что если ваш скрипт вызвал всплывающее окно,
    или открыл что-то в новом окне или вкладке браузера, то закроется только текущее окно, а все остальные останутся висеть.
    В свою очередь <code>browser.quit()</code> закрывает все окна, вкладки,
    и процессы вебдрайвера, запущенные во время тестовой сессии.</p>
    <p>Подробнее можно посмотреть
    здесь:
    <a href="https://stackoverflow.com/questions/15067107/difference-between-webdriver-dispose-close-and-quit">Difference between webdriver.Dispose(), .Close() and .Quit()</a>.</p>
    <p>Будьте внимательны с этими методами и, в общем случае, всегда используйте <code>browser.quit()</code>.</p>
    <p>Но что будет, если скрипт не дойдет до выполнения этого финального шага, а упадет с ошибкой где-то раньше?</p>
    <p>Для того чтобы гарантировать закрытие, даже если произошла ошибка в предыдущих строках, проще всего использовать
    конструкцию <code>try/finally</code>:</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-symbol">link</span> = <span class="hljs-string">"http://suninjuly.github.io/simple_form_find_task.html"</span>
    <span class="hljs-symbol">
    try:</span>
        <span class="hljs-keyword">browser </span>= webdriver.Chrome()
        <span class="hljs-keyword">browser.get(link)
    </span>    <span class="hljs-keyword">button </span>= <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"submit_button"</span>)
        <span class="hljs-keyword">button.click()
    </span><span class="hljs-symbol">
    finally:</span>
        # закрываем браузер после всех манипуляций
        <span class="hljs-keyword">browser.quit()</span>
    </code></pre>
    <h2 id="-find_elements">Поиск всех необходимых элементов с помощью find_elements</h2>
    <p>Мы уже упоминали, что метод find_element возвращает только первый из всех элементов, которые подходят под условия
    поиска. Иногда возникает ситуация, когда у нас есть несколько одинаковых по сути объектов на странице, например, иконки
    товаров в корзине интернет-магазина. В тесте нам нужно проверить, что отображаются все выбранные для покупки товары. Для
    этого существует метод <code>find_elements</code>, которые в отличие от <code>find_element</code> вернёт список всех найденных элементов по
    заданному условию. Проверив длину списка, мы можем удостовериться, что в корзине отобразилось правильное количество
    товаров. Пример кода (код приведен только для примера, сайта fake-shop.com скорее всего не существует):</p>
    <pre><code class="lang-python"><span class="hljs-meta"># подготовка для теста</span>
    <span class="hljs-meta"># открываем страницу первого товара</span>
    <span class="hljs-meta"># данный сайт не существует, этот код приведен только для примера</span>
    browser.<span class="hljs-keyword">get</span>(<span class="hljs-string">"https://fake-shop.com/book1.html"</span>)
    
    <span class="hljs-meta"># добавляем товар в корзину</span>
    add_button = browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".add"</span>)
    add_button.click()
    
    <span class="hljs-meta"># открываем страницу второго товара</span>
    browser.<span class="hljs-keyword">get</span>(<span class="hljs-string">"https://fake-shop.com/book2.html"</span>)
    
    <span class="hljs-meta"># добавляем товар в корзину</span>
    add_button = browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".add"</span>)
    add_button.click()
    
    <span class="hljs-meta"># тестовый сценарий</span>
    <span class="hljs-meta"># открываем корзину</span>
    browser.<span class="hljs-keyword">get</span>(<span class="hljs-string">"https://fake-shop.com/basket.html"</span>)
    
    <span class="hljs-meta"># ищем все добавленные товары</span>
    goods = browser.find_elements(By.CSS_SELECTOR, <span class="hljs-string">".good"</span>)
    
    <span class="hljs-meta"># проверяем, что количество товаров равно 2</span>
    assert len(goods) == <span class="hljs-number">2</span>
    </code></pre>
    <p><strong>!Важно.</strong>
    Обратите внимание на важную разницу в результатах, которые возвращают методы <code>find_element</code> и <code>find_elements</code>.
    Если первый метод не смог найти элемент на странице, то он вызовет ошибку <code>NoSuchElementException</code>, которая прервёт
    выполнение вашего кода.
    Второй же метод всегда возвращает валидный результат: если ничего не было найдено, то он вернёт пустой
    список и ваша программа перейдет к выполнению следующего шага в коде.</p>
    <h2 id="-1">Уникальность селекторов: часть 1</h2>
    <p>Как отмечалось ранее, идеальный селектор — это тот, который идентифицирует один конкретный элемент на странице.
    Уникальные селекторы повышают стабильность тестирования и снижают зависимость от изменений макета страницы. Разработчики
    часто вносят незначительные изменения в страницы, и мы хотим свести к минимуму необходимость постоянной корректировки
    наших тестов.</p>
    <p>Важно отметить, что эффективные тесты сосредоточены на тестировании небольших отдельных функциональных единиц. Простые
    тесты, предназначенные для определенного сценария, предпочтительнее больших тестов, которые пытаются охватить сразу
    несколько сценариев. Простые тесты позволяют быстро локализовать ошибки и могут выявить несколько проблем одновременно.
    Напротив, большой автотест завершается при первой обнаруженной ошибке.</p>
    <p>Рассмотрим следующий пример: у нас есть форма регистрации, в которой есть обязательные и необязательные поля для
    заполнения. Нужно проверить, что можно успешно зарегистрироваться на сайте.</p>
    <p><strong>Сценарий плохого автотеста:</strong></p>
    <p>1</p>
    <ul>
    <li>Открыть страницу с формой</li>
    <li>Заполнить все поля</li>
    <li>Нажать кнопку &quot;Регистрация&quot;</li>
    <li>Проверить, что есть сообщение об успешной регистрации</li>
    </ul>
    <p><strong>Лучше разбить предыдущий тест на набор более простых автотестов:</strong></p>
    <p>1</p>
    <ul>
    <li>Открыть страницу с формой</li>
    <li>Заполнить только обязательные поля</li>
    <li>Нажать кнопку &quot;Регистрация&quot;</li>
    <li>Проверить, что есть сообщение об успешной регистрации</li>
    </ul>
    <p>2</p>
    <ul>
    <li>Открыть страницу с формой</li>
    <li>Заполнить все обязательные поля</li>
    <li>Заполнить все необязательные поля</li>
    <li>Нажать кнопку &quot;Регистрация&quot;</li>
    <li>Проверить, что есть сообщение об успешной регистрации</li>
    </ul>
    <p>3</p>
    <ul>
    <li>Открыть страницу с формой</li>
    <li>Заполнить только необязательные поля</li>
    <li>Проверить, что кнопка &quot;Регистрация&quot; неактивна</li>
    </ul>
    <h2 id="-2">Уникальность селекторов: часть 2</h2>
    <p>Попробуем реализовать один из автотестов из предыдущего шага. Вам
    дана <a href="http://suninjuly.github.io/registration1.html">страница</a> с формой регистрации. Проверьте, что
    можно зарегистрироваться на сайте, заполнив только обязательные поля, отмеченные символом <code>*</code>: First name, last name,
    email. Текст для полей может быть любым. Успешность регистрации проверяется сравнением ожидаемого текста &quot;
    Congratulations! You have successfully registered!&quot; с текстом на странице, которая открывается после регистрации. Для
    сравнения воспользуемся стандартной конструкцией assert из языка Python.</p>
    <p>Ниже дан шаблон кода, который вам нужно использовать для своего теста. Не забывайте, что селекторы должны быть
    уникальными.</p>
    <pre><code class="lang-python"><span class="hljs-built_in">from</span> selenium import webdriver
    <span class="hljs-built_in">from</span> selenium.webdriver.common.<span class="hljs-keyword">by</span> import By
    import <span class="hljs-built_in">time</span>
    
    <span class="hljs-keyword">try</span>:
        link = <span class="hljs-string">"http://suninjuly.github.io/registration1.html"</span>
        browser = webdriver.Chrome()
        browser.<span class="hljs-built_in">get</span>(link)
    
        <span class="hljs-comment"># Ваш код, который заполняет обязательные поля</span>
        ...
    
        <span class="hljs-comment"># Отправляем заполненную форму</span>
        button = browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"button.btn"</span>)
        button.click()
    
        <span class="hljs-comment"># Проверяем, что смогли зарегистрироваться</span>
        <span class="hljs-comment"># ждем загрузки страницы</span>
        <span class="hljs-built_in">time</span>.sleep(<span class="hljs-number">1</span>)
    
        <span class="hljs-comment"># находим элемент, содержащий текст</span>
        welcome_text_elt = browser.find_element(By.TAG_NAME, <span class="hljs-string">"h1"</span>)
        <span class="hljs-comment"># записываем в переменную welcome_text текст из элемента welcome_text_elt</span>
        welcome_text = welcome_text_elt.<span class="hljs-keyword">text</span>
    
        <span class="hljs-comment"># с помощью assert проверяем, что ожидаемый текст совпадает с текстом на странице сайта</span>
        assert <span class="hljs-string">"Congratulations! You have successfully registered!"</span> == welcome_text
    
    <span class="hljs-keyword">finally</span>:
        <span class="hljs-comment"># ожидание чтобы визуально оценить результаты прохождения скрипта</span>
        <span class="hljs-built_in">time</span>.sleep(<span class="hljs-number">10</span>)
        <span class="hljs-comment"># закрываем браузер после всех манипуляций</span>
        browser.quit()
    </code></pre>
    <p>Углубимся немного в использовании конструкции <code>assert</code> из данного примера. Если результат проверки &quot;Поздравляем! Вы
    успешно зарегистрировались!&quot; == welcome_text вернет значение <code>False</code>, то далее выполнится код <strong>assert False.</strong>
    Он бросит исключение <code>AssertionError</code> и номер строки, в которой произошла ошибка.
    Если код написан правильно и работал ранее, то
    такой результат равносилен тому, что наш автотест обнаружил баг в тестируемом веб-приложении.
    Если результат проверки вернет <code>True</code>, то выполнится выражение <strong>assert True</strong>.
    В этом случае код завершится без ошибок — тест прошел успешно.</p>
    <p>Ознакомьтесь дополнительно с ассертом самостоятельно:
    <a href="https://pythonru.com/uroki/35-instrukcija-assert-dlja-nachinajushhih">Инструкция assert / для начинающих</a></p>
    <h3 id="-">Замечание</h3>
    <p>В этом примере мы использовали метод <code>time.sleep(1)</code>, чтобы дождаться загрузки следующей страницы, прежде чем выполнять
    проверки. Если вы будете запускать код без этого метода, ваш код может внезапно упасть, хотя проходил ранее. Без
    использования такой паузы WebDriver может перейти к поиску тега <code>h1</code> слишком рано, когда новая страница еще не
    загрузилась. В таком случаем будем видеть в терминале ошибку:</p>
    <pre><code><span class="hljs-function"><span class="hljs-title">NoSuchElementException</span></span>... Unable to locate element: {<span class="hljs-string">"method"</span>:<span class="hljs-string">"tag name"</span>,<span class="hljs-string">"selector"</span>:<span class="hljs-string">"h1"</span>}
    </code></pre><p>Метод <code>time.sleep(1)</code> говорит Python подождать 1 секунду, прежде чем выполнять следующую строчку кода.
    Если вы всё равно видите эту ошибку, просто увеличьте количество секунд ожидания.</p>
    <p>Разработка UI автотестов может быть сложной задачей, и одной из самых больших проблем является
    своевременный поиск элементов. Скорость загрузки страниц может сильно различаться из-за изменения скорости сетевого
    подключения и неравномерной загрузки сервера. Еще одним фактором, влияющим на стабильность теста, является асинхронное
    выполнение кода JavaScript. Хотя это может быть незаметно на простых страницах, страницы со многими функциями могут
    сделать время агрузки элементов страницы непредсказуемым.
    Во избежание сбоев тестов, вызванных факторами, не зависящими от нас,
    рекомендуется организовывать тесты таким образом, чтобы смягчить влияние нестабильной скорости интернета или других
    внешних факторов.</p>
    <p>Решать эту проблему с помощью <code>time.sleep()</code> считается плохой практикой, так как заранее трудно указать нужное время
    ожидания. Если выставить слишком большое время ожидания, то тесты будут идти неоправданно долго. Далее мы
    рассмотрим более красивые и эффективные способы решения этой проблемы, а пока будем использовать <code>time.sleep()</code> из-за
    его простоты и наглядности.</p>

    <h1 id="-">Ссылки на дополнительные материалы</h1>
    <h2 id="selenium">Selenium</h2>
    <ul>
    <li><a href="https://habr.com/ru/articles/152653/">Что такое Selenium?</a></li>
    <li><a href="https://habr.com/ru/articles/152971/">Что такое Selenium WebDriver?</a></li>
    <li><a href="https://chromedriver.chromium.org/">ChromeDriver</a></li>
    <li><a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a></li>
    <li><a href="https://selenium-python.com/install-chromedriver-chrome">Установка драйвера chromedriver для Chrome Selenium</a></li>
    <li><a href="https://selenium-python.com/install-geckodriver">Установка драйвера geckodriver для Firefox Selenium</a></li>
    </ul>
    <h2 id="-">Селекторы</h2>
    <h3 id="css">CSS</h3>
    <ul>
    <li><a href="https://www.w3schools.com/cssref/css_selectors.php">CSS Selector Reference</a></li>
    <li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">CSS selectors</a></li>
    <li><a href="https://html5css.ru/cssref/css_selectors.php">CSS Selector Справочник</a></li>
    <li><a href="https://flukeout.github.io/">CSS Diner</a></li>
    <li><a href="https://htmlcheatsheet.com/css/">CSS CheatSheet</a></li>
    <li><a href="https://habr.com/ru/companies/skyeng/articles/588282/">CSS и XPath для QA: чтобы разобраться с локаторами, нужно всего лишь…</a></li>
    </ul>
    <h3 id="xpath">XPATH</h3>
    <ul>
    <li><a href="https://www.w3schools.com/xml/xpath_syntax.asp">XPath Syntax</a></li>
    <li><a href="https://learn.microsoft.com/ru-ru/previous-versions/ms256086(v=vs.120">Примеры XPath</a>?redirectedfrom=MSDN)</li>
    <li><a href="https://msiter.ru/tutorials/xpath/syntax">Синтаксис XPath</a></li>
    <li><a href="https://habr.com/ru/articles/114772/">Примеры xpath-запросов к html</a></li>
    <li><a href="https://testerslittlehelper.wordpress.com/2016/07/10/real-xpath/">Не так страшен XPATH как его незнание</a></li>
    <li><a href="https://habr.com/ru/companies/skyeng/articles/588282/">CSS и XPath для QA: чтобы разобраться с локаторами, нужно всего лишь…</a></li>
    </ul>
    <h2 id="python">Python</h2>
    <ul>
    <li><a href="https://pythonru.com/uroki/35-instrukcija-assert-dlja-nachinajushhih">Инструкция assert / для начинающих</a></li>
    <li><a href="https://realpython.com/python-assert-statement/">Python&#39;s assert: Debug and Test Your Code Like a Pro</a></li>
    </ul>

    <hr>

    <h1 id="-selenium">Основные методы Selenium</h1>
    <h2 id="-checkbox-radiobutton-">Как работать с элементами типа checkbox и radiobutton?</h2>
    <p>Checkbox (чекбокс или флажок) и radiobutton (радиобаттон или переключатель) — часто используемые в формах элементы.
    Основная разница между ними состоит в том, что флажки позволяют выбирать/отключать любой из представленных вариантов, а
    переключатели позволяют выбрать только один из вариантов. Далее мы будем называть эти элементы на англоязычный манер:
    checkbox и radiobutton.</p>
    <p>Так выглядят checkboxes:</p>
    <p><img src="img/check_box.png" width="400" height="200" alt="checkbox"></p>
    <p>А это radiobuttons:</p>
    <p><img src="img/radiobutton.png" width="400" height="200" alt="radiobutton"></p>
    <p>Оба этих элемента создаются при помощи тега <code>input</code> со значением атрибута <code>type</code> равным <code>checkbox</code> или <code>radio</code>
    соответственно. В html-коде страницы вы увидите:</p>
    <pre><code class="lang-html">&lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"checkbox"</span>&gt;
    &lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"radio"</span>&gt;
    </code></pre>
    <p>Если checkbox или radiobutton выбран, то у элемента появится новый атрибут <code>checked</code> без значения. Часто
    атрибут <code>checked</code> уже установлен для одного из элементов по умолчанию.</p>
    <pre><code class="lang-html">&lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"checkbox"</span> checked&gt;
    &lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"radio"</span> checked&gt;
    </code></pre>
    <p>Radiobuttons объединяются в группу, где все элементы имеют одинаковые значения атрибута <code>name</code>, но разные значения
    атрибута <code>value</code>:</p>
    <pre><code class="lang-html">&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">"radio"</span> name=<span class="hljs-string">"language"</span> <span class="hljs-built_in">value</span>=<span class="hljs-string">"python"</span> checked&gt;
    &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">"radio"</span> name=<span class="hljs-string">"language"</span> <span class="hljs-built_in">value</span>=<span class="hljs-string">"selenium"</span>&gt;
    </code></pre>
    <p>Checkboxes могут иметь как одинаковые, так и разные значения атрибута name. Поэтому и те, и другие лучше искать с
    помощью значения <code>id</code> или значения атрибута <code>value</code>. Если вы видите на странице чекбокс с уникальным значением name, то
    можете искать по name.</p>
    <p>Чтобы снять/поставить галочку в элементе типа checkbox или выбрать опцию из группы radiobuttons, надо указать WebDriver
    метод поиска элемента и выполнить для найденного элемента метод <code>click()</code>:</p>
    <pre><code class="lang-python">option1 = browser.find_element(By<span class="hljs-selector-class">.CSS_SELECTOR</span>, <span class="hljs-string">"[value='python']"</span>)
    option1.click()
    </code></pre>
    <p>Также вы можете увидеть тег <code>label</code> рядом с <code>input</code>. Этот тег используется, чтобы сделать кликабельным текст, который
    отображается рядом с флажком. Этот текст заключен внутри тега <code>label</code>. Элемент <code>label</code> связывается с элементом <code>input</code> с
    помощью атрибута <code>for</code>, в котором указывается значение атрибута <code>id</code> для элемента <code>input</code>:</p>
    <pre><code class="lang-html">
    &lt;<span class="hljs-keyword">div</span>&gt;
        &lt;input type=<span class="hljs-string">"radio"</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"python"</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"language"</span> checked&gt;
        &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">"python"</span>&gt;Python&lt;/label&gt;
    &lt;/<span class="hljs-keyword">div</span>&gt;
    &lt;<span class="hljs-keyword">div</span>&gt;
        &lt;input type=<span class="hljs-string">"radio"</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"java"</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"language"</span>&gt;
        &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">"java"</span>&gt;Java&lt;/label&gt;
    &lt;/<span class="hljs-keyword">div</span>&gt;
    </code></pre>
    <p>В этом случае можно также отметить нужный пункт с помощью WebDriver, выполнив метод <code>click()</code> на элементе <code>label</code>.</p>
    <pre><code class="lang-python">option1 = browser.find_element(By<span class="hljs-selector-class">.CSS_SELECTOR</span>, <span class="hljs-string">"[for='java']"</span>)
    option1.click()
    </code></pre>
    <h2 id="-checkboxes-radiobuttons-">Задание: кликаем по checkboxes и radiobuttons (капча для роботов)</h2>
    <p>На данной <a href="https://suninjuly.github.io/math.html">странице</a> мы добавили капчу для роботов, то есть тест, являющийся
    простым для компьютера, но сложным для человека.</p>
    <p>Нужно написать программу, которая выполнит следующие шаги:</p>
    <ol>
    <li>Открыть страницу <a href="https://suninjuly.github.io/math.html">https://suninjuly.github.io/math.html</a>.</li>
    <li>Считать значение для переменной x.</li>
    <li>Посчитать математическую функцию от x (код для этого приведён ниже).</li>
    <li>Ввести ответ в текстовое поле.</li>
    <li>Отметить checkbox &quot;I&#39;m the robot&quot;.</li>
    <li>Выбрать radiobutton &quot;Robots rule!&quot;.</li>
    <li>Нажать на кнопку Submit.</li>
    </ol>
    <p>Для этой задачи вам понадобится использовать атрибут <code>.text</code> для найденного элемента.
    Обратите внимание, что скобки здесь не нужны:</p>
    <pre><code class="lang-python"><span class="hljs-attr">x_element</span> = browser.find_element(By.CSS_SELECTOR, selector_value)
    <span class="hljs-attr">x</span> = x_element.text
    <span class="hljs-attr">y</span> = calc(x)
    </code></pre>
    <p>Атрибут <code>text</code> возвращает текст, который находится между открывающим и закрывающим тегами элемента. Например, <code>text</code> для
    данного элемента <code>&lt;div class=&quot;message&quot;&gt;У вас новое сообщение.&lt;/div&gt;</code> вернёт строку: <code>&quot;У вас новое сообщение&quot;</code>.</p>
    <p>Используйте функцию <code>calc()</code>, которая рассчитает и вернет вам значение функции, которое нужно ввести в текстовое поле.
    Не забудьте добавить этот код в начало вашего скрипта:</p>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> math
    
    
    def calc(x):
        <span class="hljs-keyword">return</span> str(math.log(abs(12 * math.sin(<span class="hljs-keyword">int</span>(x)))))
    </code></pre>
    <p>Если все сделано правильно и достаточно быстро (в этой задаче тоже есть ограничение по времени), вы увидите окно с
    числом.</p>
    <h2 id="-get_attribute">Метод get_attribute</h2>
    <p>Мы уже знаем, как найти нужный элемент на странице и как получить видимый пользователю текст. Для более детальных
    проверок в тесте нам может понадобиться узнать значение атрибута элемента. Атрибуты могут быть стандартными свойствами,
    которые понимает и использует браузер для отображения и вёрстки элементов или для хранения служебной информации,
    например, <code>name</code>, <code>width</code>, <code>height</code>, <code>color</code> и <a href="https://www.w3schools.com/tags/ref_attributes.asp">многие другие</a>.
    Также атрибуты могут быть созданы разработчиками проекта для задания собственных стилей или правил.</p>
    <p>Значение атрибута представляет собой строку. Если значение атрибута отсутствует, то это равносильно значению атрибута
    равному &quot;false&quot;. Давайте еще раз взглянем на страницу <a href="http://suninjuly.github.io/math.html">http://suninjuly.github.io/math.html</a>. На ней есть radiobuttons,
    для которых выбрано значение по умолчанию. В автотесте нам может понадобиться проверить, что для одного из radiobutton
    по умолчанию уже выбрано значение. Для этого мы можем проверить значение атрибута checked у этого элемента. Вот HTML-код
    элемента:</p>
    <pre><code class="lang-html">&lt;input <span class="hljs-keyword">class</span>=<span class="hljs-string">"check-input"</span> type=<span class="hljs-string">"radio"</span> name=<span class="hljs-string">"ruler"</span> id=<span class="hljs-string">"peopleRule"</span> <span class="hljs-keyword">value</span>=<span class="hljs-string">"people"</span> <span class="hljs-keyword">checked</span>&gt;
    </code></pre>
    <p>Найдём этот элемент с помощью WebDriver:</p>
    <pre><code class="lang-python"><span class="hljs-attr">people_radio</span> = browser.find_element(By.ID, <span class="hljs-string">"peopleRule"</span>)
    </code></pre>
    <p>Найдём атрибут &quot;checked&quot; с помощью встроенного метода get_attribute и проверим его значение:</p>
    <pre><code class="lang-python">people_checked = people_radio.get_attribute(<span class="hljs-string">"checked"</span>)
    print(<span class="hljs-string">"value of people radio: "</span>, people_checked)
    <span class="hljs-keyword">assert</span> people_checked <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>, <span class="hljs-string">"People radio is not selected by default"</span>
    </code></pre>
    <p>Т.к. у данного атрибута значение не указано явно, то метод <code>get_attribute</code> вернёт &quot;true&quot;. Возможно, вы заметили, что &quot;
    true&quot; написано с маленькой буквы, — все методы WebDriver взаимодействуют с браузером с помощью JavaScript, в котором
    булевые значения пишутся с маленькой буквы, а не с большой, как в Python.</p>
    <p>Мы можем написать проверку другим способом, сравнив строки:</p>
    <pre><code class="lang-python"><span class="hljs-keyword">assert</span> <span class="hljs-attr">people_checked</span> == <span class="hljs-string">"true"</span>, <span class="hljs-string">"People radio is not selected by default"</span>
    </code></pre>
    <p>Если атрибута нет, то метод get_attribute вернёт значение <code>None</code>. Применим метод <code>get_attribute</code> ко второму radiobutton,
    и убедимся, что атрибут отсутствует.</p>
    <pre><code class="lang-python"><span class="hljs-attr">robots_radio</span> = browser.find_element(By.ID, <span class="hljs-string">"robotsRule"</span>)
    <span class="hljs-attr">robots_checked</span> = robots_radio.get_attribute(<span class="hljs-string">"checked"</span>)
    <span class="hljs-keyword">assert</span> robots_checked is None
    </code></pre>
    <p>Так же мы можем проверять наличие атрибута <code>disabled</code>, который определяет, может ли пользователь взаимодействовать с
    элементом. Например, в предыдущем задании на странице с капчей для роботов JavaScript устанавливает атрибут <code>disabled</code> у
    кнопки <strong>Submit</strong>, когда истекает время, отведенное на решение задачи.</p>
    <pre><code class="lang-html">
    &lt;button <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"submit"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"btn btn-default"</span> disabled&gt;<span class="hljs-type">Submit</span>&lt;/button&gt;
    </code></pre>
    <h2 id="-get_attribute">Задание: поиск сокровища с помощью get_attribute</h2>
    <p>В данной задаче вам нужно с помощью роботов решить ту же математическую задачу, как и в прошлом задании. Но теперь
    значение переменной х спрятано в &quot;сундуке&quot;, точнее, значение хранится в атрибуте valuex у картинки с изображением
    сундука.</p>
    <p>Ваша программа должна:</p>
    <ol>
    <li>Открыть страницу <a href="http://suninjuly.github.io/get_attribute.html">http://suninjuly.github.io/get_attribute.html</a>.</li>
    <li>Найти на ней элемент-картинку, который является изображением сундука с сокровищами.</li>
    <li>Взять у этого элемента значение атрибута valuex, которое является значением x для задачи.</li>
    <li>Посчитать математическую функцию от x (сама функция остаётся неизменной).</li>
    <li>Ввести ответ в текстовое поле.</li>
    <li>Отметить checkbox &quot;I&#39;m the robot&quot;.</li>
    <li>Выбрать radiobutton &quot;Robots rule!&quot;.</li>
    <li>Нажать на кнопку &quot;Submit&quot;.</li>
    </ol>
    <p>Для вычисления значения выражения в п.4 используйте функцию <code>calc(x)</code> из предыдущей задачи.</p>
    <p>Если все сделано правильно и достаточно быстро (в этой задаче тоже есть ограничение по времени), вы увидите окно с
    числом.</p>

    <h1 id="-js-">Работа с файлами, списками и js-скриптами</h1>
    <h2 id="-">Работа со списками</h2>
    <p>На веб-страницах мы также встречаем раскрывающиеся (выпадающие) списки. У таких списков есть несколько важных
    особенностей:</p>
    <p>У каждого элемента списка обычно есть уникальное значение атрибута <code>value</code>
    В списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка
    Визуально списки могут различаться тем, что в одном случае все варианты скрыты в выпадающем
    меню (<a href="http://suninjuly.github.io/selects1.html">http://suninjuly.github.io/selects1.html</a>), а в другом все варианты или их часть
    видны (<a href="http://suninjuly.github.io/selects2.html">http://suninjuly.github.io/selects2.html</a>)</p>
    <p>Но для взаимодействия с любым вариантом списка мы будем использовать одни и те же методы Selenium.</p>
    <p>Посмотрим, как выглядит html для списка:</p>
    <pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"dropdown"</span>&gt;</span>Выберите язык программирования:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dropdown"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"custom-select"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>&gt;</span>--<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
    </code></pre>
    <p>Варианты ответа задаются тегом <code>option</code>, значение <code>value</code> может отсутствовать.
    Можно отмечать варианты с помощью обычного
    метода <code>click()</code>. Для этого сначала нужно применить метод <code>click()</code> для элемента с тегом <code>select</code>,
    чтобы список раскрылся, а затем кликнуть на нужный вариант ответа:</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-keyword">browser </span>= webdriver.Chrome()
    <span class="hljs-keyword">browser.get(link)
    </span>
    <span class="hljs-keyword">browser.find_element(By.TAG_NAME, </span><span class="hljs-string">"select"</span>).click()
    <span class="hljs-keyword">browser.find_element(By.CSS_SELECTOR, </span><span class="hljs-string">"option:nth-child(2)"</span>).click()
    </code></pre>
    <p>Последняя строчка может выглядеть и так:</p>
    <pre><code class="lang-python"><span class="hljs-selector-tag">browser</span><span class="hljs-selector-class">.find_element</span>(<span class="hljs-selector-tag">By</span><span class="hljs-selector-class">.CSS_SELECTOR</span>, "<span class="hljs-selector-attr">[value='1']</span>")<span class="hljs-selector-class">.click</span>()
    </code></pre>
    <p>Это не самый удобный способ, так как нам приходится делать лишний клик для открытия списка.</p>
    <p>Есть более удобный способ, для которого используется специальный класс <code>Select</code> из библиотеки <code>WebDriver</code>.
    Вначале мы должны инициализировать новый объект, передав в него <code>WebElement</code> с тегом <code>select</code>.
    Далее можно найти любой вариант из списка с помощью метода <code>select_by_value(value)</code>:</p>
    <pre><code class="lang-python"><span class="hljs-keyword">from</span> selenium.webdriver.support.ui import <span class="hljs-keyword">Select</span>
    
    <span class="hljs-keyword">select</span> = <span class="hljs-keyword">Select</span>(browser.find_element(<span class="hljs-keyword">By</span>.TAG_NAME, <span class="hljs-string">"select"</span>))
    <span class="hljs-keyword">select</span>.select_by_value(<span class="hljs-string">"1"</span>)  <span class="hljs-meta"># ищем элемент с текстом "Python"</span>
    </code></pre>
    <p>Можно использовать еще два метода: <code>select.select_by_visible_text(&quot;text&quot;)</code> и <code>select.select_by_index(index)</code>.
    Первый способ
    ищет элемент по видимому тексту, например, <code>select.select_by_visible_text(&quot;Python&quot;)</code> найдёт &quot;Python&quot; для нашего примера.</p>
    <p>Второй способ ищет элемент по его индексу или порядковому номеру. Индексация начинается с нуля. Для того чтобы найти
    элемент с текстом &quot;Python&quot;, нужно использовать <code>select.select_by_index(1)</code>, так как опция с индексом 0 в данном примере
    имеет значение по умолчанию равное &quot;--&quot;.</p>
    <h2 id="-">Задание: работа с выпадающим списком</h2>
    <p>Напишите код, который реализует следующий сценарий:</p>
    <ol>
    <li>Открыть страницу <a href="https://suninjuly.github.io/selects1.html">https://suninjuly.github.io/selects1.html</a></li>
    <li>Посчитать сумму заданных чисел</li>
    <li>Выбрать в выпадающем списке значение равное расчитанной сумме</li>
    <li>Нажать кнопку &quot;Submit&quot;</li>
    </ol>
    <p>Когда ваш код заработает, попробуйте запустить его на странице <a href="https://suninjuly.github.io/selects2.html">https://suninjuly.github.io/selects2.html</a>.
    Ваш код и для нее тоже должен пройти успешно.</p>
    <h2 id="-execute_script">Метод execute_script</h2>
    <p>Вот еще один мощный и очень полезный метод, хотя он требует хотя бы некоторых базовых знаний JavaScript. Метод
    <code>execute_script</code> позволяет выполнять код JavaScript в работающем браузере как часть скрипта автотестирования. Это может
    показаться ненужным, поскольку автотесты обычно взаимодействуют с интерфейсом сайта, как обычный пользователь, нажимая
    кнопки, выбирая пункты меню и вводя текст в поля. Однако бывают ситуации, когда выполнение JavaScript может быть
    чрезвычайно полезным.</p>
    <p>Стандартные методы Selenium могут оказаться недостаточными для всех сценариев веб-приложений. Веб-сайты сильно
    различаются по назначению: от простых блогов до сложных финансовых или графических приложений. Разработчики имеют доступ
    к огромному количеству библиотек для решения бизнес-сценариев, включая нестандартные текстовые редакторы, уникальные
    меню и оригинальные видеоплееры на веб-страницах. В некоторых случаях тестировщикам может потребоваться написать
    сценарий JavaScript для взаимодействия с, казалось бы, обычными кнопками. Когда это происходит, важно обратиться за
    помощью к фронтэнд-разработчикам и попросить пример желаемого сценария. Тестировщики могут протестировать
    скрипт, выполнив его в консоли браузера перед добавлением в автотест с помощью метода <code>execute_script(javascript_code)</code>.</p>
    <p>Давайте попробуем вызвать alert в браузере с помощью WebDriver. Пример сценария:</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    
    <span class="hljs-keyword">browser </span>= webdriver.Chrome()
    <span class="hljs-keyword">browser.execute_script("alert('Robots </span>at work<span class="hljs-string">');")</span>
    </code></pre>
    <p>Обратите внимание, что исполняемый JavaScript нужно заключать в кавычки (двойные или одинарные). Если внутри скрипта вам
    также понадобится использовать кавычки, а для выделения скрипта вы уже используете двойные кавычки, то в скрипте следует
    поставить одинарные:</p>
    <pre><code class="lang-python"><span class="hljs-selector-tag">browser</span><span class="hljs-selector-class">.execute_script</span>(<span class="hljs-string">"document.title='Script executing';"</span>)
    </code></pre>
    <p>Такой формат записи тоже будет работать:</p>
    <pre><code class="lang-python">browser.execute_script(<span class="hljs-symbol">'document.title</span>=<span class="hljs-string">"Script executing"</span>;')
    </code></pre>
    <p>Можно с помощью этого метода выполнить сразу несколько инструкций, перечислив их через точку с запятой. Изменим сначала
    заголовок страницы, а затем вызовем alert:</p>
    <pre><code class="lang-python">browser.execute_script("document.title=<span class="hljs-string">'Script executing'</span>;alert(<span class="hljs-string">'Robots at work'</span>);")
    </code></pre>
    <h2 id="-execute_script">Пример задачи для execute_script</h2>
    <p>Давайте теперь рассмотрим реальную ситуацию, когда пользователь должен кликнуть на элемент, который внезапно оказывается
    перекрыт другим элементом на странице.</p>
    <p>Для клика в WebDriver мы используем метод <code>click()</code>. Если элемент оказывается перекрыт другим элементом, то наша
    программа вызовет следующую ошибку:</p>
    <pre><code>selenium<span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.exceptions</span><span class="hljs-selector-class">.WebDriverException</span>: Message: unknown
    error: Element &lt; <span class="hljs-selector-tag">button</span>
    type = <span class="hljs-string">"submit"</span>
    class =<span class="hljs-string">"btn btn-default"</span> style=<span class="hljs-string">"margin-bottom: 1000px;"</span>&gt;
    ...
    &lt; /<span class="hljs-selector-tag">button</span> &gt; is not clickable at point (<span class="hljs-number">87</span>, <span class="hljs-number">420</span>).
    Other element would receive the click: &lt;p&gt; ... &lt; / <span class="hljs-selector-tag">p</span> &gt;
    </code></pre><p>Из описания ошибки можно понять, что указанный нами элемент нельзя кликнуть в данной точке, т.к. клик произойдёт на
    другом элементе с тегом <code>&lt;p&gt;</code>.</p>
    <p>Чтобы увидеть пример данной ошибки, запустите следующий скрипт:</p>
    <pre><code class="lang-python">from selenium import webdriver
    from selenium<span class="hljs-selector-class">.webdriver</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.by</span> import By
    
    browser = webdriver.Chrome()
    link = <span class="hljs-string">"https://SunInJuly.github.io/execute_script.html"</span>
    browser.get(link)
    <span class="hljs-selector-tag">button</span> = browser.find_element(By<span class="hljs-selector-class">.TAG_NAME</span>, <span class="hljs-string">"button"</span>)
    <span class="hljs-selector-tag">button</span>.click()
    </code></pre>
    <p>Теперь вы можете сами посмотреть на эту <a href="https://suninjuly.github.io/execute_script.html">страницу</a> и увидеть, что
    огромный футер действительно перекрывает нужную нам кнопку.
    Футером (<code>footer</code>) называется нижний блок, который обычно одинаков для всех страниц сайта. Чтобы понять, как
    решить эту проблему, нужно разобраться, как работает метод <code>click()</code>.</p>
    <p>В первую очередь WebDriver проверит, что ширина и высота элемента больше 0, чтобы по нему можно было кликнуть.</p>
    <p>Затем, если элемент находится за границей окна браузера, WebDriver автоматически проскроллит страницу, чтобы элемент
    попал в область видимости, то есть не находился за границей экрана. Но это не гарантирует того, что элемент не перекрыт
    другим элементом, который тоже находится в области видимости.</p>
    <p>А в какую точку элемента будет происходить клик? Selenium рассчитывает координаты центра элемента и производит клик в
    вычисленную точку. Это тоже приведёт к ошибке, если часть элемента всё-таки видна, но элемент перекрыт больше чем на
    половину своей высоты или ширины.</p>
    <p>Если мы столкнулись с такой ситуацией, мы можем заставить браузер дополнительно проскроллить нужный элемент, чтобы он
    точно стал видимым.
    Делается это с помощью следующего скрипта:</p>
    <pre><code class="lang-python">"<span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">arguments</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.scrollIntoView</span>(<span class="hljs-selector-tag">true</span>);"
    </code></pre>
    <p>Мы дополнительно передали в метод <code>scrollIntoView</code> аргумент <code>true</code>,
    чтобы элемент после скролла оказался в области видимости.</p>
    <p>Другие возможные параметры метода можно посмотреть
    здесь: <a href="https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView">https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView</a></p>
    <p>В итоге, чтобы кликнуть на перекрытую кнопку, нам нужно выполнить следующие команды в коде:</p>
    <pre><code class="lang-python"><span class="hljs-selector-tag">button</span> = browser.find_element(By<span class="hljs-selector-class">.TAG_NAME</span>, <span class="hljs-string">"button"</span>)
    browser.execute_script(<span class="hljs-string">"return arguments[0].scrollIntoView(true);"</span>, button)
    <span class="hljs-selector-tag">button</span>.click()
    </code></pre>
    <p>В метод <code>execute_script</code> мы передали текст js-скрипта и найденный элемент <code>button</code>, к которому нужно будет проскроллить
    страницу. После выполнения кода элемент <code>button</code> должен оказаться в верхней части страницы. Подробнее о методе
    см <a href="https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView">https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView</a> .</p>
    <p>Также можно проскроллить всю страницу целиком на строго заданное количество пикселей. Эта команда проскроллит страницу
    на 100 пикселей вниз:</p>
    <pre><code class="lang-python"><span class="hljs-selector-tag">browser</span><span class="hljs-selector-class">.execute_script</span>("<span class="hljs-selector-tag">window</span><span class="hljs-selector-class">.scrollBy</span>(0, 100);")
    </code></pre>
    <p>Код на JavaScript:</p>
    <pre><code class="lang-javascript">// javascript
    <span class="hljs-attribute">button</span> = document.getElementsByTagName(<span class="hljs-string">"button"</span>)[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
    button.scrollIntoView(true)<span class="hljs-comment">;</span>
    </code></pre>
    <p>Можете попробовать исполнить его в консоли браузера на странице <a href="http://suninjuly.github.io/execute_script.html">http://suninjuly.github.io/execute_script.html</a>. Для
    этого откройте инструменты разработчика в браузере, перейдите на вкладку консоль (<code>console</code>), скопируйте туда этот код и
    нажмите Enter. Таким образом можно протестировать кусочки js кода прежде чем внедрять его в свои тесты на python.</p>
    <p>Обратите внимание, что в коде в WebDriver нужно использовать ключевое слово <code>return</code>.
    Также его нужно будет использовать,
    когда вы захотите получить какие-то данные после выполнения скрипта. При этом при тестировании скрипта в консоли
    браузера слово return использовать не надо.</p>
    <h1 id="-execute_script">Задание на execute_script</h1>
    <p>Вам потребуется написать код, чтобы:</p>
    <ol>
    <li>Открыть страницу <a href="https://SunInJuly.github.io/execute_script.html">https://SunInJuly.github.io/execute_script.html</a>.</li>
    <li>Считать значение для переменной x.</li>
    <li>Посчитать математическую функцию от x.</li>
    <li>Проскроллить страницу вниз.</li>
    <li>Ввести ответ в текстовое поле.</li>
    <li>Выбрать checkbox &quot;I&#39;m the robot&quot;.</li>
    <li>Переключить radiobutton &quot;Robots rule!&quot;.</li>
    <li>Нажать на кнопку &quot;Submit&quot;.</li>
    </ol>
    <p>Для этой задачи вам понадобится использовать метод <code>execute_script</code>, чтобы сделать прокрутку в область видимости
    элементов, перекрытых футером.</p>
    <h2 id="-">Загрузка файлов</h2>
    <p>Если нам понадобится загрузить файл на веб-странице, мы можем использовать уже знакомый нам метод <code>send_keys</code>. Только
    теперь нам нужно в качестве аргумента передать путь к нужному файлу на диске вместо простого текста.</p>
    <p>Чтобы указать путь к файлу, можно использовать стандартный модуль Python для работы с операционной системой — os. В этом
    случае ваш код не будет зависеть от операционной системы, которую вы используете. Добавление файла будет работать и на
    Windows, и на Linux, и даже на MaсOS.</p>
    <p>Пример кода, который позволяет указать путь к файлу <code>file.txt</code>, находящемуся в той же папке, что и скрипт, который вы
    запускаете:</p>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> <span class="hljs-built_in">os</span>
    
    current_dir = <span class="hljs-built_in">os</span>.path.abspath(<span class="hljs-built_in">os</span>.path.dirname(__file__))  # получаем путь к директории текущего исполняемого файла 
    file_path = <span class="hljs-built_in">os</span>.path.join(current_dir, <span class="hljs-string">'file.txt'</span>)  # добавляем к этому пути имя файла 
    element.send_keys(file_path)
    </code></pre>
    <p>Попробуйте добавить в файл отдельно команды <code>print(os.path.abspath(__file__))</code>
    и <code>print(os.path.abspath(os.path.dirname(__file__)))</code> и посмотрите на разницу.
    Подробнее о методах модуля os можете почитать самостоятельно в
    документации: <a href="https://docs.python.org/3/library/os.path.html">https://docs.python.org/3/library/os.path.html</a>. Обратите внимание, что это будет работать только при
    запуске кода из файла, в интерпретаторе не сработает.</p>
    <h1 id="-">Задание: загрузка файла</h1>
    <p>В этом задании в форме регистрации требуется загрузить текстовый файл.</p>
    <p>Напишите скрипт, который будет выполнять следующий сценарий:</p>
    <ol>
    <li>Открыть страницу <a href="http://suninjuly.github.io/file_input.html">http://suninjuly.github.io/file_input.html</a></li>
    <li>Заполнить текстовые поля: имя, фамилия, email</li>
    <li>Загрузить файл. Файл должен иметь расширение .txt и может быть пустым</li>
    <li>Нажать кнопку &quot;Submit&quot;</li>
    </ol>

    <h1 id="-">Работа с окнами</h1>
    <h2 id="alerts">Alerts</h2>
    <p>Мы уже сталкивались с алертами, когда получали числовые ответы в задачах. Кроме того, мы узнали, что можно
    создавать алерты с помощью JavaScript:</p>
    <pre><code class="lang-javascript"><span class="hljs-selector-tag">alert</span>(<span class="hljs-string">'Hello!'</span>);
    </code></pre>
    <p><img src="img/alert.png" width="400" height="150" alt="alert"></p>
    <p>Давайте теперь рассмотрим сценарий, в котором тестовый сценарий требует не только получения содержимого предупреждения,
    но и нажатия кнопки OK, чтобы закрыть его. Оповещение — это модальное окно, что означает, что пользователь не может
    взаимодействовать с интерфейсом, пока оповещение не будет закрыто. Чтобы отклонить предупреждение, тестер должен сначала
    переключиться в окно предупреждения, а затем использовать команду <code>accept()</code>.</p>
    <pre><code class="lang-python">alert = browser<span class="hljs-selector-class">.switch_to</span><span class="hljs-selector-class">.alert</span>
    alert.accept()
    </code></pre>
    <p>Чтобы получить текст из alert, используйте свойство text объекта alert:</p>
    <pre><code class="lang-python"><span class="hljs-attr">alert</span> = browser.switch_to.alert
    <span class="hljs-attr">alert_text</span> = alert.text
    </code></pre>
    <p>Другой тип модального окна, который предоставляет пользователю возможность либо принять, либо отклонить сообщение,
    называется диалоговым окном <code>confirm</code>. Для переключения в окно <code>confirm</code> можно использовать ту же команду, что и
    для <code>alert</code>:</p>
    <pre><code class="lang-python">confirm = browser<span class="hljs-selector-class">.switch_to</span><span class="hljs-selector-class">.alert</span>
    confirm.accept()
    </code></pre>
    <p><img src="img/confirm.png" width="400" height="150" alt="confirm"></p>
    <p>Для confirm-окон можно использовать следующий метод для отказа:</p>
    <pre><code class="lang-python"><span class="hljs-selector-tag">confirm</span><span class="hljs-selector-class">.dismiss</span>()
    </code></pre>
    <p>То же самое, что и при нажатии пользователем кнопки &quot;Отмена&quot;.
    Третий вариант модального окна — <code>prompt</code> — имеет дополнительное поле для ввода текста. Чтобы ввести текст, используйте
    метод <code>send_keys()</code>:</p>
    <pre><code class="lang-python"><span class="hljs-built_in">prompt</span> = browser.switch_to.alert
    <span class="hljs-built_in">prompt</span>.send_keys(<span class="hljs-string">"My answer"</span>)
    <span class="hljs-built_in">prompt</span>.accept()
    </code></pre>
    <p><img src="img/prompt.png" width="400" height="150" alt="prompt"></p>
    <h2 id="-alert">Задание: принимаем alert</h2>
    <p>В этой задаче вам нужно написать программу, которая будет выполнять следующий сценарий:</p>
    <ol>
    <li>Открыть страницу <a href="http://suninjuly.github.io/alert_accept.html">http://suninjuly.github.io/alert_accept.html</a></li>
    <li>Нажать на кнопку</li>
    <li>Принять confirm</li>
    <li>На новой странице решить капчу для роботов, чтобы получить число с ответом</li>
    </ol>
    <p>Если все сделано правильно и достаточно быстро (в этой задаче тоже есть ограничение по времени), вы увидите окно с
    числом.</p>
    <h2 id="-">Переход на новую вкладку браузера</h2>
    <p>При работе с веб-приложениями часто встречаются ссылки, которые открываются в новой вкладке браузера. Однако WebDriver
    может одновременно взаимодействовать только с одной вкладкой браузера. Когда ссылка открывается в новой вкладке,
    WebDriver продолжит работу на старой вкладке. Чтобы переключиться на только что открытую вкладку, нам нужно явно
    указать, с какой вкладкой мы хотим работать. Этого можно добиться с помощью команды <code>switch_to.window</code>:</p>
    <pre><code class="lang-python">browser<span class="hljs-selector-class">.switch_to</span><span class="hljs-selector-class">.window</span>(window_name)
    </code></pre>
    <p>Чтобы определить имя вновь открытой вкладки, можно использовать метод <code>window_handles</code>, который возвращает массив имен
    всех вкладок. Как только мы подтвердим, что две вкладки открыты, мы можем переключиться на вторую вкладку, используя
    соответствующую индексацию:</p>
    <pre><code class="lang-python"><span class="hljs-keyword">new</span><span class="hljs-type">_window</span> = browser.window_handles[<span class="hljs-number">1</span>]
    </code></pre>
    <p>Также мы можем запомнить имя текущей вкладки, чтобы иметь возможность потом к ней вернуться:</p>
    <pre><code class="lang-python"><span class="hljs-attr">first_window</span> = browser.window_handles[<span class="hljs-number">0</span>]
    </code></pre>
    <p>После переключения на новую вкладку поиск и взаимодействие с элементами будут происходить уже на новой странице.</p>
    <h2 id="-">Задание: переход на новую вкладку</h2>
    <p>В этом задании после нажатия кнопки страница откроется в новой вкладке, нужно переключить WebDriver на новую вкладку и
    решить в ней задачу.</p>
    <p>Сценарий для реализации выглядит так:</p>
    <ol>
    <li>Открыть страницу <a href="http://suninjuly.github.io/redirect_accept.html">http://suninjuly.github.io/redirect_accept.html</a></li>
    <li>Нажать на кнопку</li>
    <li>Переключиться на новую вкладку</li>
    <li>Пройти капчу для робота и получить число-ответ</li>
    </ol>
    <p>Если все сделано правильно и достаточно быстро (в этой задаче тоже есть ограничение по времени), вы увидите окно с
    числом.</p>

    <h1 id="-">Настройка ожиданий</h1>
    <p>Разработчики усердно работали над созданием красивых и быстро загружаемых веб-страниц с плавными переходами между ними.
    Это было достигнуто за счет использования подхода одностраничных приложений (SPA), когда сайт имеет только
    одну страницу, а ее содержимое динамически обновляется с помощью JavaScript, который обменивается информацией с сервером
    через REST API.</p>
    <p>Хотя этот подход обеспечивает удобство работы с пользователем, он создает проблемы для тех, кто создает UI автотесты.
    Непредсказуемое появление или исчезновение элементов на странице, непредсказуемое время рендеринга и
    изменение текста в кнопках или сообщениях — вот некоторые особенности приложений SPA, которые необходимо учитывать при
    автотестировании. Это один из самых сложных и запутанных аспектов разработки автотестов в Selenium (и других фреймворках
    для E-2-E (end-to-end) тестов).</p>
    <p>Мы рассмотрим эти распространенные проблемы и узнаем, как их преодолеть.</p>
    <h2 id="-get-find_element-">Работа методов <code>get()</code> и <code>find_element()</code></h2>
    <p>Резберем тест, проверяющий работу кнопки.</p>
    <p>Тестовый сценарий:</p>
    <ol>
    <li>Открыть страницу <a href="http://suninjuly.github.io/wait1.html">http://suninjuly.github.io/wait1.html</a></li>
    <li>Нажать на кнопку &quot;Verify&quot;</li>
    <li>Проверить, что появилась надпись &quot;Verification was successful!&quot;</li>
    </ol>
    <p>Страница открывается с помощью метода <code>.get()</code>, после чего поиск нужной кнопки осуществляется с помощью одного из
    методов <code>.find_element_by_()</code>.
    Затем для нажатия на кнопку используется метод <code>.click()</code>. После этого идентифицируется новый элемент с
    определенным текстом, и его текст проверяется на соответствие ожидаемому тексту.</p>
    <p>Вот как выглядит код автотеста:</p>
    <pre><code class="lang-python">from selenium import webdriver
    from selenium<span class="hljs-selector-class">.webdriver</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.by</span> import By
    
    browser = webdriver.Chrome()
    browser.get(<span class="hljs-string">"http://suninjuly.github.io/wait1.html"</span>)
    
    <span class="hljs-selector-tag">button</span> = browser.find_element(By<span class="hljs-selector-class">.ID</span>, <span class="hljs-string">"verify"</span>)
    <span class="hljs-selector-tag">button</span>.click()
    message = browser.find_element(By<span class="hljs-selector-class">.ID</span>, <span class="hljs-string">"verify_message"</span>)
    
    assert <span class="hljs-string">"successful"</span> <span class="hljs-keyword">in</span> message.text
    </code></pre>
    <p>Сначала попытайтесь выполнить тест в ручную, а затем перейдите к автотесту. При выполнении ручного теста вы успешно
    завершите тест, но в случае автотеста он завершится ошибкой и сгенерирует сообщение <code>NoSuchElementException</code>
    для элемента с id=&quot;verify&quot;. В чем может быть причина этой ошибки?</p>
    <p>В Python команды выполняются синхронно, то есть выполняются строго последовательно. Это подразумевает, что пока команда
    <code>get</code> не будет выполнена, поиск кнопки не начнется. Точно так же, пока кнопка не найдена, на нее нельзя нажать и так
    далее.</p>
    <p>Однако надежность теста не гарантируется, если веб-страница использует JavaScript (что весьма вероятно на современных
    веб-сайтах). Метод <code>get</code> ожидает, пока браузер подтвердит загрузку страницы, после чего тест переходит к поиску кнопки.
    Однако, если страница является интерактивной, браузер может считать страницу загруженной, в то время как скрипты,
    загруженные браузером, продолжают выполняться. Скрипт может управлять внешним видом кнопки на странице и отображать ее с
    задержкой, придавая ей плавный вид. В этом случае наш тест завершится ошибкой <code>NoSuchElementException</code>,
    так как элемент с id=&quot;verify&quot; не отображается на странице при выполнении команды
    <code>button = browser.find_element(By.ID, &quot;verify&quot;)</code>.
    Эта страница имеет 1-секундную задержку перед появлением кнопки,
    и метод <code>find_element()</code> попытается найти элемент только один раз, в случае неудачи завершив проверку.</p>
    <h2 id="-time-sleep-">Фикс с помощью time.sleep()</h2>
    <p>Поскольку мы знаем о задержке появления кнопки, мы можем ввести паузу перед поиском элемента. Поскольку мы использовали
    библиотеку <code>time</code> ранее, мы можем использовать ее и здесь.</p>
    <pre><code class="lang-python">from selenium import webdriver
    from selenium<span class="hljs-selector-class">.webdriver</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.by</span> import By
    import <span class="hljs-selector-tag">time</span>
    
    browser = webdriver.Chrome()
    browser.get(<span class="hljs-string">"http://suninjuly.github.io/wait1.html"</span>)
    
    <span class="hljs-selector-tag">time</span>.sleep(<span class="hljs-number">1</span>)
    <span class="hljs-selector-tag">button</span> = browser.find_element(By<span class="hljs-selector-class">.ID</span>, <span class="hljs-string">"verify"</span>)
    <span class="hljs-selector-tag">button</span>.click()
    message = browser.find_element(By<span class="hljs-selector-class">.ID</span>, <span class="hljs-string">"verify_message"</span>)
    
    assert <span class="hljs-string">"successful"</span> <span class="hljs-keyword">in</span> message.text
    </code></pre>
    <p>Текущее решение добавления фиксированной задержки перед поиском элемента может быть неэффективным при обработке
    различных сценариев. Например, если элемент с сообщением тоже появляется с задержкой, или время задержки меняется при
    появлении кнопки. Точно так же скорость Интернета на разных машинах может вызывать различия во временном интервале,
    когда появляется кнопка. Хотя добавление задержки перед каждым действием может показаться решением, это непрактично, так
    как может излишне увеличить время выполнения теста. С увеличением количества тестов эта проблема будет только
    усугубляться.</p>
    <h2 id="-selenium-waits-implicit-waits-">Фикс с помощью Selenium Waits (Implicit Waits)</h2>
    <p>Решение с time.sleep() плохое: оно не масштабируемое и трудно поддерживаемое.</p>
    <p>Лучший способ справиться с ложными ошибками теста, вызванными асинхронным выполнением сценариев или задержками
    сервера, — реализовать решение, которое ожидает появления определенного элемента на странице в течение заданного периода
    времени (например, 5 секунд). Мы можем проверять наличие элемента каждые 500 миллисекунд, и как только элемент будет
    найден, мы можем сразу перейти к следующему шагу теста. Таким образом, мы можем получить желаемый элемент как можно
    скорее в лучшем случае или в течение 5 секунд в худшем случае.</p>
    <p>Selenium WebDriver предоставляет особый подход к обработке этого ожидания, который позволяет нам установить ожидание во
    время инициализации драйвера и применить его ко всем тестам. Это ожидание называется неявным ожиданием, поскольку нам не
    нужно явно указывать его каждый раз, когда мы ищем элементы. Он будет автоматически применяться к каждой последующей
    команде.</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-keyword">browser </span>= webdriver.Chrome()
    # говорим WebDriver искать каждый элемент в течение <span class="hljs-number">5</span> секунд
    <span class="hljs-keyword">browser.implicitly_wait(5)
    </span>
    <span class="hljs-keyword">browser.get("http://suninjuly.github.io/wait1.html")
    </span>
    <span class="hljs-keyword">button </span>= <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"verify"</span>)
    <span class="hljs-keyword">button.click()
    </span><span class="hljs-symbol">message</span> = <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"verify_message"</span>)
    
    <span class="hljs-symbol">assert</span> <span class="hljs-string">"successful"</span> in message<span class="hljs-meta">.text</span>
    </code></pre>
    <p>С неявным ожиданием, установленным во время инициализации драйвера, мы можем гарантировать, что наши тесты останутся
    стабильными даже при незначительных задержках на веб-сайте. Для каждого экземпляра команды <code>find_element</code> WebDriver
    будет ждать до 5 секунд, пока элемент появится на странице, прежде чем вызвать исключение <code>NoSuchElementException</code>.</p>
    <h1 id="-explicit-waits-webdriverwait-expected_conditions-">Фикс с помощью Explicit Waits (WebDriverWait и expected_conditions)</h1>
    <p>На предыдущем шаге мы решили проблему ожидания загрузки элементов на странице. Однако метод <code>find_element</code> только
    проверяет наличие элемента на странице. Между тем, элемент может иметь другие атрибуты, которые могут быть важны для
    наших тестов.</p>
    <p>Рассмотрим пример с кнопкой, которая отправляет данные:</p>
    <ul>
    <li>Кнопка может быть неактивной, то есть её нельзя кликнуть;</li>
    <li>Кнопка может содержать текст, который меняется в зависимости от действий пользователя. Например, текст &quot;Отправить&quot;
    после нажатия кнопки поменяется на &quot;Отправлено&quot;;</li>
    <li>Кнопка может быть перекрыта каким-то другим элементом или быть невидимой.</li>
    </ul>
    <p>Если кнопка неактивна в тот момент, когда мы хотим нажать на нее во время теста, WebDriver все равно будет имитировать
    действие нажатия на кнопку, но данные отправляться не будут.</p>
    <p>Попробуем запустить следующий тест:</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-keyword">browser </span>= webdriver.Chrome()
    # говорим WebDriver ждать все элементы в течение <span class="hljs-number">5</span> секунд
    <span class="hljs-keyword">browser.implicitly_wait(5)
    </span>
    <span class="hljs-keyword">browser.get("http://suninjuly.github.io/wait2.html")
    </span>
    <span class="hljs-keyword">button </span>= <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"verify"</span>)
    <span class="hljs-keyword">button.click()
    </span><span class="hljs-symbol">message</span> = <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"verify_message"</span>)
    
    <span class="hljs-symbol">assert</span> <span class="hljs-string">"successful"</span> in message<span class="hljs-meta">.text</span>
    </code></pre>
    <p>Мы видим, что WebDriver смог найти кнопку с id=&quot;verify&quot; и кликнуть по ней, но тест упал на поиске элемента &quot;
    verify_message&quot; с итоговым сообщением:</p>
    <p><code>no such element: Unable to locate element: {&quot;method&quot;:&quot;id&quot;,&quot;selector&quot;:&quot;verify_message&quot;}</code></p>
    <p>WebDriver быстро нашел и нажал кнопку, хотя она еще не была активна, что привело к провалу теста. Это распространенная
    проблема на реальных сайтах, так как кнопки могут быть не активны при загрузке. На странице специально установлена
    1-секундная задержка после ее загрузки перед активацией кнопки.</p>
    <p>Для обеспечения надежности теста необходимо не только найти кнопку на странице, но и дождаться, когда кнопка станет
    кликабельной. Явные ожидания используются в Selenium WebDriver для установки определенных ожиданий для элемента.
    Реализация явных ожиданий предполагает использование инструментов WebDriverWait и <code>expected_conditions</code>.
    Давайте улучшим наш тест:</p>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.support.ui </span><span class="hljs-meta">import</span> WebDriverWait
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.support </span><span class="hljs-meta">import</span> expected_conditions as EC
    <span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium </span><span class="hljs-meta">import</span> webdriver
    
    <span class="hljs-keyword">browser </span>= webdriver.Chrome()
    
    <span class="hljs-keyword">browser.get("http://suninjuly.github.io/wait2.html")
    </span>
    # говорим <span class="hljs-keyword">Selenium </span>проверять в течение <span class="hljs-number">5</span> секунд, пока кнопка не станет кликабельной
    <span class="hljs-keyword">button </span>= WebDriverWait(<span class="hljs-keyword">browser, </span><span class="hljs-number">5</span>).until(
        EC.element_to_be_clickable((<span class="hljs-keyword">By.ID, </span><span class="hljs-string">"verify"</span>)))
    <span class="hljs-keyword">button.click()
    </span><span class="hljs-symbol">message</span> = <span class="hljs-keyword">browser.find_element(By.ID, </span><span class="hljs-string">"verify_message"</span>)
    
    <span class="hljs-symbol">assert</span> <span class="hljs-string">"successful"</span> in message<span class="hljs-meta">.text</span>
    </code></pre>
    <p><code>element_to_be_clickable</code> вернет элемент, когда он станет кликабельным, или вернет <code>False</code> в ином случае.</p>
    <p>Обратите внимание, что в объекте WebDriverWait используется функция <code>until</code>, которая принимает условие ожидания,
    элемент и значение, которое будет использоваться для поиска элемента.
    Модуль <code>expect_conditions</code> имеет несколько
    <a href="https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html">других условий</a>,
    которые можно использовать для определения требуемых ожиданий.</p>
    <p>Если мы захотим проверять, что кнопка становится неактивной после отправки данных, то можно задать негативное правило с
    помощью метода <code>until_not</code>:</p>
    <pre><code class="lang-python"># говорим <span class="hljs-keyword">Selenium </span>проверять в течение <span class="hljs-number">5</span> секунд пока кнопка станет неактивной
    <span class="hljs-keyword">button </span>= WebDriverWait(<span class="hljs-keyword">browser, </span><span class="hljs-number">5</span>).until_not(
        EC.element_to_be_clickable((<span class="hljs-keyword">By.ID, </span><span class="hljs-string">"verify"</span>)))
    </code></pre>
    <h2 id="-">Задание: ждем нужный текст на странице</h2>
    <p>Попробуем теперь написать программу, которая будет бронировать нам дом для отдыха по строго заданной цене. Более высокая
    цена нас не устраивает, а по более низкой цене объект успеет забронировать кто-то другой.</p>
    <p>В этой задаче вам нужно написать программу, которая будет выполнять следующий сценарий:</p>
    <ol>
    <li>Открыть страницу <a href="http://suninjuly.github.io/explicit_wait2.html">http://suninjuly.github.io/explicit_wait2.html</a></li>
    <li>Дождаться, когда цена дома уменьшится до $100 (ожидание нужно установить не меньше 12 секунд)</li>
    <li>Нажать на кнопку &quot;Book&quot;</li>
    <li>Решить уже известную нам математическую задачу (используйте ранее написанный код) и отправить решение</li>
    </ol>
    <p>Чтобы определить момент, когда цена аренды уменьшится до $100, используйте метод <code>text_to_be_present_in_element</code> из
    библиотеки <code>expected_conditions</code>.</p>
    <p>Если все сделано правильно и быстро, то вы увидите окно с числом.</p>

    <h1 id="-">Ссылки на дополнительные материалы</h1>
    <h2 id="python">Python</h2>
    <ul>
    <li><a href="https://docs.python.org/3/library/os.path.html">os.path</a></li>
    <li><a href="https://docs.python.org/3/library/pathlib.html">pathlib</a></li>
    <li><a href="https://habr.com/ru/articles/453862/">Почему вам следует использовать pathlib</a></li>
    <li><a href="https://python-scripts.com/pathlib">Pathlib — манипуляция путями, создание и удаление папок и файлов</a></li>
    </ul>
    <h2 id="web">Web</h2>
    <ul>
    <li><a href="https://en.wikipedia.org/wiki/Single-page_application">SPA</a></li>
    <li><a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5">Одностраничное приложение</a></li>
    <li><a href="http://barancev.github.io/page-loading-complete/">...что означает &quot;окончание загрузки страницы&quot;?</a></li>
    <li><a href="https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html">expected_conditions</a></li>
    <li><a href="https://www.selenium.dev/documentation/webdriver/waits/">Waits</a></li>
    <li><a href="https://selenium-python.readthedocs.io/waits.html#explicit-waits">Explicit Waits</a></li>
    </ul>

    <hr>

    <h1 id="-web-">Тестирование web-приложений и тестовые фреймворки</h1>
    <p>Для начала нам необходимо познакомиться с распространенными тестовыми фреймворками unittest и PyTest.
    Это необходимо, чтобы называть наши скрипты тестами. А главный атрибут теста - это сопоставление ожидаемого результата
    фактическому.</p>
    <h2 id="-">Автоматическое и ручное тестирование</h2>
    <p>Чтобы писать хорошие автотесты необходимо понимать различия, сильные и слабые стороны ручного и автоматического
    тестирования.</p>
    <table>
    <thead>
    <tr>
    <th>Критерий</th>
    <th>Ручное тестирование</th>
    <th>Автоматическое тестирование</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td>Тестовое покрытие</td>
    <td>Ограниченное тестовое покрытие из-за нехватки времени и ресурсов</td>
    <td>Полное тестовое покрытие может быть достигнуто с помощью больших наборов тестов</td>
    </tr>
    <tr>
    <td>Скорость выполнения</td>
    <td>Медленное выполнение и большая трудоемкость</td>
    <td>Более быстрое выполнение, экономия времени и усилий</td>
    </tr>
    <tr>
    <td>Человеческие ошибки</td>
    <td>Подвержены человеческим ошибкам</td>
    <td>Менее подвержены человеческим ошибкам</td>
    </tr>
    <tr>
    <td>Содержание</td>
    <td>Сценарии ручного тестирования требуют большего обслуживания и поддержки</td>
    <td>Сценарии автоматизированного тестирования требуют меньше обслуживания и поддержки</td>
    </tr>
    <tr>
    <td>Регрессионное тестирование</td>
    <td>Ручное регрессионное тестирование отнимает много времени и подвержено ошибкам</td>
    <td>Автоматизированное регрессионное тестирование эффективно и надежно</td>
    </tr>
    <tr>
    <td>Начальная стоимость и настройка окружения</td>
    <td>Низкие первоначальные затраты и время настройки</td>
    <td>Высокая начальная стоимость и время настройки</td>
    </tr>
    <tr>
    <td>Гибкость</td>
    <td>Более гибкие с точки зрения модификации тест-кейсов</td>
    <td>Менее гибкие с точки зрения модификации тест-кейсов</td>
    </tr>
    <tr>
    <td>Требования к навыкам</td>
    <td>Не требует специальных технических навыков</td>
    <td>Требуются специальные технические навыки</td>
    </tr>
    <tr>
    <td>Когда использовать</td>
    <td>При тестировании небольших изолированных функций или новых приложений</td>
    <td>При тестировании больших сложных систем с повторяющимися тестовыми сценариями</td>
    </tr>
    </tbody>
    </table>
    <h3 id="-">Ручное тестирование лучше использовать в следующих случаях:</h3>
    <ul>
    <li>Для исследовательского тестирования, когда тестирование основано на интуиции, творчестве и опыте, а не на заранее
    определенном наборе тест-кейсов.</li>
    <li>Для тестирования удобства использования, когда основное внимание уделяется пользовательскому опыту и требуется
    обратная связь.</li>
    <li>Для тестирования небольших изолированных функций или новых приложений, где тестовые наборы ограничены, а стоимость
    автоматизации высока.</li>
    <li>Когда тестирование требует участия человека, например, тестирование пользовательского интерфейса или интуитивное (
    ad-hoc) тестирование.</li>
    </ul>
    <h3 id="-">Лучше использовать автоматизированное тестирование в следующих случаях:</h3>
    <ul>
    <li>При тестировании больших и сложных систем с повторяющимися тест-кейсами.</li>
    <li>Когда требуется регрессионное тестирование, чтобы убедиться, что новые изменения не нарушают существующую
    функциональность.</li>
    <li>Когда требуется тестирование производительности или нагрузочное тестирование для имитации большого количества
    пользователей.</li>
    <li>Когда требуется интеграционное тестирование, чтобы убедиться, что все компоненты системы работают без сбоев.</li>
    <li>При тестировании требуется высокая степень точности и согласованности, например, проверка данных или тестирование
    безопасности.</li>
    </ul>
    <h2 id="-">Юнит-тесты (модульные тесты) и интеграционные тесты</h2>
    <p>Интеграционные тесты и модульные тесты — это типы автоматических тестов, но они различаются по своему объему и
    назначению.</p>
    <p>Модульные тесты сосредоточены на тестировании отдельных единиц кода, таких как функции или методы, изолированно от
    остальной системы. Цель модульных тестов — убедиться, что каждая сущность кода ведет себя ожидаемым образом в различных
    условиях и что изменения в одной сущносте кода не нарушают работу других сущностей. Примеры модульных тестов могут
    включать тестирование функции, вычисляющей квадратный корень из числа, или тестирование метода,
    который складывает два числа.</p>
    <p>Интеграционные тесты, с другой стороны, сосредоточены на проверке того, как различные блоки кода работают вместе, чтобы
    сформировать полную систему. Целью интеграционных тестов является выявление проблем, которые могут возникнуть при
    объединении различных единиц кода, таких как проблемы со связью между компонентами или с внешними системами. Примеры
    интеграционных тестов могут включать тестирование сквозной функциональности веб-приложения или тестирование
    взаимодействия базы данных с приложением.</p>
    <p>Как правило, модульные тесты запускаются чаще и выполняются быстрее, чем интеграционные тесты, поскольку они тестируют
    небольшие фрагменты кода изолированно. Однако интеграционные тесты важны для обеспечения правильной работы системы в
    целом и обычно выполняются реже, чем модульные тесты.</p>
    <p>Важно отметить, что граница между модульными тестами и интеграционными тестами иногда может быть нечеткой и что различие
    между ними не всегда ясное. Некоторые тесты могут находиться где-то посередине, и в конечном итоге команда тестирования
    должна определить, как лучше классифицировать и расставить приоритеты для своих тестов в зависимости от потребностей
    проекта.</p>
    <p>Подробнее про разные типы автотестов вы можете изучить самостоятельно. Вот хорошая
    статья <a href="https://habr.com/ru/articles/358950/">Пирамида тестов на практике</a>.</p>
    <h2 id="-">Структура теста</h2>
    <p>Основная структура тестирования как для модульных, так и UI автоматизированных тестов
    может быть разбита на три части:</p>
    <ol>
    <li>Test Setup: здесь подготавливаются среда и тестовые данные. В модульных тестах это может включать настройку фиктивных
    объектов(mocks) или заглушек для зависимостей, а в тестах пользовательского интерфейса — настройку веб-драйвера или
    эмулятора.</li>
    <li>Test Execution: здесь выполняется фактическая тестовая логика. В модульных тестах это может включать вызов методов и
    проверку вывода, тогда как в тестах пользовательского интерфейса это может включать взаимодействие с элементами
    пользовательского интерфейса и проверку ожидаемого поведения.</li>
    <li>Test Teardown: здесь выполняются любые действия по очистке. В модульных тестах это может включать сброс состояния
    любых фиктивных объектов, а в тестах пользовательского интерфейса это может включать закрытие веб-драйвера или
    эмулятора.</li>
    </ol>
    <p>Несмотря на некоторые различия в деталях реализации модульных тестов и тестов пользовательского интерфейса, общая
    структура тестов схожа. Оба типа тестов направлены на проверку функциональности приложения и обеспечение его правильного
    поведения в различных сценариях.</p>
    <p>Давайте обсудим, как именно можно производить проверки.</p>
    <h2 id="-">Проверка ожидаемого результата</h2>
    <p>Один из способов проверить ожидаемый результат — использовать встроенный оператор <code>assert</code> в Python. Этот оператор
    оценивает достоверность утверждений, позволяя вам убедиться, что ваш код работает должным образом. Если ваше утверждение
    истинно, никаких дополнительных сообщений генерироваться не будет. Однако, если утверждение ложно, будет выдано
    исключение <code>AssertionError</code> с текстом, которое вы можете указать после логической проверки.</p>
    <p>Посмотрим как работает <code>assert</code> на примере:</p>
    <pre><code class="lang-python"># <span class="hljs-keyword">Create</span> a list <span class="hljs-keyword">of</span> numbers
    numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    
    # Use the built-<span class="hljs-keyword">in</span> sum() <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">to</span> <span class="hljs-title">add</span> <span class="hljs-title">up</span> <span class="hljs-title">the</span> <span class="hljs-title">numbers</span>
    <span class="hljs-title">total</span> = <span class="hljs-title">sum</span><span class="hljs-params">(numbers)</span>
    
    # <span class="hljs-title">Assert</span> <span class="hljs-title">that</span> <span class="hljs-title">the</span> <span class="hljs-title">total</span> <span class="hljs-title">is</span> 15
    <span class="hljs-title">assert</span> <span class="hljs-title">total</span> == 15, "<span class="hljs-title">The</span> <span class="hljs-title">sum</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">numbers</span> <span class="hljs-title">is</span> <span class="hljs-title">incorrect</span>"</span>
    </code></pre>
    <p>В этом примере мы используем встроенный метод <code>sum()</code> для сложения чисел в списке чисел. Затем мы используем оператор
    <code>assert</code>, чтобы проверить, что сумма чисел в списке равно 15, как мы ожидаем.
    Если сумма не равна 15, оператор утверждения вызовет <code>AssertionError</code> и напечатает
    сообщение <code>&quot;The sum of the numbers is incorrect&quot;</code>.
    Вы можете изменить числа в списке, чтобы проверка оказалась не выполнена и посмотреть на работу оператора <code>assert</code> в
    этом случае.</p>
    <p>Обратите внимание на то, что когда ваших тестов станет огромное количество вы уже не будете помнить, что конкретно
    проверяет каждый тест. И фраза &quot;Сумма чисел некорректна&quot; не проясняет суть проблемы и вам придется тратить время,
    чтобы понять что конкретно пошло не так.</p>
    <p>Давайте попытаемся уменьшить степень неопределенности нашего теста:</p>
    <pre><code class="lang-python"><span class="hljs-comment"># Create a list of numbers</span>
    <span class="hljs-attr">numbers</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    
    <span class="hljs-comment"># Use the built-in sum() method to add up the numbers</span>
    <span class="hljs-attr">total</span> = sum(numbers)
    
    <span class="hljs-comment"># Assert that the total is 15</span>
    <span class="hljs-attr">expected_sum</span> = <span class="hljs-number">100500</span>
    
    <span class="hljs-keyword">assert</span> <span class="hljs-attr">total</span> == expected_sum, \
        f<span class="hljs-string">"The sum of the list {numbers} is incorrect. "</span> \
        f<span class="hljs-string">"Expected: {expected_sum}. Got: {total}."</span>
    </code></pre>
    <h2 id="-">Задание: составные сообщения об ошибках</h2>
    <p>ля закрепления материала реализуйте проверку самостоятельно.</p>
    <p>Вам дана функция test_input_text, которая принимает два значения: expected_result — ожидаемый результат, и
    actual_result — фактический результат. Обратите внимание, input использовать не нужно!</p>
    <p>Функция должна проверить совпадение значений с помощью оператора assert и, в случае несовпадения, предоставить
    исчерпывающее сообщение об ошибке.</p>
    <p>Маленький совет: попробуйте написать код и протестируйте его код на разных введенных
    значениях, проверьте вывод вашей функции на разных парах. Обрабатывать ситуацию с пустым или невалидным вводом не нужно.</p>
    <p>Sample Input 1: 8 11
    Sample Output 1: expected 8, got 11</p>
    <p>Sample Input 2: 11 11
    Sample Output 2:</p>
    <p>Sample Input 3: 11 15
    Sample Output 3: expected 11, got 15</p>
    <details>
      <summary>Правильный ответ</summary>
    
    <code>python
    def test_input_text(expected_result, actual_result):
        assert expected_result == actual_result, f&#39;expected {expected_result}, got {actual_result}&#39;</code>
    
    </details>
    
    <h2 id="-">Задание: составные сообщения об ошибках и поиск подстроки</h2>
    <p>Вам дан шаблон для функции test_substring, которая принимает два значения: full_string и substring.</p>
    <p>Функция должна проверить вхождение строки substring в строку full_string с помощью оператора assert и, в случае
    несовпадения, предоставить исчерпывающее сообщение об ошибке.</p>
    <p>Важно! Формат ошибки должен точно совпадать с приведенным в примере, чтобы его засчитала проверяющая система!</p>
    <p>Маленький совет: попробуйте написать код и протестируйте его код на разных введенных
    значениях, проверьте вывод вашей функции на разных парах. Обрабатывать ситуацию с пустым или невалидным вводом не нужно.</p>
    <p>Sample Input 1: fulltext some_value
    Sample Output 1: expected &#39;some_value&#39; to be substring of &#39;fulltext&#39;</p>
    <p>Sample Input 2: 1 1
    Sample Output 2:</p>
    <p>Sample Input 3: some_text some
    Sample Output 3:</p>
    <details>
      <summary>Правильный ответ</summary>
    
    <code>python
    def test_substring(full_string, substring):
        assert substring in full_string, f&#39;expected \&#39;{substring}\&#39; to be substring of \&#39;{full_string}\&#39;&#39;</code>
    
    </details>
    
    <h2 id="-">Тестовые сценарии</h2>
    <p>Созданные тесты нужно сохранить в файле, чтобы его было удобно запускать и хранить в системе контроля версий. Давайте
    создадим файл <code>test_list_sum.py</code> и напишем в нём следующий код:</p>
    <pre><code class="lang-python"><span class="hljs-string">"""Making first test scripts."""</span>
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_sum_of_list_elements_equals_fifteen</span><span class="hljs-params">(input_list: list[int])</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-string">"""Testing that sum of list elements is equal to 15."""</span>
        total = sum(input_list)
        <span class="hljs-keyword">assert</span> total == <span class="hljs-number">15</span>, \
        f<span class="hljs-string">"The sum of the list {input_list} is incorrect. "</span> \
        f<span class="hljs-string">"Expected: 15. Got: {total}."</span>
    
    
    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
        <span class="hljs-string">"""This method works if started from that module."""</span>
        numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
        test_sum_of_list_elements_equals_fifteen(numbers)
        print(<span class="hljs-string">"All tests passed!"</span>)
    </code></pre>
    <p>Тест-кейс помещен в отдельную функцию, чтобы можно было независимо к нему обращаться.</p>
    <p>В этом файле мы вызываем функцию <code>test_sum_of_list_elements_equals_fifteen()</code> и передаем ей в качестве аргумента
    наш список. Функция выполняет тестовый сценарий. Если тесты прошли успешно, то мы увидим в терминале выполнение
    команды <code>print(&quot;All tests passed!&quot;)</code>.</p>
    <p>Запустите тест и посмотрите как он работает. Попробуйте изменить входные данные так, чтобы тест провалился.</p>
    <p>Добавим в файл <code>test_list_sum.py</code> еще один тест и обратим внимание на поведение оператора <code>assert</code>: при провале любого
    теста прекращается выполнение команд интерпретатором.</p>
    <p>Добавим следующий код:</p>
    <pre><code class="lang-python"><span class="hljs-string">"""Making first test scripts."""</span>
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_sum_of_list_elements_equals_fifteen</span><span class="hljs-params">(input_list: list[int])</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-string">"""Test that sum of list elements is equal to 15."""</span>
        total = sum(input_list)
        <span class="hljs-keyword">assert</span> total == <span class="hljs-number">15</span>, \
        f<span class="hljs-string">"The sum of the list {input_list} is incorrect. "</span> \
        f<span class="hljs-string">"Expected: 15. Got: {total}."</span>
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_number_is_greater_than_five</span><span class="hljs-params">(number: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-string">"""Test that the number is greater than 5."""</span>
        <span class="hljs-keyword">assert</span> number &gt; <span class="hljs-number">5</span>, \
        f<span class="hljs-string">"Number {number} is not greater than 5."</span>
    
    
    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
        <span class="hljs-string">"""This method works if started from that module."""</span>
        big_number = <span class="hljs-number">-191</span>
        test_number_is_greater_than_five(big_number)
        numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
        test_sum_of_list_elements_equals_fifteen(numbers)
        print(<span class="hljs-string">"All tests passed!"</span>)
    </code></pre>
    <h2 id="-test-runner">Выбор test runner</h2>
    <p>В предыдущих шагах мы научились писать простые тесты и запускать их с помощью Python. Приведём здесь код тестов и
    результаты запуска из предыдущего шага еще раз.</p>
    <h3 id="test_list_sum-py">test_list_sum.py</h3>
    <pre><code class="lang-python"><span class="hljs-string">"""Making first test scripts."""</span>
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_sum_of_list_elements_equals_fifteen</span><span class="hljs-params">(input_list: list[int])</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-string">"""Test that sum of list elements is equal to 15."""</span>
        total = sum(input_list)
        <span class="hljs-keyword">assert</span> total == <span class="hljs-number">15</span>, \
        f<span class="hljs-string">"The sum of the list {input_list} is incorrect. "</span> \
        f<span class="hljs-string">"Expected: 15. Got: {total}."</span>
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_number_is_greater_than_five</span><span class="hljs-params">(number: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
        <span class="hljs-string">"""Test that the number is greater than 5."""</span>
        <span class="hljs-keyword">assert</span> number &gt; <span class="hljs-number">5</span>, \
        f<span class="hljs-string">"Number {number} is not greater than 5."</span>
    
    
    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
        <span class="hljs-string">"""This method works if started from that module."""</span>
        big_number = <span class="hljs-number">-191</span>
        test_number_is_greater_than_five(big_number)
        numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
        test_sum_of_list_elements_equals_fifteen(numbers)
        print(<span class="hljs-string">"All tests passed!"</span>)
    </code></pre>
    <h3 id="-">Консоль</h3>
    <pre><code class="lang-shell">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):
      <span class="hljs-keyword">File</span> <span class="hljs-string">"C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum.py"</span>, line <span class="hljs-number">21</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-keyword">module</span>&gt;
        test_number_is_greater_than_five(big_number)
      <span class="hljs-keyword">File</span> <span class="hljs-string">"C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum.py"</span>, line <span class="hljs-number">14</span>, <span class="hljs-keyword">in</span> test_number_is_greater_than_five
        assert <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">5</span>, \
               ^^^^^^^^^^
    AssertionError: <span class="hljs-built_in">Number</span> <span class="hljs-number">-191</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> greater <span class="hljs-keyword">than</span> <span class="hljs-number">5.</span>
    </code></pre>
    <h3 id="-">Рассмотрим минусы такого подхода к запуску автотестов:</h3>
    <ul>
    <li>По мере роста количества тестов становится сложно изолировать и запускать только необходимые наборы тестов.</li>
    <li>Чтобы выполнить каждый тест, вы должны подготовить тестовые данные и среду независимо друг от друга. Например, если вы
    хотите открывать и закрывать браузер для каждого теста, логика работы браузера должна быть воспроизведена в коде
    каждого отдельного теста.</li>
    <li>Если тест завершается ошибкой из-за ошибки AssertionError, последующие тесты выполняться не будут. Следовательно,
    любые потенциальные проблемы в этих тестах останутся неизвестными до тех пор, пока неудачный тест не будет устранен
    или пока каждый тест не будет выполнен вручную по отдельности.</li>
    </ul>
    <p>Чтобы упростить процесс написания и выполнения тестов, разработчики используют специализированные фреймворки, известные
    как средства выполнения тестов (test runners). Существует три основных тестовых фреймворка для Python:
    unittest, PyTest и Nose. Заметным преимуществом обладает модуль unittest потому что он встроенный.
    Между тем, PyTest и Nose предлагают расширенные функции,
    которые превосходят возможности unittest. Мы сначала кратко рассмотрим использование unittest, а
    затем углубимся в возможности PyTest, который позволяет использовать более простой тестовый код, чем unittest, и
    обеспечивает гибкое выполнение тестов. Кроме того, PyTest имеет обширную библиотеку плагинов, которые могут решить
    практически любую проблему, связанную с автоматическим тестированием.</p>
    <h2 id="unittest">unittest</h2>
    <p>Тест-раннеры могут автоматически обнаруживать методы тестирования в указанных файлах при условии соблюдения
    стандартных соглашений. Фундаментальное соглашение во всех средах тестирования заключается в том, что имя метода
    тестирования должно начинаться со слова <code>test_</code>. Впоследствии может следовать любой текст для создания уникального имени
    теста:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_specific_meaningful_test_text</span><span class="hljs-params">()</span>:</span>
        <span class="hljs-keyword">pass</span>
    </code></pre>
    <p>Для unittest существуют собственные дополнительные правила:</p>
    <ul>
    <li>Тесты обязательно должны находиться в специальном тестовом классе.</li>
    <li>Вместо assert должны использоваться специальные assertion методы.</li>
    </ul>
    <p>Давайте теперь изменим наши предыдущие тесты, чтобы их можно было запустить с помощью unittest. Для этого нам
    понадобится выполнить следующие шаги:</p>
    <ol>
    <li>Импортировать unittest в файл: <code>import unittest</code></li>
    <li>Создать класс, который должен наследоваться от класса TestCase: <code>class TestWithUnittest(unittest.TestCase):</code></li>
    <li>Превратить тестовые функции в методы, добавив ссылку на экземпляр класса <code>self</code> в качестве первого аргумента функции:
    <code>def test_sum_of_list_elements_equals_fifteen(self, input_list: list[int]) -&gt; None:</code></li>
    <li>Изменить <code>assert</code> на <code>self.assertEqual()</code></li>
    <li>Заменить строку запуска программы на <code>unittest.main()</code></li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-string">"""Making first test scripts."""</span>
    <span class="hljs-keyword">import</span> unittest
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWithUnittest</span><span class="hljs-params">(unittest.TestCase)</span>:</span>
        <span class="hljs-string">"""Test class must be inherited from TestCase."""</span>
        big_number = <span class="hljs-number">-191</span>
        numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_sum_of_list_elements_equals_fifteen</span><span class="hljs-params">(self)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
            <span class="hljs-string">"""Test that sum of list elements is equal to 15."""</span>
            input_list = self.numbers
            total = sum(input_list)
            self.assertEqual(total, <span class="hljs-number">15</span>, \
                             f<span class="hljs-string">"The sum of the list {input_list} is incorrect. "</span> \
                             f<span class="hljs-string">"Expected: 15. Got: {total}."</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_number_is_greater_than_five</span><span class="hljs-params">(self)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
            <span class="hljs-string">"""Test that the number is greater than 5."""</span>
            number = self.big_number
            self.assertTrue(number &gt; <span class="hljs-number">5</span>, \
                            f<span class="hljs-string">"Number {number} is not greater than 5."</span>)
    
    
    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
        <span class="hljs-string">"""This method works if started from that module."""</span>
        unittest.main()
        print(<span class="hljs-string">"All tests passed!"</span>)
    </code></pre>
    <p>После изменений запустим наш файл с тестами всё так же с помощью Python:</p>
    <pre><code class="lang-shell">Ran 2 tests in 0.005s
    
    FAILED (failures=1)
    
    Failure
    Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):
      <span class="hljs-keyword">File</span> <span class="hljs-string">"C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum_unittest.py"</span>, line <span class="hljs-number">21</span>, <span class="hljs-keyword">in</span> test_number_is_greater_than_five
        self.assertTrue(<span class="hljs-built_in">number</span> &gt; <span class="hljs-number">5</span>, \
    AssertionError: <span class="hljs-literal">False</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">true</span> : <span class="hljs-built_in">Number</span> <span class="hljs-number">-191</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> greater <span class="hljs-keyword">than</span> <span class="hljs-number">5.</span>
    </code></pre>
    <p>Теперь мы видим более подробную информацию о результатах запуска: было запущено два теста, один тест выполняется с
    ошибкой. Место ошибки и пояснение к ней отображаются в логе.</p>

    <h1 id="-pytest">Тестирование с помощью PyTest</h1>
    <h2 id="pytest-">PyTest — преимущества и недостатки</h2>
    <p>Установить PyTest можно использовав команду:</p>
    <pre><code class="lang-shell">pip <span class="hljs-keyword">install</span> pytest
    </code></pre>
    <p>Мы будем использовать версию 7.3.1. Её можно установить командой:</p>
    <pre><code class="lang-shell">pip install pytest==<span class="hljs-number">7.3</span><span class="hljs-number">.1</span>
    </code></pre>
    <p>Или подтянуть зависимости из файла <code>requirements.txt</code>:</p>
    <pre><code class="lang-shell">pip <span class="hljs-keyword">install</span> -r requirements.txt
    </code></pre>
    <p>Рассмотрим преимущества использования PyTest:</p>
    <ol>
    <li>Простой и удобный в использовании: PyTest разработан, чтобы быть интуитивно понятным и простым в использовании, с
    простым синтаксисом для определения тестов и фикстур.</li>
    <li>Мощные фикстуры: фикстуры в PyTest — это мощный инструмент для настройки тестовых данных и ресурсов, и их можно
    использовать в тестах и наборах тестов.</li>
    <li>Полная отчетность: PyTest предоставляет подробные и исчерпывающие отчеты о результатах тестирования, включая сводки,
    информацию о трассировке и продолжительность тестирования.</li>
    <li>Параметризованное тестирование. С помощью PyTest вы можете легко выполнять параметризованное тестирование, когда одна
    тестовая функция запускается с несколькими наборами входных данных.</li>
    <li>Система плагинов: PyTest имеет богатую систему плагинов, которая предоставляет широкий спектр функций, таких как
    параллельный запуск тестов, создание отчетов в формате HTML и многое другое.</li>
    <li>Поддерживает как модульное, так и функциональное тестирование: PyTest поддерживает как модульное, так и
    функциональное тестирование, что делает его универсальным инструментом для тестирования всех типов кода Python.</li>
    <li>Лучшее обнаружение тестов: PyTest обеспечивает лучшее обнаружение тестов, чем unittest, который может автоматически
    находить и запускать тесты в каталоге или модуле, не требуя явных тест-кейсов.</li>
    </ol>
    <p>В целом, PyTest — это мощный и гибкий инструмент тестирования, который обеспечивает множество преимуществ по сравнению с
    unittest, включая более простой синтаксис, более мощные инструменты, улучшенную отчетность и большую расширяемость.</p>
    <p>Хотя у PyTest есть много преимуществ, есть и некоторые недостатки, которые следует учитывать при его использовании:</p>
    <ol>
    <li>Кривая обучения: PyTest имеет более обширный набор функций и требует некоторых дополнительных знаний по сравнению со
    встроенным модулем unittest. Это может затруднить обучение новичков.</li>
    <li>Настройка: гибкость PyTest может быть палкой о двух концах. Его широкие возможности настройки могут затруднить для
    команд поддержание согласованности в наборах тестов.</li>
    <li>Управление плагинами: PyTest имеет большое количество доступных плагинов, что может быть как силой, так и слабостью.
    Хотя они предлагают множество полезных функций, управление плагинами может занимать много времени, и может быть
    сложно найти и выбрать правильный плагин для ваших нужд.</li>
    <li>Отладка: отладка может быть сложной задачей в PyTest из-за его модульной природы. Иногда может быть сложно
    определить, какой плагин или хук вызывает проблему, что приводит к увеличению времени отладки.</li>
    <li>Накладные расходы: дополнительные функции и гибкость PyTest сопряжены с некоторыми накладными расходами. В некоторых
    случаях тесты PyTest могут выполняться дольше, чем тесты, написанные с использованием более простых сред
    тестирования.</li>
    </ol>
    <p>При рассмотрении вопроса о том, является ли PyTest правильным выбором для вашего проекта, важно взвесить эти недостатки
    и преимущества.</p>
    <h2 id="-">Отвлекемся на фиксацию пакетов</h2>
    <p>Файл <code>requirements.txt</code> — это текстовый файл, в котором вы можете перечислить необходимые пакеты Python с их версиями.
    Распространенной практикой является использование файла <code>requirements.txt</code>, чтобы сделать ваш проект более переносимым и
    чтобы любой, кто хочет запустить ваш код, могли легко установить все зависимости.</p>
    <p>Когда вы создаете файл <code>requirements.txt</code>, вы можете перечислить все пакеты Python, необходимые для запуска вашего
    проекта. Вы можете указать версию каждого пакета или использовать диапазоны версий, чтобы указать, что любая версия в
    пределах определенного диапазона будет приемлемой.</p>
    <p>Чтобы создать файл requirements.txt для вашего проекта Python, выполните следующие действия:</p>
    <ol>
    <li>Откройте командную строку или окно терминала.</li>
    <li>Перейдите в каталог вашего проекта.</li>
    <li>Убедитесь, что ваша виртуальная среда активна.</li>
    <li>Выполните следующую команду, чтобы создать файл <code>requirements.txt</code>:</li>
    </ol>
    <pre><code class="lang-shell"><span class="hljs-selector-tag">pip</span> <span class="hljs-selector-tag">freeze</span> &gt; <span class="hljs-selector-tag">requirements</span><span class="hljs-selector-class">.txt</span>
    </code></pre>
    <p>Это создаст новый файл с именем <code>requirements.txt</code> в каталоге вашего проекта. Файл будет содержать список всех
    установленных пакетов и их версий.</p>
    <p>Если вы используете виртуальные среды, рекомендуется создать новый файл требований после установки нового пакета или
    обновления существующего. Это гарантирует наличие актуального списка зависимостей, которые можно легко установить в
    других средах.</p>
    <p>Чтобы установить зависимости из файла <code>requirements.txt</code> нужно использовать команду:</p>
    <pre><code class="lang-shell">pip <span class="hljs-keyword">install</span> -r requirements.txt
    </code></pre>
    <p>Все необходимые зависимости установлены одной командой!</p>
    <h2 id="pytest-">PyTest: правила запуска тестов</h2>
    <p>Мы кратко остановимся на важнейших функциях запуска тестов с использованием PyTest. Когда мы
    инициируем команду <code>pytest</code>, средство запуска тестов соберет все тесты для выполнения на основе определенных правил:</p>
    <ul>
    <li>Если мы выполним команду <code>pytest</code> без передачи каких-либо аргументов, средство запуска тестов автоматически выполнит
    поиск тестов в текущем каталоге.</li>
    <li>В качестве аргумента вы можете передать файл, путь к каталогу или любую комбинацию каталогов и файлов. Например:</li>
    </ul>
    <pre><code class="lang-shell">pytest scripts/selenium_scripts
    <span class="hljs-meta"># найти все тесты в директории scripts/selenium_scripts</span>
    
    pytest test_user_interface.py
    <span class="hljs-meta"># найти и выполнить все тесты в файле </span>
    
    pytest scripts/drafts.py::test_register_new_user_parametrized
    <span class="hljs-meta"># найти тест с именем test_register_new_user_parametrized в указанном файле в указанной директории и выполнить</span>
    </code></pre>
    <ul>
    <li>Далее PyTest выполнит рекурсивный поиск по всем вложенным каталогам.</li>
    <li>Во время поиска PyTest проверяет все каталоги на наличие файлов, которые соответствуют соглашению об
    именах <code>test_*.py</code> или <code>*test.py</code> (т. е. файлы, которые начинаются с <code>test_</code> или заканчиваются на <code>_test</code> и имеют
    расширение <code>.py</code>).</li>
    <li>В каждом из этих файлов PyTest идентифицирует тестовые функции на основе следующих правил:<ul>
    <li>PyTest идентифицирует все тесты, которые находятся за пределами классов и имена которых начинаются с <code>test</code>.</li>
    <li>Кроме того, PyTest идентифицирует все тесты в классах, имена которых начинаются с <code>Test</code> (и которые не содержат
    метод инициализации) и имена методов которых начинаются с <code>test</code>.</li>
    </ul>
    </li>
    </ul>
    <p>С подробностями можно ознакомиться в
    <a href="https://docs.pytest.org/en/stable/explanation/goodpractices.html#conventions-for-python-test-discovery">соглашении по обнаружению тестов.</a></p>
    <h2 id="pytest-">PyTest — отчёты</h2>
    <p>При выполнении PyTest с флагом -v (verbose, подробный) отчет о тестировании включает дополнительную информацию, в
    которой перечислены тесты и их статус прохождения/непрохождения.</p>
    <p>Ознакомиться с другими полезными командами и функциями вывода информации можно использовав команду:</p>
    <pre><code class="lang-shell">pytest <span class="hljs-comment">--help</span>
    </code></pre>
    <h2 id="pytest-">PyTest — как пишут тесты</h2>
    <p>В отличие от unittest, PyTest не требует использования дополнительных специфических конструкций в ваших тестах.</p>
    <p>Мы уже запускали тесты, написанные в unittest стиле с помощью PyTest.
    Давайте перепишем их в более простом варианте, который понимает PyTest.</p>
    <p>Назовем новый файл <code>test_sum_and_value.py</code></p>
    <pre><code class="lang-python"><span class="hljs-string">"""Making first test scripts."""</span>
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWithPytest</span>:</span>
        <span class="hljs-string">"""This class provides data for tests."""</span>
        big_number: int = <span class="hljs-number">-191</span>
        numbers: list[int] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_sum_of_list_elements_equals_fifteen</span><span class="hljs-params">(self)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
            <span class="hljs-string">"""Test that sum of list elements is equal to 15."""</span>
            input_list = self.numbers
            total = sum(input_list)
            <span class="hljs-keyword">assert</span> total == <span class="hljs-number">15</span>, \
                f<span class="hljs-string">"The sum of the list {input_list} is incorrect. "</span> \
                f<span class="hljs-string">"Expected: 15. Got: {total}."</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_number_is_greater_than_five</span><span class="hljs-params">(self)</span> -&gt; <span class="hljs-keyword">None</span>:</span>
            <span class="hljs-string">"""Test that the number is greater than 5."""</span>
            number = self.big_number
            <span class="hljs-keyword">assert</span> number &gt; <span class="hljs-number">5</span>, \
                f<span class="hljs-string">"Number {number} is not greater than 5."</span>
    </code></pre>
    <p>Запустим тесты в этом файле:</p>
    <pre><code class="lang-shell">pytest test<span class="hljs-number">_</span>sum<span class="hljs-number">_</span>and<span class="hljs-number">_</span><span class="hljs-keyword">value</span>.py
    </code></pre>

    <h1 id="-pytest">Использование фикстур в PyTest</h1>
    <h2 id="-fixtures-">Классические фикстуры (fixtures)</h2>
    <p>В контексте PyTest фикстуры — это вспомогательные функции для тестов, которые существуют вне самого тестового сценария.</p>
    <p>Фикстуры служат различным целям, включая подготовку тестовой среды, очистку тестовой среды и данных после завершения
    теста, подключение к базам данных, создание тестовых файлов и подготовку данных в текущей среде с использованием методов
    API. Для получения дополнительной информации о фикстурах в самом широком смысле см. статью
    в <a href="https://en.wikipedia.org/wiki/Test_fixture#Software">Википедии</a> на эту тему.</p>
    <p>Традиционный подход к использованию фикстур предполагает создание методов настройки и демонтажа в тестовом файле. Вы
    можете найти более подробную информацию о том, как использовать эти методы
    в <a href="https://docs.pytest.org/en/latest/how-to/xunit_setup.html">документации PyTest</a>.</p>
    <p>Фикстуры можно создавать для различных областей, таких как модули, классы и отдельные функции в PyTest. Мы можем создать
    фикстуру для инициализации браузера, которую можно использовать в наших тестах. Чтобы избежать нескольких открытых окон
    браузера, мы закроем браузер с помощью команды <code>browser.quit()</code> после завершения выполнения тестов. Переместив код
    инициализации и закрытия браузера в фикстуры, мы можем повторно использовать код в нескольких тестах, не повторяя его
    каждый раз.</p>
    <p>Чтобы организовать наши тесты, мы сгруппируем их в тестовые наборы, используя классы в качестве контейнеров.</p>
    <p>Давайте рассмотрим два примера, иллюстрирующих использование фикстур. Первый пример включает создание экземпляра
    браузера и его закрытие только один раз для всех тестов в наборе тестов. Напротив, во втором примере создается браузер
    для каждого теста в наборе тестов. Вы можете сохранить приведенный ниже код в файл с именем <code>test_fixture1.py</code> и
    запустить его с помощью PyTest. Чтобы увидеть вывод команды <code>print()</code>, не забудьте использовать параметр <code>-s</code>.</p>
    <pre><code class="lang-shell">pytest <span class="hljs-_">-s</span> test_fixture1.py
    </code></pre>
    <pre><code class="lang-python">from selenium import webdriver
    from selenium.webdriver.common.by import By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span>:</span>
    
        @classmethod
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup_class</span><span class="hljs-params">(cls)</span></span>:
            print(<span class="hljs-string">"\nstart browser for test suite.."</span>)
            cls.browser = webdriver.Chrome()
    
        @classmethod
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teardown_class</span><span class="hljs-params">(cls)</span></span>:
            print(<span class="hljs-string">"quit browser for test suite.."</span>)
            cls.browser.quit()
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            <span class="hljs-keyword">self</span>.browser.get(link)
            <span class="hljs-keyword">self</span>.browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            <span class="hljs-keyword">self</span>.browser.get(link)
            <span class="hljs-keyword">self</span>.browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage2</span>:</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup_method</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            print(<span class="hljs-string">"start browser for test.."</span>)
            <span class="hljs-keyword">self</span>.browser = webdriver.Chrome()
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teardown_method</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            print(<span class="hljs-string">"quit browser for test.."</span>)
            <span class="hljs-keyword">self</span>.browser.quit()
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            <span class="hljs-keyword">self</span>.browser.get(link)
            <span class="hljs-keyword">self</span>.browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            <span class="hljs-keyword">self</span>.browser.get(link)
            <span class="hljs-keyword">self</span>.browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    </code></pre>
    <p>Смотрим в консоль и видим, что в первом тест-сьюте браузер запустился один раз, а во втором — два раза.</p>
    <p>Запуск каждого теста в отдельном экземпляре браузера считается хорошей практикой, поскольку оставшиеся данные и кеш
    предыдущих тестов могут потенциально повлиять на результаты последующих тестов. Такой подход обеспечивает большую
    стабильность и надежность при тестировании. Более того, выполнение каждого теста в отдельном экземпляре браузера может
    предотвратить влияние проблем, которые могут возникнуть из-за зависания браузера во время одного теста, на другие тесты.</p>
    <p>Запуск браузера для каждого теста имеет некоторые недостатки. Каждый запуск и выход из браузера требует времени, что
    может увеличить продолжительность тестов. Если вам нужно оптимизировать время выполнения тестов, рекомендуется
    использовать другие инструменты, о которых речь пойдет позже.</p>
    <p>Как правило, эти фикстуры включаются в тесты, написанные на модульном тесте, и требуют обслуживания. Однако в настоящее
    время используются более гибкие фикстуры @pytest.fixture.</p>
    <h2 id="-">Фикстуры, возвращающие значение</h2>
    <p>В предыдущем разделе обсуждался традиционный метод создания фикстур, при котором тестовые данные инициализируются и
    очищаются в рамках методов setup и teardown. Однако PyTest предоставляет расширенный подход к фикстурам, где их
    можно определять глобально, передавать в качестве аргументов тестовым методам и даже включать в себя набор
    предварительно созданных фикстур. Этот подход гораздо более гибкий и удобный для работы со вспомогательными функциями, и
    мы сейчас рассмотрим его более подробно.</p>
    <h3 id="-">Возвращаемое значение</h3>
    <p>Давайте пересмотрим предыдущий пример, используя фикстуры PyTest. Мы можем создать фикстуру с именем <code>browser</code>, которая
    инициализирует объект WebDriver и возвращает его для использования в тестах. Чтобы определить фикстуру, нам нужно
    создать метод с именем <code>browser</code> и декорировать его @pytest.fixture. После определения мы можем вызвать фикстуру в
    наших тестах, передав ее в качестве параметра. По умолчанию для каждого тестового метода создается фикстура, а это
    значит, что для каждого теста будет запускаться отдельный экземпляр браузера.</p>
    <pre><code class="lang-shell">pytest <span class="hljs-_">-s</span> -v test_fixture2.py
    </code></pre>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">return</span> browser
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span>:</span>
        <span class="hljs-comment"># вызываем фикстуру в тесте, передав ее как параметр</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    </code></pre>
    <h2 id="-">Финализаторы — закрываем браузер</h2>
    <p>В предыдущем примере вы могли заметить, что мы не включили команду <code>browser.quit()</code>.
    В результате несколько окон браузера
    оставались открытыми после завершения тестов и закрывались только после того, как все тесты были выполнены. Такое
    поведение было связано со встроенным приспособлением — сборщиком мусора. Однако, если количество тестов превышает
    несколько десятков, оставление нескольких открытых окон браузера может быстро привести к истощению оперативной памяти
    системы. Поэтому крайне важно явно закрывать браузеры после каждого теста. Этого можно добиться с помощью финализаторов,
    и один из способов реализовать финализатор — использовать ключевое слово <code>yield</code> в Python. После завершения теста,
    вызвавшего фикстуру, выполнение фикстуры продолжается со строки, следующей за строкой с ключевым словом <code>yield</code>.</p>
    <blockquote>
    <p>test_fixture3.py</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        <span class="hljs-comment"># этот код выполнится после завершения теста</span>
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span>:</span>
        <span class="hljs-comment"># вызываем фикстуру в тесте, передав ее как параметр</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    </code></pre>
    <p>Документация PyTest предлагает альтернативный метод для вызова кода разрыва с использованием встроенной фиксации запроса
    и его метода <code>addfinalizer</code>. Вы можете обратиться
    к <a href="https://docs.pytest.org/en/latest/how-to/fixtures.html#adding-finalizers-directly">документации</a>, чтобы изучить этот
    метод.</p>
    <p>Вместо того, чтобы записывать данные и очистку памяти в шагах теста, рекомендуется помещать их в фикстуру, чтобы
    финализатор выполнялся даже в случае провала теста.</p>
    <h2 id="-scope">Область видимости scope</h2>
    <p>Фикстуры в PyTest могут быть привязаны к определенной области покрытия. Доступные значения для параметра области
    действия: «функция», «класс», «модуль» и «сеанс». В зависимости от выбранной области фикстура будет вызываться один раз
    для каждой тестовой функции, один раз для каждого тестового класса, один раз для каждого тестового модуля или один раз
    для всего тестового сеанса.</p>
    <p>Чтобы сэкономить время, мы можем установить область действия фикстуры браузера на «класс», чтобы все тесты из класса
    TestMainPage1 могли выполняться в одном и том же браузере.</p>
    <blockquote>
    <p>test_fixture5.py</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture(scope="class")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span>:</span>
    
        <span class="hljs-comment"># вызываем фикстуру в тесте, передав ее как параметр</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            print(<span class="hljs-string">"start test1"</span>)
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
            print(<span class="hljs-string">"finish test1"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            print(<span class="hljs-string">"start test2"</span>)
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
            print(<span class="hljs-string">"finish test2"</span>)
    </code></pre>
    <p>В этом примере браузер запускался только один раз, и тесты выполнялись последовательно в этом браузере. Хотя мы
    продемонстрировали это здесь, мы настоятельно рекомендуем запускать отдельный экземпляр браузера для каждого теста,
    чтобы повысить стабильность тестов. Для фикстур, которые потребляют много времени и ресурсов (обычно операции с базой
    данных), они могут выполняться один раз за сеанс выполнения теста.</p>
    <h2 id="-">Автоиспользование фикстур</h2>
    <p>Вы можете указать дополнительный параметр при определении фикстуры, а именно <code>autouse=True</code>, что означает, что фикстура
    будет автоматически выполняться для каждого теста, не требуя явного вызова.</p>
    <blockquote>
    <p>test_fixture_autouse.py</p>
    </blockquote>
    <p>Если вы запустите этот код, вы заметите, что фикстура подготовки данных выполняется для каждого теста даже без явного
    вызова из-за параметра <code>autouse=True</code>. Однако вы должны использовать этот параметр с осторожностью, так как фикстура
    будет выполняться для всех тестов. Поэтому рекомендуется использовать его только тогда, когда это необходимо.</p>

    <h1 id="pytest-">PyTest — маркировка</h1>
    <h2 id="-1">Маркировка тестов часть 1</h2>
    <p>При работе с большим количеством тестов может быть полезно распределить их по категориям, а не только по именам. Вот где
    вступает в действие маркировка тестов. Отмечая тесты определенными категориями, такими как «smoke» для критических
    тестов или «regression» для регрессионных тестов, выполняемых перед выпуском, мы можем выборочно запускать тесты на
    основе их категории. Кроме того, у нас могут быть тесты, специфичные для определенного браузера, например Internet
    Explorer 11, и мы можем захотеть запустить эти тесты только в этом браузере.
    PyTest предоставляет тестовую маркировку или метки для
    этой цели. Чтобы пометить тест, вы можете использовать декоратор, например @pytest.mark.mark_name, где «mark_name» —
    любая выбранная вами строка.</p>
    <p>Разделим тесты в одном из предыдущих примеров на smoke и regression.</p>
    <blockquote>
    <p>test_fixture8.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture(scope="function")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span>:</span>
    
    <span class="hljs-meta">    @pytest.mark.smoke</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            print(<span class="hljs-string">"smoke test"</span>)
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
    <span class="hljs-meta">    @pytest.mark.regression</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            print(<span class="hljs-string">"regression test"</span>)
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    </code></pre>
    <p>Вы можете выполнить тест с нужной меткой, передав параметр <code>-m</code>, а затем нужную метку в командной строке.</p>
    <pre><code class="lang-shell">pytest <span class="hljs-_">-s</span> -v -m smoke test_fixture8.py
    </code></pre>
    <p>Должен запуститься только тест с маркировкой smoke.</p>
    <p>При этом вы увидите уведомление с предупреждениями.</p>
    <p>В последних версиях PyTest настоятельно рекомендуется явно регистрировать метки перед использованием, чтобы избежать
    опечаток. Пометка теста несуществующей меткой может привести к тому, что он будет пропущен во время тестов. Вот почему
    появляется предупреждение.</p>
    <h2 id="-">Как регистрировать метки?</h2>
    <p>Создайте файл <code>pyproject.toml</code> в корневой директории вашего тестового проекта и добавьте в файл следующие строки:</p>
    <pre><code>[tool<span class="hljs-selector-class">.pytest</span><span class="hljs-selector-class">.ini_options</span>]
    
    markers = [
        <span class="hljs-string">"smoke: marker for smoke tests"</span>,
        <span class="hljs-string">"regression: marker for regression tests"</span>
    ]
    </code></pre><p>Запустите тесты повторно, предупреждений быть не должно.</p>
    <p>Маркировать можно не только методы, но и сразу целые классы. В этом случае маркировка будет применена ко всем тестовым
    методам этого класса.</p>
    <h2 id="-2">Маркировка тестов часть 2</h2>
    <h3 id="-">Инверсия</h3>
    <p>Для выполнения всех тестов, не помеченных как «smoke», можно использовать инверсию.
    Выполните следующую команду:</p>
    <pre><code class="lang-shell">pytest <span class="hljs-_">-s</span> -v -m <span class="hljs-string">"not smoke"</span> test_fixture8.py
    </code></pre>
    <h3 id="-">Объединение тестов с разными маркировками</h3>
    <p>Чтобы запустить тесты с разными метками с использованием логического ИЛИ, вы можете выполнить следующую команду для
    запуска как smoke, так и regression тестов:</p>
    <pre><code class="lang-shell">pytest <span class="hljs-_">-s</span> -v -m <span class="hljs-string">"smoke or regression"</span> test_fixture8.py
    </code></pre>
    <h3 id="-">Выбор тестов, имеющих несколько маркировок</h3>
    <p>Предполагая, что есть необходимость запускать дымовые тесты исключительно на Windows 10, мы можем прописать метку win10
    в файле <code>pyproject.toml</code> и назначить ее соответствующему тесту.</p>
    <blockquote>
    <p>pyproject.toml</p>
    </blockquote>
    <pre><code>[tool<span class="hljs-selector-class">.pytest</span><span class="hljs-selector-class">.ini_options</span>]
    
    markers = [
        <span class="hljs-string">"smoke: marker for smoke tests"</span>,
        <span class="hljs-string">"regression: marker for regression tests"</span>,
        <span class="hljs-string">"win10"</span>
    ]
    </code></pre><blockquote>
    <p>test_fixture81.py</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture(scope="function")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span>:</span>
    
    <span class="hljs-meta">    @pytest.mark.smoke</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
    <span class="hljs-meta">    @pytest.mark.smoke</span>
    <span class="hljs-meta">    @pytest.mark.win10</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    </code></pre>
    <p>Чтобы запустить только smoke-тесты для Windows 10, нужно использовать логическое И:</p>
    <pre><code class="lang-shell">pytest <span class="hljs-_">-s</span> -v -m <span class="hljs-string">"smoke and win10"</span> test_fixture81.py
    </code></pre>
    <p>Должен выполниться тест test_guest_should_see_basket_link_on_the_main_page.</p>
    <h2 id="-">Пропуск тестов</h2>
    <p>PyTest предоставляет встроенные маркеры, которые позволяют пропустить тест во время сбора тестов.
    Вам не нужно объявлять эти маркеры в <code>pyproject.toml</code>.</p>
    <p>Чтобы пропустить тест необходимо отметить его как <code>@pytest.mark.skip</code>:</p>
    <blockquote>
    <p>test_fixture_skip.py</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture(scope="function")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span><span class="hljs-params">()</span>:</span>
    
    <span class="hljs-meta">    @pytest.mark.skip(reason="Reason to skip test")</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    </code></pre>
    <p>Хорошей практикой является явное указание причины пропуска теста <code>@pytest.mark.skip(reason=&quot;Reason to skip test&quot;)</code>.</p>
    <p>Команда для отображения всех зарегистрированных меток:</p>
    <pre><code class="lang-shell">pytest <span class="hljs-comment">--markers</span>
    </code></pre>
    <h2 id="xfail-">XFail: помечать тест как ожидаемо падающий</h2>
    <h3 id="-">Отметить тест как падающий</h3>
    <p>Давайте включим тест в наш тестовый класс, который проверяет, присутствует ли кнопка «Избранное».</p>
    <pre><code class="lang-python"><span class="hljs-symbol">def</span> test_guest_should_see_search_button_on_the_main_page(<span class="hljs-keyword">self, </span><span class="hljs-keyword">browser):
    </span>    <span class="hljs-keyword">browser.get(link)
    </span>    <span class="hljs-keyword">browser.find_element(By.CSS_SELECTOR, </span><span class="hljs-string">"button.favorite"</span>)
    </code></pre>
    <p>Допустим, должна быть кнопка «Избранное», но из-за недавних изменений кода ее больше нет. Ожидая, пока разработчики
    исправят проблему, мы по-прежнему хотим, чтобы все наши тесты прошли успешно, но мы хотим, чтобы неудачный тест был
    помечен соответствующим образом, чтобы мы могли не забыть проверить его позже. Поэтому давайте добавим маркер
    <code>@pytest.mark.xfail</code> к проваленному тесту.</p>
    <blockquote>
    <p>test_fixture10.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture(scope="function")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span><span class="hljs-params">()</span>:</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    
    <span class="hljs-meta">    @pytest.mark.xfail</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_search_button_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"button.favorite"</span>)
    </code></pre>
    <p>Запустим тесты:</p>
    <pre><code class="lang-shell"><span class="hljs-selector-tag">pytest</span> <span class="hljs-selector-tag">-v</span> <span class="hljs-selector-tag">test_fixture10</span><span class="hljs-selector-class">.py</span>
    </code></pre>
    <p>Если ошибка устранена, тест, отмеченный <code>@pytest.mark.xfail</code>, теперь будет помечен как <code>XPASS</code> (неожиданно пройденный).
    На этом этапе можно удалить отметку xfail. Кроме того, к отметке xfail можно добавить параметр Reason. Чтобы просмотреть
    это сообщение в консоли, во время запуска необходимо добавить параметр <code>pytest -rx</code>.</p>
    <blockquote>
    <p>test_fixture10a.py</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture(scope="function")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span><span class="hljs-params">()</span>:</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    
    <span class="hljs-meta">    @pytest.mark.xfail(reason="fixing this bug right now")</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_search_button_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"button.favorite"</span>)
    </code></pre>
    <p>Запустим тесты:</p>
    <pre><code class="lang-shell"><span class="hljs-selector-tag">pytest</span> <span class="hljs-selector-tag">-rx</span> <span class="hljs-selector-tag">-v</span> <span class="hljs-selector-tag">test_fixture10a</span><span class="hljs-selector-class">.py</span>
    </code></pre>
    <h3 id="xpass-">XPASS-тесты</h3>
    <p>Поменяем селектор в последнем тесте, чтобы тест начал проходить.</p>
    <blockquote>
    <p>test_fixture10b.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-meta">@pytest.fixture(scope="function")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage1</span><span class="hljs-params">()</span>:</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_basket_link_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">".basket-mini .btn-group &gt; a"</span>)
    
    <span class="hljs-meta">    @pytest.mark.xfail(reason="fixing this bug right now")</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_search_button_on_the_main_page</span><span class="hljs-params">(self, browser)</span>:</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"input.btn.btn-default"</span>)
    </code></pre>
    <p>Запустите тесты.
    Здесь мы добавили символ X в параметр -r, чтобы получить подробную информацию по XPASS-тестам:</p>
    <pre><code class="lang-shell"><span class="hljs-selector-tag">pytest</span> <span class="hljs-selector-tag">-rX</span> <span class="hljs-selector-tag">-v</span> <span class="hljs-selector-tag">test_fixture10b</span><span class="hljs-selector-class">.py</span>
    </code></pre>
    <p>Дополнительно об использовании этих меток можно почитать в документации:
    <a href="https://pytest.org/en/stable/how-to/skipping.html">How to use skip and xfail to deal with tests that cannot succeed</a></p>
    <h2 id="-">Задание: пропуск тестов</h2>
    <p>Найдите в <a href="">документации по xfail</a> параметр, который в случае неожиданного прохождения теста,
    помеченного как xfail, отметит в отчете этот тест как упавший.
    Пометьте таким образом первый тест из этого тестового набора.</p>
    <blockquote>
    <p>test_xfail.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_succeed</span><span class="hljs-params">()</span>:</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
    
    <span class="hljs-meta">@pytest.mark.xfail</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_not_succeed</span><span class="hljs-params">()</span>:</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">False</span>
    
    
    <span class="hljs-meta">@pytest.mark.skip</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_skipped</span><span class="hljs-params">()</span>:</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">False</span>
    </code></pre>
    <h2 id="-">Задание: запуск тестов</h2>
    <p>Отметьте только те тестовые методы, которые будут найдены и выполнены PyTest при запуске следующей команды:</p>
    <pre><code class="lang-shell">pytest -v -m <span class="hljs-string">"smoke and not beta_users"</span> test_task_ru<span class="hljs-symbol">n_1</span>.py
    </code></pre>
    <blockquote>
    <p>test_task_run_1.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMainPage</span><span class="hljs-params">()</span>:</span>
        <span class="hljs-comment"># номер 1</span>
    <span class="hljs-meta">    @pytest.mark.xfail</span>
    <span class="hljs-meta">    @pytest.mark.smoke</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_login</span><span class="hljs-params">(self, browser)</span>:</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
        <span class="hljs-comment"># номер 2</span>
    <span class="hljs-meta">    @pytest.mark.regression</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_add_book_from_catalog_to_basket</span><span class="hljs-params">(self, browser)</span>:</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBasket</span><span class="hljs-params">()</span>:</span>
        <span class="hljs-comment"># номер 3</span>
    <span class="hljs-meta">    @pytest.mark.skip(reason="not implemented yet")</span>
    <span class="hljs-meta">    @pytest.mark.smoke</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_go_to_payment_page</span><span class="hljs-params">(self, browser)</span>:</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
        <span class="hljs-comment"># номер 4</span>
    <span class="hljs-meta">    @pytest.mark.smoke</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_see_total_price</span><span class="hljs-params">(self, browser)</span>:</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
    
    <span class="hljs-meta">@pytest.mark.skip</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBookPage</span><span class="hljs-params">()</span>:</span>
        <span class="hljs-comment"># номер 5</span>
    <span class="hljs-meta">    @pytest.mark.smoke</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_add_book_to_basket</span><span class="hljs-params">(self, browser)</span>:</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
        <span class="hljs-comment"># номер 6</span>
    <span class="hljs-meta">    @pytest.mark.regression</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_see_book_price</span><span class="hljs-params">(self, browser)</span>:</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
    
    <span class="hljs-comment"># номер 7</span>
    <span class="hljs-meta">@pytest.mark.beta_users</span>
    <span class="hljs-meta">@pytest.mark.smoke</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_open_gadget_catalogue</span><span class="hljs-params">(browser)</span>:</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    </code></pre>

    <h1 id="pytest-">PyTest — параметризация, конфигурирование, плагины</h1>
    <h2 id="conftest-py-">Conftest.py — конфигурация тестов</h2>
    <p>В предыдущем разделе мы создали фикстуру браузера <code>browser</code>, которая создает экземпляр браузера для тестирования в
    текущем файле.
    Однако, когда у нас есть несколько тестовых файлов, может быть неудобно переопределять эту фикстуру в каждом файле.
    Чтобы избежать этого повторения и сохранить часто используемые фикстуры и глобальные настройки, мы можем использовать
    файл <code>conftest.py</code>, который должен находиться в каталоге верхнего уровня нашего тестового проекта.
    Хотя можно создавать
    дополнительные файлы <code>conftest.py</code> в других каталогах, любые настройки, определенные в этих файлах, будут применяться
    только к тестам в подкаталогах.</p>
    <p>Мы можем создать файл <code>conftest.py</code> в каталоге верхнего уровня нашего тестового проекта и переместить туда фикстуру
    браузера для хранения часто используемых фикстур и глобальных настроек. Благодаря этому файл с тестами становится более
    лаконичным.</p>
    <blockquote>
    <p>conftest.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    
    
    <span class="hljs-meta">@pytest.fixture(scope='function')</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        browser.quit()
    </code></pre>
    <p>С добавлением файла <code>conftest.py</code> в корневой каталог тестового проекта доступ к фикстуре браузера теперь возможен для
    всех тестовых файлов.
    Фикстура передается тестовому методу в качестве аргумента, что позволяет легко повторно использовать
    вспомогательные функции в разных частях проекта, независимо от того, сколько тестовых файлов создано.</p>
    <blockquote>
    <p>test_conftest.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-symbol">link</span> = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-symbol">def</span> test_guest_should_see_login_link(<span class="hljs-keyword">browser):
    </span>    <span class="hljs-keyword">browser.get(link)
    </span>    <span class="hljs-keyword">browser.find_element(By.CSS_SELECTOR, </span><span class="hljs-string">"#login_link"</span>)
    </code></pre>
    <h3 id="-">ОЧЕНЬ ВАЖНО!</h3>
    <p>Крайне важно понять важный аспект поведения файлов конфигурации. PyTest автоматически обнаруживает и загружает файлы
    <code>conftest.py</code> в каталог с тестами. Если у вас все тестовые сценарии в одной папке, будьте осторожны и не запускайте
    тесты из папки с тестами, так как это может помешать автоматическому обнаружению файлов conftest.py:</p>
    <pre><code>tests/
    ├── conftest<span class="hljs-selector-class">.py</span>
    ├── subfolder
    │   └── conftest<span class="hljs-selector-class">.py</span>
    │   └── test_abs<span class="hljs-selector-class">.py</span>
    
    следует избегать!
    </code></pre><p>Если тесты запускаются из каталога, содержащего два файла conftest.py, будут применены оба файла, что может привести к
    непредвиденным ошибкам и конфликтам.</p>
    <p>Этот метод можно использовать для переопределения различных фикстур, но для знакомства рекомендуется придерживаться
    одного файла для каждого проекта/задачи и сохранять их в горизонтальном порядке, например:</p>
    <pre><code>selenium_course_solutions/
    ├── section3
    │   └── conftest<span class="hljs-selector-class">.py</span>
    │   └── test_languages<span class="hljs-selector-class">.py</span>
    ├── section4 
    │   └── conftest<span class="hljs-selector-class">.py</span>
    │   └── test_main_page<span class="hljs-selector-class">.py</span>
    
    правильно!
    </code></pre><p>Подробнее можете ознакомиться в документации:
    <a href="https://docs.pytest.org/en/7.1.x/how-to/fixtures.html?highlight=fixture%20folder#override-a-fixture-on-a-folder-conftest-level">Override a fixture on a folder (conftest) level</a></p>
    <h2 id="-">Параметризация тестов</h2>
    <p>Используя декоратор <code>@pytest.mark.parametrize()</code> в PyTest, вы можете запустить один и тот же тест с различными входными
    параметрами. Например, предположим, что наш веб-сайт доступен на разных языках. Мы можем написать тест, который
    проверяет, отображается ли ссылка на форму входа для русской и английской версий главной страницы сайта. Мы можем
    передать в наш тест ссылки на русскую и английскую версии главной страницы сайта.</p>
    <p>Чтобы использовать декоратор <code>@pytest.mark.parametrize()</code>, вам необходимо указать параметр,
    который необходимо изменить, и список значений параметров.
    Тест также должен передавать параметр в качестве аргумента. Важно отметить, что при
    использовании декоратора имя параметра заключается в кавычки, а в списке тестовых аргументов кавычки не нужны.</p>
    <blockquote>
    <p>test_fixture7.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    <span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    
    
    <span class="hljs-meta">@pytest.fixture(scope="function")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">()</span>:</span>
        print(<span class="hljs-string">"\nstart browser for test.."</span>)
        browser = webdriver.Chrome()
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    
    
    <span class="hljs-meta">@pytest.mark.parametrize('language', ["ru", "en-gb"])</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(browser, language)</span>:</span>
        link = f<span class="hljs-string">"http://selenium1py.pythonanywhere.com/{language}/"</span>
        browser.get(link)
        browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
    </code></pre>
    <p>Запустите тест:</p>
    <pre><code class="lang-shell">pytest <span class="hljs-_">-s</span> -v test_fixture7.py
    </code></pre>
    <p>При запуске теста вы увидите два запущенных теста, при этом имя каждого теста отображает параметр, с которым он был
    запущен, заключенный в квадратные скобки. Такой подход помогает увеличить количество проверок по схожим сценариям без
    дублирования кода.</p>
    <p>Чтобы указать параметры для всех тестов в классе, перед объявлением класса следует поставить знак параметризации. Это
    применит указанные параметры ко всем тестам в классе:</p>
    <pre><code class="lang-python">@pytest.mark.parametrize(<span class="hljs-string">'language'</span>, [<span class="hljs-string">"ru"</span>, <span class="hljs-string">"en-gb"</span>])
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLogin</span>:</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser, language)</span></span>:
            link = f<span class="hljs-string">"http://selenium1py.pythonanywhere.com/{language}/"</span>
            browser.get(link)
            browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
            <span class="hljs-comment"># этот тест запустится 2 раза</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_navbar_element</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser, language)</span></span>:
            pass
            <span class="hljs-comment"># этот тест тоже запустится дважды</span>
    </code></pre>
    <p>Дополнительно ознакомьтесь с документацией
    <a href="https://docs.pytest.org/en/latest/how-to/parametrize.html">How to parametrize fixtures and test functions</a></p>
    <h2 id="-firefox-selenium-geckodriver">Установка Firefox и Selenium-драйвера geckodriver</h2>
    <p>До сих пор мы выполняли наши тесты только в браузере Chrome. Однако что, если мы хотим протестировать наше
    веб-приложение и в других браузерах? В таком сценарии мы можем запускать одни и те же тесты в разных браузерах, указав
    имя браузера при запуске тестов. Например, мы можем выбрать Firefox в качестве второго браузера, поскольку он широко
    используется и может работать на любой платформе. Чтобы запустить тесты в конкретном браузере, нам нужно указать
    параметр <code>browser_name</code> при запуске с помощью следующей команды:</p>
    <pre><code class="lang-shell">pytest -s -v <span class="hljs-comment">--browser_name=firefox test_cmd.py</span>
    </code></pre>
    <p>Установите последнюю версию браузера Firefox для вашей платформы:
    <a href="https://www.mozilla.org/en-US/firefox/new/">Firefox Browser</a></p>
    <p>Selenium-драйвер для Firefox носит название geckodriver.</p>
    <p>Последнюю версию драйвера можно скачать <a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a></p>
    <p>Ознакомьтесь с <a href="https://selenium-python.com/install-geckodriver">инструкцией по установке драйвера</a> и не забудьте
    добавить его в PATH для пользователей с ОС Windows.</p>
    <h2 id="conftest-py-">Conftest.py и передача параметров в командной строке</h2>
    <p>На этом этапе мы разберемся, как настраивать тестовые среды, передавая параметры через командную
    строку с помощью встроенной фикстуры request, которая может получать данные о текущем выполняемом тесте. Это может
    позволить нам хранить дополнительные данные в отчете и выполнять ряд других полезных задач.</p>
    <p>Это делается с помощью встроенной функции pytest_addoption и фикстуры request. Сначала добавляем в файле conftest
    обработчик опции в функции pytest_addoption, затем напишем фикстуру, которая будет обрабатывать переданные в опции
    данные.</p>
    <p>Подробнее можно узнать в
    документации: <a href="https://docs.pytest.org/en/latest/example/simple.html?highlight=addoption">pytest_addoption</a></p>
    <p>Добавим логику обработки командной строки в файл <code>conftest.py</code>.
    Мы можем получить значение параметра с помощью следующей команды:</p>
    <pre><code class="lang-python">browser_name = request<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.getoption</span>(<span class="hljs-string">"browser_name"</span>)
    </code></pre>
    <blockquote>
    <p>conftest.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-keyword">import</span> pytest
    <span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pytest_addoption</span><span class="hljs-params">(parser)</span>:</span>
        parser.addoption(<span class="hljs-string">'--browser_name'</span>, action=<span class="hljs-string">'store'</span>, default=<span class="hljs-keyword">None</span>,
                         help=<span class="hljs-string">"Choose browser: chrome or firefox"</span>)
    
    
    <span class="hljs-meta">@pytest.fixture(scope="function")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">browser</span><span class="hljs-params">(request)</span>:</span>
        browser_name = request.config.getoption(<span class="hljs-string">"browser_name"</span>)
        browser = <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> browser_name == <span class="hljs-string">"chrome"</span>:
            print(<span class="hljs-string">"\nstart chrome browser for test.."</span>)
            browser = webdriver.Chrome()
        <span class="hljs-keyword">elif</span> browser_name == <span class="hljs-string">"firefox"</span>:
            print(<span class="hljs-string">"\nstart firefox browser for test.."</span>)
            browser = webdriver.Firefox()
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> pytest.UsageError(<span class="hljs-string">"--browser_name should be chrome or firefox"</span>)
        <span class="hljs-keyword">yield</span> browser
        print(<span class="hljs-string">"\nquit browser.."</span>)
        browser.quit()
    </code></pre>
    <blockquote>
    <p>test_parser.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-symbol">link</span> = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-symbol">def</span> test_guest_should_see_login_link(<span class="hljs-keyword">browser):
    </span>    <span class="hljs-keyword">browser.get(link)
    </span>    <span class="hljs-keyword">browser.find_element(By.CSS_SELECTOR, </span><span class="hljs-string">"#login_link"</span>)
    </code></pre>
    <p>Если вы теперь запустите тесты без параметра, то получите ошибку:</p>
    <pre><code class="lang-shell">pytest <span class="hljs-_">-s</span> -v test_parser.py
    </code></pre>
    <pre><code><span class="hljs-keyword">ERROR </span>_pytest.config.exceptions.UsageError: --browser_name should be chrome or firefox
    </code></pre><p>Чтобы избежать необходимости каждый раз указывать параметр <code>--browser_name</code> в командной строке, мы можем установить для
    параметра значение по умолчанию.
    Это можно сделать, добавив следующую строку в файл <code>conftest.py</code>:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pytest_addoption</span><span class="hljs-params">(parser)</span></span>:
        parser.addoption(<span class="hljs-string">'--browser_name'</span>, action=<span class="hljs-string">'store'</span>, default=<span class="hljs-string">'chrome'</span>, help=<span class="hljs-string">"Choose browser: chrome or firefox"</span>)
    </code></pre>
    <p>Запустите тесты на Chrome:</p>
    <pre><code class="lang-shell">pytest -s -v <span class="hljs-comment">--browser_name=chrome test_parser.py</span>
    </code></pre>
    <p>И на Firefox:</p>
    <pre><code class="lang-shell">pytest -s -v <span class="hljs-comment">--browser_name=firefox test_parser.py</span>
    </code></pre>
    <p>Тесты должны выполняться в разных браузерах.</p>
    <h2 id="-">Плагины и перезапуск тестов</h2>
    <p>PyTest имеет широкий спектр
    доступных <a href="https://docs.pytest.org/en/latest/explanation/flaky.html?highlight=plugins#plugins">плагинов</a>, которые могут
    расширить функциональность фреймворка.
    Полный список доступных плагинов можно найти <a href="https://docs.pytest.org/en/latest/reference/plugin_list.html">здесь</a>.</p>
    <p>Обсудим еще одну распространенную проблему, часто возникающую при написании сквозных тестов в Selenium, — flaky-тесты
    или «мигающие» автотесты. Это тесты, которые иногда проваливаются из-за внешних факторов, не зависящих от нас, или
    из-за трудно воспроизводимых ошибок, хотя в большинстве случаев они успешно проходят. Это может произойти во время
    тестов из-за одновременных обновлений сайта, проблем с сетью или странных совпадений. Несмотря на то, что устранение
    таких проблем и выявление причин ошибок необходимо, в реальном мире это часто требует значительных усилий. Таким
    образом, чтобы убедиться, что тест действительно обнаружил ошибку и не произошел случайный сбой, мы можем повторить
    неудачный тест.</p>
    <p>Реализация этого — простой процесс. Мы будем использовать плагин
    <a href="https://pypi.org/project/pytest-rerunfailures/">pytest-rerunfailures</a>.</p>
    <p>Изначально нам нужно установить плагин в нашу виртуальную среду. После установки плагин будет автоматически обнаружен
    PyTest, и мы сможем использовать его возможности без внесения дополнительных изменений в код:</p>
    <pre><code class="lang-shell">pip <span class="hljs-keyword">install</span> pytest-rerunfailures
    </code></pre>
    <p>Чтобы установить количество повторных запусков неудачных тестов, вы можете добавить параметр командной строки: <code>--reruns
    n</code>, где <code>n</code> представляет количество повторных запусков. Если тесты пройдены на любом из повторных запусков, тестовый
    запуск будет считаться успешным, а количество повторных запусков будет отображаться в отчете для дальнейшего анализа
    проблемных тестов.</p>
    <p>Дополнительно мы указали параметр <code>--tb=line</code>, чтобы сократить лог с результатами теста:</p>
    <pre><code class="lang-shell"><span class="hljs-comment">pytest</span> <span class="hljs-literal">-</span><span class="hljs-comment">v</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">tb=line</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">reruns</span> <span class="hljs-comment">1</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">browser_name=chrome</span> <span class="hljs-comment">test_rerun</span><span class="hljs-string">.</span><span class="hljs-comment">py</span>
    </code></pre>
    <p>Давайте напишем два теста: один из них будет проходить, а другой — нет. Посмотрим, как выглядит перезапуск.</p>
    <blockquote>
    <p>test_rerun.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-symbol">from</span> <span class="hljs-keyword">selenium.webdriver.common.by </span><span class="hljs-meta">import</span> <span class="hljs-keyword">By
    </span>
    <span class="hljs-symbol">link</span> = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    <span class="hljs-symbol">def</span> test_guest_should_see_login_link_pass(<span class="hljs-keyword">browser):
    </span>    <span class="hljs-keyword">browser.get(link)
    </span>    <span class="hljs-keyword">browser.find_element(By.CSS_SELECTOR, </span><span class="hljs-string">"#login_link"</span>)
    
    
    <span class="hljs-symbol">def</span> test_guest_should_see_login_link_fail(<span class="hljs-keyword">browser):
    </span>    <span class="hljs-keyword">browser.get(link)
    </span>    <span class="hljs-keyword">browser.find_element(By.CSS_SELECTOR, </span><span class="hljs-string">"#magic_link"</span>)
    </code></pre>
    <p>Вы увидите отчет о запуске тестов: &quot;1 failed, 1 passed, 1 rerun in 50.16s&quot;, следовательно первоначально провалившийся
    тест был перезапущен.</p>
    <h2 id="-">Запуск автотестов для разных языков интерфейса</h2>
    <p>Цель: научиться запускать автотесты для разных локалей, т.е. для разных языков интерфейсов.</p>
    <p>На предыдущем шаге мы запускали автотесты для разных языков, используя параметризацию с разными ссылками, но этот метод
    становится сложным в управлении при работе с большим количеством тестов. Чтобы решить эту проблему, мы можем настроить
    сервер так, чтобы он определял язык интерфейса для отображения на основе данных браузера. Когда пользователь делает
    запрос на сервер, браузер отправляет данные о языке пользователя через параметр <code>accept-language</code> в заголовках
    (заголовок запроса).
    Если сервер получит запрос с заголовком <code>{accept-language: ru, en}</code>, он отобразит пользователю русскоязычный
    интерфейс сайта. Если русский язык не поддерживается, то будет показан следующий язык из списка. Этот процесс аналогичен
    установке предпочтительного языка в настройках вашего браузера.</p>
    <p>Чтобы указать язык браузера с помощью WebDriver, используйте класс <code>Options</code> и метод <code>add_experimental_option</code>, как
    указано в примере ниже:</p>
    <pre><code class="lang-python"><span class="hljs-keyword">from</span> selenium.webdriver.chrome.<span class="hljs-keyword">options</span> <span class="hljs-keyword">import</span> <span class="hljs-keyword">Options</span> as chromeOptions
    
    <span class="hljs-keyword">options</span> = chromeOptions()
    <span class="hljs-keyword">options</span>.add_experimental_option(<span class="hljs-string">'prefs'</span>, {<span class="hljs-string">'intl.accept_languages'</span>: language})
    browser = webdriver.Chrome(<span class="hljs-keyword">options</span>=<span class="hljs-keyword">options</span>)
    </code></pre>
    <pre><code class="lang-python"><span class="hljs-keyword">from</span> selenium.webdriver.firefox.<span class="hljs-keyword">options</span> <span class="hljs-keyword">import</span> <span class="hljs-keyword">Options</span> as firefoxOptions
    
    <span class="hljs-keyword">options</span> = firefoxOptions()
    <span class="hljs-keyword">options</span>.set_preference(<span class="hljs-string">'intl.accept_languages'</span>, language)
    browser = webdriver.Firefox(<span class="hljs-keyword">options</span>=<span class="hljs-keyword">options</span>)
    </code></pre>
    <h2 id="-">Задание: запуск автотестов для разных языков интерфейса</h2>
    <p>Поскольку мы стремимся обеспечить бесперебойную работу создаваемого нами интернет-магазина для пользователей из всех
    стран, нам необходимо протестировать многоязычное решение, запустив набор автотестов для каждого языка. Как разработчик
    автотестов, вы должны создать решение, позволяющее выполнять автотесты для разных пользовательских языков, указав нужный
    язык в командной строке.</p>
    <ol>
    <li>Создайте GitHub-репозиторий, в котором будут лежать файлы conftest.py и test_items.py.</li>
    <li>Добавьте в файл conftest.py обработчик, который считывает из командной строки параметр language.</li>
    <li>Реализуйте в файле conftest.py логику запуска браузера с указанным языком пользователя. Браузер должен объявляться в
    фикстуре browser и передаваться в тест как параметр.</li>
    <li>В файл test_items.py напишите тест, который проверяет, что страница товара на сайте содержит кнопку добавления в
    корзину. Например, можно проверять товар, доступный
    по <a href="http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/">http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/</a>.</li>
    <li>Тест должен запускаться с параметром language следующей командой:
    <code>pytest --language=es test_items.py</code>
    и проходить успешно. Достаточно, чтобы код работал только для браузера Сhrome.</li>
    </ol>

    <h1 id="-">Ссылки на дополнительные материалы</h1>
    <h2 id="-">Теория автотестов</h2>
    <ul>
    <li><a href="https://habr.com/ru/articles/358950/">Пирамида тестов на практике</a></li>
    <li><a href="https://habr.com/ru/articles/269759/">PyTest</a></li>
    <li><a href="https://habr.com/ru/companies/yandex/articles/242795/">Как в Яндексе используют PyTest и другие фреймворки для функционального тестирования</a></li>
    <li><a href="https://habr.com/ru/articles/426699/">Python Testing with pytest. Просто, Быстро, Эффективно и Масштабируемо. Предисловие и Ведение</a></li>
    <li><a href="https://habr.com/ru/articles/448786/">Python Testing с pytest. ГЛАВА 3 pytest Fixtures</a></li>
    </ul>
    <h2 id="-">Документация</h2>
    <ul>
    <li><a href="https://docs.python.org/3/library/unittest.html">unittest docs</a></li>
    <li><a href="https://docs.pytest.org/en/7.1.x/getting-started.html">pytest docs</a></li>
    <li><a href="https://docs.pytest.org/en/stable/explanation/goodpractices.html#conventions-for-python-test-discovery">Conventions for Python test discovery</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Test_fixture#Software">Test fixtures</a></li>
    <li><a href="https://docs.pytest.org/en/latest/how-to/xunit_setup.html">How to implement xunit-style set-up</a></li>
    <li><a href="https://docs.pytest.org/en/latest/how-to/fixtures.html#adding-finalizers-directly">Adding finalizers directly</a></li>
    <li><a href="https://habr.com/ru/articles/132554/">Как работает yield</a></li>
    <li><a href="https://docs.pytest.org/en/stable/explanation/fixtures.html">About fixtures</a></li>
    <li><a href="https://pytest.org/en/stable/how-to/skipping.html">How to use skip and xfail to deal with tests that cannot succeed</a></li>
    <li><a href="https://docs.pytest.org/en/latest/reference/reference.html#pytest.mark.xfail">xfail</a></li>
    <li><a href="https://docs.pytest.org/en/7.1.x/how-to/fixtures.html?highlight=fixture%20folder#override-a-fixture-on-a-folder-conftest-level">Override a fixture on a folder (conftest) level</a></li>
    <li><a href="https://docs.pytest.org/en/latest/how-to/parametrize.html">How to parametrize fixtures and test functions</a></li>
    <li><a href="https://docs.pytest.org/en/latest/example/simple.html?highlight=addoption">pytest_addoption</a></li>
    </ul>
    <h2 id="geckodriver">geckodriver</h2>
    <ul>
    <li><a href="https://www.mozilla.org/en-US/firefox/new/">Firefox Browser</a></li>
    <li><a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a></li>
    <li><a href="https://selenium-python.com/install-geckodriver">Установка драйвера geckodriver для Firefox Selenium</a></li>
    </ul>
    <h2 id="pytest">PyTest</h2>
    <ul>
    <li><a href="https://docs.pytest.org/en/latest/explanation/flaky.html?highlight=plugins#plugins">плагины</a></li>
    <li><a href="https://docs.pytest.org/en/latest/reference/plugin_list.html">Plugin List</a></li>
    <li><a href="https://pypi.org/project/pytest-rerunfailures/">pytest-rerunfailures</a></li>
    </ul>

    <hr>

    <h1 id="-page-object-">Что такое Page Object?</h1>
    <p>В этой части курса мы будем использовать принципы объектно-ориентированного программирования и вам не помешает освежить в
    памяти основные принципы ООП по ссылкам на дополнительные материалы.</p>
    <h2 id="code-style">Code Style</h2>
    <p>В сообществе программистов существует широко распространенное соглашение, известное как «стиль кода» (Code
    Style). Стиль кода
    охватывает все аспекты, не связанные с функциональностью самого кода, такие как форматирование, имена переменных и
    функций, и другие подобные соображения. Python, в частности, хвалят за его удобочитаемость, но даже этот язык может
    превратиться в нечитаемый беспорядок, если его не поддерживать должным образом. Нечитаемый код представляет опасность,
    поскольку становится трудным для понимания и может вызвать путаницу в будущем как у вас, так и у других. С другой
    стороны, хорошо написанный код предлагает множество преимуществ, включая экономию времени при исправлении ошибок, более
    плавную адаптацию новых членов команды и более эффективную разработку кода в целом. Поэтому поддержание читабельности
    кода всегда должно быть главным приоритетом.</p>
    <p>В предыдущих частях мы кратко обсуждали эту тему, а теперь более уместно углубиться в неё более подробно.</p>
    <h3 id="-">Отступы</h3>
    <p>Отступы являются важным аспектом синтаксиса Python, поскольку они означают вложенность блоков, таких как тело условного
    оператора или цикла. Важно отметить, что на следующих шагах должны поддерживаться правильные отступы для всех функций
    внутри класса.</p>
    <pre><code class="lang-python"><span class="hljs-comment"># Тест вне класса, отступ не нужен.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_equal</span><span class="hljs-params">(a, b)</span>:</span>
        <span class="hljs-keyword">assert</span> a == b, f<span class="hljs-string">'Expected {a=} to be equal {b=}'</span>
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInteractionsPage</span>:</span>
        <span class="hljs-string">"""Class represents Interactions tab.
        Sortable
        Selectable,
        Resizable,
        Droppable
        """</span>
    
        <span class="hljs-comment"># Класс внутри класса. Необходим отступ, чтобы показать вложенность.</span>
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSortablePage</span>:</span>
            <span class="hljs-string">"""Class represents Sortable tab tests."""</span>
            sortable_page_link = <span class="hljs-string">'https://demoqa.com/sortable'</span>
    
            <span class="hljs-comment"># Тест внутри вложенного класса. Необходим отступ.</span>
            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_order_of_list_can_be_changed</span><span class="hljs-params">(self, driver)</span>:</span>
                <span class="hljs-string">"""Test order of list can be changed."""</span>
                sortable_page = SortablePage(driver, self.sortable_page_link)
                sortable_page.open()
                order_of_list_before = sortable_page.get_items_of_list()
                sortable_page.change_list_order()
                order_of_list_after = sortable_page.get_items_of_list()
                <span class="hljs-keyword">assert</span> order_of_list_before != order_of_list_after, \
                <span class="hljs-string">'Expected order of list to be different.'</span> \
                f<span class="hljs-string">'Order before: {order_of_list_before}'</span> \
                f<span class="hljs-string">'Order after: {order_of_list_after}'</span>
    </code></pre>
    <h3 id="-">Имена переменных и функций</h3>
    <p>Именование — важнейший элемент написания читаемого кода. Будь то объявление переменных, определение функций или
    присвоение имен классам, важно убедиться, что назначенные имена имеют смысл и точно отражают суть соответствующих
    объектов. Избегайте использования однобуквенных или расплывчатых имен, таких как var1, x, y, my_function, class2 и т. д.
    Цель состоит в том, чтобы создать код, который говорит сам за себя и не требует дополнительных объяснений. Если вы
    обнаружите, что хотите написать поясняющий комментарий, это хорошая возможность реорганизовать код и устранить
    необходимость в комментариях за счет улучшения соглашений об именах.</p>
    <p>Как правило, компании имеют свои внутренние соглашения относительно именования переменных. Однако общие отраслевые
    правила именования переменных относительно одинаковы в разных организациях.</p>
    <h4 id="-snake_case-">Функции и методы пишутся с помощью snake_case:</h4>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_revertable_draggable_will_return_to_current_position_after_dragging</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, driver)</span></span>:
        pass
    </code></pre>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">switch_to_frame</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, frame_locator, timeout=<span class="hljs-number">5</span>)</span></span>:
        pass
    </code></pre>
    <h4 id="-camelcase-">Классы пишут с помощью CamelCase:</h4>
    <pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccordianPage</span><span class="hljs-params">(BasePage)</span>:</span>
        <span class="hljs-keyword">pass</span>
    </code></pre>
    <pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAccordianPage</span>:
        <span class="hljs-type">pass</span></span>
    </code></pre>
    <p>Константы пишут в стиле UPPERCASE:</p>
    <pre><code class="lang-python"><span class="hljs-attr">NO_ERRORS_TEXT</span> = <span class="hljs-string">'No errors'</span>
    </code></pre>
    <h4 id="-">Максимальная простота кода</h4>
    <p>Распространенные принципы DRY (<a href="https://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself">Don&#39;t repeat yourself</a>) и
    KISS (<a href="https://en.wikipedia.org/wiki/KISS_principle">Keep itsimple, stupid</a>).</p>
    <ul>
    <li>Старайтесь писать как можно более простой код, избегая ненужной сложности.</li>
    <li>Сведите к минимуму использование сложных конструкций, таких как лямбда-выражения, карты и другие сложные методы, если
    только они не являются действительно необходимыми.</li>
    <li>Всякий раз, когда у вас есть возможность заменить часть кода более простой альтернативой, сделайте это.</li>
    <li>Подчеркните линейную структуру кода, так как ее легче понять и следовать.</li>
    <li>Избегайте чрезмерной вложенности блоков кода, так как это может затруднить чтение кода.</li>
    <li>По возможности избегайте дублирования логики. Если вы заметили повторяющиеся шаблоны, выделите эту логику в отдельный
    компонент или функцию, чтобы избежать повторения.</li>
    <li>По возможности предпочтите явный код неявному коду. Лучше иметь четкий и понятный код, чем полагаться на скрытое или
    магическое поведение.</li>
    </ul>
    <h2 id="code-style-">Code Style в автотестах</h2>
    <p>Важные принципы написания автотестов:</p>
    <ul>
    <li><p>Стремитесь поддерживать высокий уровень линейности в своем тестовом коде, сводя к минимуму использование ветвлений и
    циклов в тестовых примерах. Если вы обнаружите, что вам нужно ввести условные операторы (например, оператор «if») в
    свои тесты, рассмотрите возможность разделения теста на два отдельных теста или внесите изменение тестовой среды,
    чтобы исключить необходимость ветвления.</p>
    <ul>
    <li>Уменьшая число ветвлений и сохраняя линейность тестового кода, вы можете улучшить
    читабельность и удобство сопровождения ваших тестов, упрощая их понимание и устранение неполадок.</li>
    </ul>
    </li>
    <li><p>Сведите к минимуму использование зависимых тестов, основанных на определенном порядке выполнения. По мере расширения
    набора тестов вы можете захотеть запускать тесты одновременно в нескольких потоках, что усложняется при использовании
    зависимых тестов. Кроме того, зависимые тесты могут привести к проблемам с надежностью.</p>
    <ul>
    <li>Избегая зависимостей между тестами, вы обеспечиваете большее распараллеливание и повысите общую надежность набора
    тестов. Каждый тест должен быть автономным и независимым, что обеспечивает гибкость выполнения и более точные
    результаты тестирования.
    Подробнее: <a href="http://barancev.github.io/test-deps-are-evil/">...почему зависимости между тестами это плохо?</a></li>
    </ul>
    </li>
    <li><p>Стремитесь сделать ваши тесты самодостаточными и независимыми от конкретного контента. Вместо этого сосредоточьтесь на
    подготовке необходимых данных в самом тесте и обеспечьте надлежащую очистку после завершения теста. Рекомендуется
    использовать чистые браузеры и создавать новые учетные записи пользователей для повышения воспроизводимости.</p>
    <ul>
    <li>Генерируя необходимые данные и управляя тестовой средой в тестовом коде, вы уменьшаете зависимость от внешних
    факторов, делая ваши тесты более надежными и воспроизводимыми при различных исполнениях. Такой подход обеспечивает
    лучшую изоляцию и повышает общую стабильность набора тестов.</li>
    </ul>
    </li>
    <li><p>Стремитесь к линейному потоку в своих проверках, избегая использования ветвей и циклов в функциях <code>assert</code>.
    Важно, чтобы логика проверок была простой и линейной. Такой подход упрощает анализ ошибок и делает сопровождение
    тестирования более экономичным.</p>
    <ul>
    <li>Придерживаясь линейных проверок, вы гарантируете, что каждое утверждение следует четкому пути без ненужных
    ветвлений или циклов. Это способствует удобочитаемости, ремонтопригодности и упрощению устранения неполадок при
    возникновении проблем.</li>
    </ul>
    </li>
    <li><p>Именуйте проверки в одинаковом стиле, чтобы по первому взгляду можно было понять, что это именно проверка.</p>
    </li>
    <li><p>Названия тестов должны соответствовать единому стилю и эффективно отражать различия между похожими сценариями. Подобно
    добавлению имен к тест-кейсам в тестовой документации, вы можете использовать аналогичные подходы для именования
    своих тестов.</p>
    <ul>
    <li>Важно выбрать описательные и осмысленные имена для ваших тестов, подчеркивая конкретные различия или тестируемые
    аспекты. Следуя единому стилю именования, вы повышаете удобочитаемость и понятность своего набора тестов. Кроме
    того, понятные и информативные названия тестов облегчают эффективную коммуникацию и сотрудничество между членами
    команды.</li>
    </ul>
    </li>
    <li><p>Вместо того, чтобы дублировать идентичные тесты с небольшими различиями в содержании, например, в языке интерфейса,
    рекомендуется их параметризовать. Параметризация позволяет повторно использовать одну и ту же тестовую логику,
    предоставляя разные входные значения.</p>
    <ul>
    <li><p>Параметризируя тесты, вы можете определить один тестовый пример и указать различное содержимое в качестве
    параметров.
    Такой подход устраняет дублирование кода, повышает удобство сопровождения и упрощает процесс добавления новых
    тест-кейсов с аналогичными характеристиками.</p>
    </li>
    <li><p>Параметризация обеспечивает эффективное управление тестированием и помогает обеспечить охват всех соответствующих
    сценариев без ненужного дублирования тестового кода.</p>
    </li>
    </ul>
    </li>
    <li><p>Рекомендуется писать тесты, которые являются атомарными и неделимыми, то есть каждый тест фокусируется на определенной
    функциональности или сценарии. Вместо того, чтобы создавать один большой тест, который проверяет сразу несколько
    аспектов, лучше разбить его на более мелкие, более целенаправленные тесты. Такой подход позволяет лучше локализовать
    проблему и упрощает устранение неполадок при их возникновении.</p>
    <ul>
    <li><p>Сохраняя тесты атомарными, вы можете точно определить местонахождение сбоев и определить конкретную
    функциональность, вызывающую проблему. Это также способствует модульности и возможности повторного использования,
    поскольку тесты меньшего размера можно комбинировать или повторно использовать в разных сценариях.</p>
    </li>
    <li><p>Написание небольших целенаправленных тестов повышает удобство сопровождения и удобочитаемость тестов. Это
    позволяет быстрее выявлять и решать проблемы, повышая общую эффективность процесса тестирования.</p>
    </li>
    </ul>
    </li>
    </ul>
    <p>Рекомендуется ознакомится с Code Style для написания автотестов из дополнительных материалов.</p>
    <h2 id="-">Подготовка окружения</h2>
    <p>Целью этого дипломного проекта является обучение основам автоматизированного тестирования UI и, чтобы приблизиться к
    достижению этой цели, вы должны практиковаться.</p>
    <p>Мы создадим отдельный публичный репозиторий и будем постепенно добавлять и изменять код автотестов, чтобы сохранить
    историю коммитов и приблизиться к промышленной разработке.</p>
    <p>Начнём:</p>
    <ol>
    <li>Создайте отдельный публичный репозиторий с осмысленным названием на GitHub.</li>
    <li>Добавьте в свой репозиторий файлы <code>README.md</code> и Python <code>.gitignore</code>.</li>
    <li>Склонируйте его к себе на локальную машину.</li>
    <li>Добавьте туда файл <code>conftest.py</code> из предыдущего модуля. Убедитесь дополнительно, что там есть параметр для задания
    языка интерфейса, по умолчанию равный <code>en</code>.</li>
    <li>Убедитесь что ни во вложенных папках, ни во внешних папках нет других файлов <code>conftest.py</code>.</li>
    <li>Добавьте в репозиторий файл <code>requirements.txt</code> из предыдущего модуля.</li>
    <li>Создайте пустой файл <code>__init__.py</code>, чтобы работали относительные импорты.</li>
    <li>Создайте файл <code>test_main_page.py</code> и добавьте в него тест из предыдущего модуля:</li>
    </ol>
    <pre><code class="lang-python">def test_guest_can_go_to_login_page(browser):
        link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
        browser.<span class="hljs-keyword">get</span>(link)
        login_link = browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
        login_link.click()
    </code></pre>
    <ol>
    <li>Создайте новое виртуальное окружение для этого проекта и убедитесь, что в нем установлены все зависимости из
    файла <code>requirements.txt</code></li>
    <li>Убедитесь, что тест работает, с помощью следующей команды: <code>pytest -v --tb=line --language=en test_main_page.py</code>.</li>
    <li>Добавьте в <code>README.md</code> небольшое описание тестового проекта.</li>
    <li>Зафиксируйте изменения коммитом с осмысленным сообщением.</li>
    </ol>
    <h2 id="-page-object-model-">Что такое Page Object Model?</h2>
    <p>Page Object Model (Page Object) — это широко используемый шаблон программирования в автоматизации тестирования,
    особенно для тестирования веб-продуктов. Он служит стандартным подходом и предлагает удобный способ структурирования
    кода, облегчая его обслуживание, модификацию и удобство использования.</p>
    <p>Фундаментальная концепция модели Page Object Model заключается в представлении каждой веб-страницы приложения в виде
    объекта класса. Взаимодействие со страницей можно описать с помощью методов внутри класса. В идеале тесты, использующие
    Page Objects, должны быть сосредоточены на бизнес-логике тестового сценария, абстрагируя методы Selenium для
    взаимодействия браузера и страницы. Такой подход упрощает обслуживание, поскольку изменения макета страницы не потребуют
    модификации связанных тестов. Вместо этого необходимо обновить только класс, представляющий страницу.</p>
    <p>К объектной модели страницы применяются те же принципы разработки кода: улучшение читаемости кода и инкапсуляция деталей
    в абстрактные методы. Тесты должны быть написаны просто и понятно, с выделением повторяющихся сегментов кода в отдельные
    функции. Внутри Page Object мы отличаем логику действий, таких как аутентификация пользователя, от конкретных деталей
    реализации (например, поиск поля электронной почты, ввод данных, поиск поля пароля, ввод данных, расположение кнопки и
    т. д.).</p>
    <p>Рассмотрим такой простой тест-кейс:</p>
    <ol>
    <li>Открыть главную страницу</li>
    <li>Перейти на страницу логина</li>
    </ol>
    <p>Ожидаемый результат:</p>
    <blockquote>
    <p>Открыта страница логина</p>
    </blockquote>
    <p>Давайте посмотрим на кода теста, который реализует первую часть этого теста:</p>
    <blockquote>
    <p>test_main_page.py:</p>
    </blockquote>
    <pre><code class="lang-python">link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com/"</span>
    
    
    def test_guest_can_go_to_login_page(browser):
        browser.<span class="hljs-keyword">get</span>(link)
        login_link = browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
        login_link.click()
    </code></pre>
    <p>Что здесь происходит?</p>
    <p>Открывается ссылка, находится элемент с определенным селектором и производится клик на этот элемент.</p>
    <p>Что мы на самом деле имеем в виду?</p>
    <p>Мы хотим открыть страницу логина. Давайте выделим это действие в отдельную функцию с понятным названием, пока все в том
    же файле</p>
    <blockquote>
    <p>test_main_page.py:</p>
    </blockquote>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go_to_login_page</span><span class="hljs-params">(browser)</span></span>:
        login_link = browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">"#login_link"</span>)
        login_link.click()
    </code></pre>
    <p>и наш тест упрощается:</p>
    <pre><code class="lang-python">def test_guest_can_go_to_login_page(browser):
        browser.<span class="hljs-keyword">get</span>(link)
        go_to_login_page(browser)
    </code></pre>
    <p>При написании последующих тестов, требующих перехода на страницу входа с главной страницы, нет необходимости дублировать
    или переписывать код. Вместо этого мы можем повторно использовать ранее написанный метод, гарантируя возможность
    повторного использования кода и уменьшая избыточность.</p>
    <h2 id="-page-object-">Почему именно Page Object?</h2>
    <p>Хотя можно хранить всю тестовую логику в одном файле, таком как «steps.py», этот подход может стать проблематичным по
    мере увеличения размера веб-продукта и сложности его состояний и переходов. Файл может стать слишком большим, что
    затруднит поиск определенных методов. Кроме того, бывают случаи, когда один и тот же метод может иметь разные реализации
    на разных страницах. Например, в нашем интернет-магазине функция «добавить в корзину» доступна как со страницы каталога,
    так и со страницы отдельного продукта.</p>
    <p>Чтобы улучшить организацию и удобство сопровождения, полезно сгруппировать методы, которые логически связаны с
    конкретной веб-страницей, в выделенный класс в нашем коде. Эта концепция приводит к термину Page Object, который
    относится к абстрактному объекту, инкапсулирующему методы для взаимодействия с конкретной веб-страницей.</p>
    <p>Важно! Обычно методы у Page Object бывают двух типов: сделать что-то и проверить что-то.</p>
    <p>Рассмотрим <a href="http://selenium1py.pythonanywhere.com/en-gb/catalogue/the-shellcoders-handbook_209/">страницу товара</a> в
    интернет магазине.</p>
    <p>Какие могут быть методы у Page Object, ассоциированного с такой страницей?</p>
    <p>Запишем основные сценарии:</p>
    <ul>
    <li>добавить в корзину;</li>
    <li>проверить, что есть сообщение об успешном добавлении в корзину;</li>
    <li>перейти к написанию отзыва;</li>
    <li>проверить, что есть название, цена, описание товара;</li>
    <li>вернуться на главную.</li>
    </ul>
    <p>Стоит отметить, что все утверждения также реализованы в виде отдельных методов. В самом тестовом примере нет
    вспомогательных ключевых слов, таких как «assert», а скорее описательное представление шагов, аналогичное нашей
    тестовой документации.</p>
    <p>Тесты будут выглядеть примерно так:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_add_to_cart</span><span class="hljs-params">(browser)</span></span>:
        product_page = ProductPage(browser, url=<span class="hljs-string">''</span>)  <span class="hljs-comment"># инициализируем объект Page Object</span>
        product_page.open()  <span class="hljs-comment"># открываем страницу в браузере</span>
        product_page.should_be_add_to_cart_button()  <span class="hljs-comment"># проверяем что есть кнопка добавления в корзину</span>
        product_page.add_product_to_cart()  <span class="hljs-comment"># жмем кнопку добавить в корзину </span>
        product_page.should_be_success_message()  <span class="hljs-comment"># проверяем что есть сообщение с нужным текстом</span>
    </code></pre>

    <h1 id="-page-object">Пишем первые тесты с помощью Page Object</h1>
    <h2 id="-basepage">Базовая страница для проекта: BasePage</h2>
    <p>Теперь мы проведём рефакторинг теста в файле <code>test_main_page.py</code> который мы представили
    на этапе настройки среды, используя шаблон Page Object.
    Наше внимание будет сосредоточено на главной странице нашего приложения, и для этого мы дадим
    классу говорящее имя, например &quot;MainPage&quot;.</p>
    <p>Примечание. Мы создадим базовую реализацию шаблона Page Object с нуля. В следующих уроках мы
    рассмотрим существующие фреймворки и то, как они могут упростить наш рабочий процесс. Сейчас крайне важно
    сосредоточиться на понимании основных принципов этого шаблона.</p>
    <ol>
    <li>Создайте в своем проекте директорию pages, там мы будем хранить все наши Page Object.</li>
    <li>В папке создайте два файла: base_page.py и main_page.py.</li>
    </ol>
    <p>Для начала мы создадим базовый класс страницы, который будет служить основой для всех остальных классов. Эта базовая
    страница будет содержать служебные методы для взаимодействия с драйвером.</p>
    <ol>
    <li>В файле base_page.py создайте класс с названием BasePage.</li>
    <li>Далее мы добавим методы в наш класс. Прежде всего, давайте включим конструктор, который является методом, вызываемым
    при создании объекта. Конструктор определяется с помощью ключевого слова __init__. Мы передадим экземпляр драйвера
    и URL-адрес в качестве параметров конструктору. Внутри конструктора мы будем хранить эти данные как атрибуты нашего
    класса.</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser, url)</span></span>:
        <span class="hljs-keyword">self</span>.browser = browser
        <span class="hljs-keyword">self</span>.url = url
    </code></pre>
    <ol>
    <li>Реализуем метод открытия страницы, путём вызовы метода <code>get()</code>:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        pass
    </code></pre>
    <p>Вам необходимо самостоятельно реализовать этот метод. В результате в файле <code>base_page.py</code> у вас должно быть следующее:</p>
    <pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePage</span>:</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser, url)</span></span>:
            <span class="hljs-keyword">self</span>.browser = browser
            <span class="hljs-keyword">self</span>.url = url
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            <span class="hljs-comment"># ваша реализация</span>
    </code></pre>
    <h2 id="page-object-">Page Object для главной страницы сайта</h2>
    <p>Теперь приступим к реализации Page Object, который будет связан с главной страницей интернет-магазина.</p>
    <ol>
    <li>Откройте файл <code>main_page.py</code></li>
    <li>В нем нужно сделать импорт базового класса BasePage:</li>
    </ol>
    <p><code>from .base_page import BasePage</code></p>
    <ol>
    <li>В нём создайте класс MainPage. Наследуйте его от класса BasePage, чтобы он получил все его методы и атрибуты:</li>
    </ol>
    <p><code>class MainPage(BasePage):</code></p>
    <ol>
    <li>Перенесите метод открытия страницы логина в класс MainPage:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go_to_login_page</span><span class="hljs-params">(browser)</span></span>:
        login_link = browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">'#login_link'</span>)
        login_link.click()
    </code></pre>
    <p>Поскольку экземпляр браузера мы создаём и передаём на этапе создания Page Object, то нам больше не нужно передавать его
    в качестве аргумента. Вместо этого необходимо использовать аргумент <code>self</code>, чтобы иметь доступ к методам и атрибутам
    класса.</p>
    <p>Так как браузер - это аргумент класса BasePage, то обращаться к нему нужно
    через <code>self</code>:</p>
    <pre><code class="lang-python">self<span class="hljs-selector-class">.browser</span><span class="hljs-selector-class">.find_element</span>(By<span class="hljs-selector-class">.CSS_SELECTOR</span>, <span class="hljs-string">'#login_link'</span>)
    </code></pre>
    <p>В итоге, ваш файл <code>main_page.py</code> должен выглядеть следующим образом:</p>
    <pre><code class="lang-python"><span class="hljs-title">from</span> .base_page <span class="hljs-keyword">import</span> BasePage
    <span class="hljs-title">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
    <span class="hljs-class">
    
    <span class="hljs-keyword">class</span> <span class="hljs-type">MainPage</span>(<span class="hljs-type">BasePage</span>):
        def go_to_login_page(<span class="hljs-title">self</span>):
            login_link = self.browser.find_element(<span class="hljs-type">By</span>.<span class="hljs-type">CSS_SELECTOR</span>, '#<span class="hljs-title">login_link'</span>)
            login_link.click()</span>
    </code></pre>
    <h2 id="-page-object">Первый тест на основе Page Object</h2>
    <p>Обратите внимание, что в директории <code>pages</code> должны находиться только Page Objects.</p>
    <p>Давайте теперь перепишем тест с помощью Page Object:</p>
    <ol>
    <li>Создайте файл для тестов главной страницы, поместите его на уровне с <code>conftest.py</code> и <code>requirements.txt</code>, тоесть в
    корневом каталоге вашего проекта. Назовём его <code>test_main_page.py</code>.</li>
    <li>Откройте файл <code>test_main_page.py</code>.</li>
    <li>Импортируйте класс главной страницы из директории <code>pages</code>:</li>
    </ol>
    <pre><code class="lang-python">from <span class="hljs-selector-class">.pages</span><span class="hljs-selector-class">.main_page</span> import MainPage
    </code></pre>
    <ol>
    <li>Теперь отрефакторим сам тест:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-keyword">from</span> .pages.main_page <span class="hljs-keyword">import</span> MainPage
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_go_to_login_page</span><span class="hljs-params">(browser)</span>:</span>
        link = <span class="hljs-string">'http://selenium1py.pythonanywhere.com/'</span>
        page = MainPage(browser, link)  <span class="hljs-comment"># инициализация Page Object</span>
        page.open()  <span class="hljs-comment"># открыть страниу</span>
        page.go_to_login_page()  <span class="hljs-comment"># перейти на страницу логина</span>
    </code></pre>
    <ol>
    <li><p>Запустите тест, чтобы убедиться, что он работает. Можете использовать любую команду для запуска,
    например <code>pytest -v --tb=line --language=en test_main_page.py</code>.</p>
    </li>
    <li><p>Не забывайте коммитить вносимые изменения (обязательно с осмысленными сообщениями о том, что изменилось. Рекомендую
    использовать только английский язык как для сообщений в коммитах, так и в пул реквестах, описаниях, комментариях и
    докстрингах.)</p>
    </li>
    </ol>
    <p>Теперь наш тест почти что полность написан согласно стилю Page Object. Почему почти - узнаете чуть позже.</p>
    <h2 id="-page-object">Методы-проверки в Page Object</h2>
    <p>Давайте автоматизируем следующий сценарий:</p>
    <ol>
    <li>Открыть главную страницу</li>
    <li>Проверить, что есть ссылка, которая ведет на логин</li>
    </ol>
    <p>Как нам реализовать проверку наличия ссылки? Во первых, это будет один из методов страницы MainPage, потому что по
    условию мы должны проводить эту проверку на этой странице. Во-вторых, методы-проверки обычно называются похоим образом и
    могут выглядеть примерно так: <code>should_be_...</code>.</p>
    <p>Давайте создадим в нашем классе MainPage метод <code>should_be_login_link</code>:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        <span class="hljs-keyword">self</span>.browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">'#login_link_invalid'</span>)
    </code></pre>
    <p>Обратите внимание, мы намеренно сделали селектор неправильным, чтобы наблюдать за результатом теста, когда он
    сталкивается с ошибкой. Хорошей практикой считается сначала писать тесты, которые проваливаются, а затем делать их
    проходящими.</p>
    <p>Добавим новый тест в наш тестовый набор для главной страницы:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(browser)</span></span>:
        link = <span class="hljs-string">'http://selenium1py.pythonanywhere.com/'</span>
        page = MainPage(browser, link)
        page.open()
        page.should_be_login_link()
    </code></pre>
    <p>Запустите получившийся тест командой: <code>pytest -v --tb=line --language=en test_main_page.py</code>.</p>
    <p>Вывод сообщения об ошибке не очень понятный и требуется время, чтобы разобраться почему тест упал с ошибкой. Далее мы
    рассмотрим как ошибки можно обработать, чтобы сделать вывод более понятным.</p>
    <p>Рекомендую ознакомиться с работой с исключениями в языке Python в статье
    <a href="https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html">Исключения в python. Конструкция try - except для обработки исключений</a></p>
    <h2 id="-">Проверка элемента на странице</h2>
    <p>Для вывода адекватного сообщения об ошибке мы будем перехватывать исключение с использованием оператора <code>assert</code>.</p>
    <p>Для этого реализуем служебный метод поиска элемента и поместим его в BasePage. Метод будет возвращать нам <code>True</code>, если
    браузер смог обнаружить элемент и <code>False</code> в противном случае.</p>
    <p>Расмотрим один из вариантов реализации с использованием неявных ожиданий.</p>
    <ol>
    <li>В конструктор BasePage добавим команду для неявного ожидания в 5 секунд:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser, url, timeout=<span class="hljs-number">5</span>)</span></span>:
        <span class="hljs-keyword">self</span>.browser = browser
        <span class="hljs-keyword">self</span>.url = url
        <span class="hljs-keyword">self</span>.browser.implicitly_wait(timeout)
    </code></pre>
    <ol>
    <li>Теперь напишем метод <code>is_element_present()</code>, который и будет заниматься проверкой наличия элемента на странице. Его
    реализация уже будет немного поинтереснее: мы должны передавать в него 2 аргумента: способ поиска (CSS/XPATH и т.д.)
    и значение поиска (сам селектор). Используем перехват сключения с помощью конструкции <code>try/except</code>.</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_element_present</span><span class="hljs-params">(self, how, what)</span>:</span>
        <span class="hljs-string">"""
        @param how: способ поиска.
        @param what: строка-селектор.
        """</span>
        <span class="hljs-keyword">try</span>:
            self.browser.find_element(how, what)
        <span class="hljs-keyword">except</span> имя_исключения:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
    </code></pre>
    <p>Если вам необходимо использовать не стандартное исключение языка Python, а исключение созданное в какой-либо библиотеке,
    то его нужно импортировать. Для реализации метода поиска вам потребуется импортировать исключение из библиотеки
    Selenium:</p>
    <pre><code class="lang-python">from selenium<span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.exceptions</span> import имя_исключения
    </code></pre>
    <p>После успешного импорта исключения вы можете использовать новый метод для проверки элемента на наличие на любой
    странице, которая будет унаследована от базовой.</p>
    <ol>
    <li>Теперь отрефакторим метод проверки ссылки на логин так, чтобы он выдавал адекватное сообщение об ошибке:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        assert <span class="hljs-keyword">self</span>.is_element_present(By.CSS_SELECTOR, <span class="hljs-string">'#login_link_invalid'</span>), \
        <span class="hljs-string">'Login link is not presented on the page'</span>
    </code></pre>
    <p>Запустите тесты и проверьте вывод сообщения об ошибке, использовав
    команду <code>pytest -v --tb=line --language=en test_main_page.py</code>.</p>
    <p>Не забудьте исправить селектор, чтобы тест успешно проходил и сделайте коммит с осмысленным сообщением (рекомендуется
    использовать английский язык) о внесённых изменениях.</p>
    <h2 id="-page-object">Элементы страниц в паттерне Page Object</h2>
    <p>Помните мы говорили, что наши тесты почти соответствуют подходу Page Object? Давайте разберёмся почему на небольшом
    примере.</p>
    <p>Допустим вы работаете в команде, где постоянно вносятся изменения в проект. У вас уже написаны тесты взаимодействующие
    со страницей логина. К вам обращается руководство с просьбой протестировать страницу сайта промо-акции.</p>
    <p>На первый взгляд ничего не изменилось крме ссылки. Замените ссылку, с которой запускаются тесты главной
    на <a href="http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209?promo=midsummer">http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209?promo=midsummer</a>.</p>
    <p>Запустите тесты командой: <code>pytest -v --tb=line --language=en test_main_page.py</code>.</p>
    <p>Тесты не прошли и их нужно фиксить. Подберите новый локатор к ссылке на логин.</p>
    <p>Посчитайте сколько строк кода вам придётся менять, чтобы исправить ситуацию. А теперь представьте, что у вас написано
    несколько десятков или даже сотен тестов.</p>
    <p>Для избежания такой ситуации, при проектировании тестов, хорошей практикой является вынесение локаторов для страниц в
    отдельный файл. Давайте и мы это сделаем.</p>
    <ol>
    <li>В директории <code>pages</code> создайте новый файл <code>locators.py</code>.</li>
    <li>Внутри него создайте класс. Класс будет создаваться для конкретной страницы и содержать все необходимые локаторы
    элементов для её тестирования, поэтому он должен иметь соответствующее название.</li>
    </ol>
    <pre><code class="lang-python">from selenium<span class="hljs-selector-class">.webdriver</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.by</span> import By
    
    
    class MainPageLocators:
        LOGIN_LINK = (By<span class="hljs-selector-class">.CSS_SELECTOR</span>, <span class="hljs-string">'#login_link'</span>)
    </code></pre>
    <p>Обратите, что локатор теперь состоит из кортежа: как искать и что искать.</p>
    <ol>
    <li>В файле <code>main_page.py</code> импортируйте новый класс с локаторами:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-keyword">from</span> .locators <span class="hljs-keyword">import</span> MainPageLocators
    </code></pre>
    <ol>
    <li>Теперь в классе MainPage заменим все старые записи использования локаторов на новый вариант использования через
    атрибуты класса MainPageLocators. Посмотрите на пример и выполните замену в остальных тестов:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        assert <span class="hljs-keyword">self</span>.is_element_present(*MainPageLocators.LOGIN_LINK), <span class="hljs-string">'Login link is not presented'</span>
    </code></pre>
    <p>Обратите на символ звёздочки, в языке Python он используется для распаковки, в данном случае кортежа, чтобы
    метод <code>is_element_present()</code> получил пару аргументов для вызова.</p>
    <ol>
    <li>Запустите тесты повторно: <code>pytest -v --tb=line --language=en test_main_page.py</code>.</li>
    </ol>
    <p>Тесты конечно же снова упадут с ошибкой, но если вам придётся снова менять локатор то менять его придется всего лишь в
    одном месте, а не искать все тесты в которых он использован.</p>
    <p>Итак, PageObject — это не только методы, но и элементы.</p>
    <p>Элементы на страницах часто меняются в процессе разработки. Поэтому важно поддерживать свой код в состоянии готовым
    быстро изменяться. В долгосрочной перспективе это уменьшит время на поддержку и обслуживание наших тестовых наборов.</p>
    <p>Удалите ссылку на промо-акцию и замените её на обычную ссылку: <code>link = &#39;http://selenium1py.pythonanywhere.com/&#39;</code>.</p>
    <p>Верните старый локатор для LOGIN_LINK, чтобы тесты проходили. Не забудьте добавить изменения вместе с осмысленным
    сообщением в ваш удалённый репозиторий.</p>
    <h2 id="-loginpage">Реализация LoginPage</h2>
    <p>На данный момент у нас реализована проверка ссылки к странице логина, но нет ни одной проверки для этой страницы.
    Давайте проверим, что мы действительно перешли на нужную страницу. Для этого нам понадобится создать новый Page Object,
    назовем его LoginPage.</p>
    <p>Возьмите за основу следующий код для файла <code>login_page.py</code>, который необходимо будет поместить в директорию к остальным
    объектам страниц:</p>
    <pre><code class="lang-python"><span class="hljs-keyword">from</span> .base_page <span class="hljs-keyword">import</span> BasePage
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPage</span><span class="hljs-params">(BasePage)</span>:</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_login_page</span><span class="hljs-params">(self)</span>:</span>
            self.should_be_login_url()
            self.should_be_login_form()
            self.should_be_register_form()
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_login_url</span><span class="hljs-params">(self)</span>:</span>
            <span class="hljs-comment"># реализуйте проверку на корректный url адрес</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_login_form</span><span class="hljs-params">(self)</span>:</span>
            <span class="hljs-comment"># реализуйте проверку, что есть форма логина</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_register_form</span><span class="hljs-params">(self)</span>:</span>
            <span class="hljs-comment"># реализуйте проверку, что есть форма регистрации на странице</span>
            <span class="hljs-keyword">assert</span> <span class="hljs-keyword">True</span>
    </code></pre>
    <p>Вам предстоит самостоятельно реализовать эти проверки.</p>
    <ol>
    <li>В файлу <code>locators.py</code> создайте новый класс для обнаружения элементов на странице логина LoginPageLocators.</li>
    <li>Подберите селекторы, необходимые для проверок, и добавьте их в класс LoginPageLocators.</li>
    <li>Реализуйте проверки с помощью локаторов. Не забудьте указывать осмысленные сообщения для ошибок и протестировать
    работу новых проверок.</li>
    <li>Обратите внимание на метод <code>should_be_login_url()</code> он должен проверить наличие подстроки в текущем url браузера. Для
    этого вам потребуется использовать свойство веб-драйвера:
    <a href="https://selenium-python.readthedocs.io/api.html#selenium.webdriver.remote.webdriver.WebDriver.current_url">current_url</a>.</li>
    <li>Добавьте изменения в репозиторий.</li>
    </ol>
    <h2 id="-">Переходы между страницами</h2>
    <p>Переход можно осуществлять разными способами.</p>
    <p>Мы рассмотрим неявный переход с явной инициализацией страницы. Такой способ позволяет делать тесты менее связными
    перекрёстными импортами.</p>
    <ol>
    <li>Для этого в файле <code>main_page.py</code> необходимо импортировать LoginPage:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-keyword">from</span> .login_page <span class="hljs-keyword">import</span> LoginPage
    </code></pre>
    <ol>
    <li>Инициализируем страницу в теле теста:</li>
    </ol>
    <pre><code class="lang-python">def test_guest_can_go_to_login_page(browser):
        link = <span class="hljs-string">"http://selenium1py.pythonanywhere.com"</span>
        page = MainPage(browser, link)
        page.open()
        page.go_to_login_page()
        login_page = LoginPage(browser, browser.current_url)
        login_page.should_be_login_page()
    </code></pre>
    <p>Можно также написать общий метод открытия странице по ссылке в классе BasePage и пользоваться им с любой страницы,
    которая будет наследована от BasePage. Так же есть и другие способы реализовать нужный функционал, но мы остановимся на
    текущей реализации.</p>
    <h2 id="-">Удобство поддержки тестов — инкапсуляция бизнес-логики в методах</h2>
    <p>Что делать, когда меняется логика взаимодействия со страницей, которая используется во множестве тестов? Например,
    давайте рассмотрим сценарий, в котором нам нужно проверить возможность перехода на страницу логина по ссылке в панели
    навигации на различных страницах веб-сайта. Предположим, что таких страниц 20, у нас будет 20 тестов, использующих
    метод <code>go_to_login_page()</code> из класса <code>MainPage</code>. А теперь представьте, что разработчики ввели alert, который
    срабатывает при переходе по нужной нам ссылке и его нужно принять. Следовательно, все 20 тестов провалятся,
    потому что метод <code>go_to_login_page()</code> не обрабатывает предупреждение, что также приводит к сбою
    метода <code>should_be_login_page()</code> так как он не срабатывает.</p>
    <p>Чтобы исправить эту ситуацию, мы можем отрефакторить метод <code>go_to_login_page()</code>, включив в него обработку
    предупреждения. Таким образом, мы можем восстановить функциональность всех тестов, не внося никаких изменений в сами
    тесты.</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go_to_login_page</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        link = <span class="hljs-keyword">self</span>.browser.find_element(By.CSS_SELECTOR, <span class="hljs-string">'#login_link'</span>)
        link.click()
        alert = <span class="hljs-keyword">self</span>.browser.switch_to.alert
        alert.accept()
    </code></pre>
    <p>Использование шаблона Page Object дает еще одно преимущество: разделение самого теста и логики взаимодействия со
    страницей. Это разделение повышает читаемость и поддерживаемость тестов, особенно когда код приложения
    подвергается изменениям. Отделяя тест от тонкостей взаимодействия со страницей, мы устанавливаем четкие границы, которые
    способствуют ясности кода и облегчают будущие изменения.</p>

    <h1 id="-">Улучшаем дизайн тестов</h1>
    <p>Вы уже знаете практически всю теорию о применении Page Object Model и далее будет много заданий на самостоятельное
    выполнение. Вы будуте самостоятельно их делать и проверять себя. Это сильно увеличит эффективность усвоения
    теоретических знаний и у вас появится проект, который можно будет продемонстрировать.</p>
    <h2 id="-">Задание: добавление в корзину со страницы товара</h2>
    <p>Представим вам поручили автоматизировать следующий сценарий:</p>
    <ol>
    <li>Открыть страницу <code>http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209/?promo=newYear</code>.</li>
    <li>Нажать на кнопку &quot;Добавить товар&quot;.</li>
    <li>Решить уравнение и получить скидку, ввести ответ. Для этого использовав метод <code>solve_quiz_and_get_code()</code>, который
    вам отдали уже реализованный.</li>
    </ol>
    <p>Ожидаемый результат:</p>
    <ol>
    <li>Получение сообщения, что товар добавлен в корзину. Название товара в сообщении соответствует добавленному товару в
    корзину.</li>
    <li>Сообщение со стоимостью корзины, стоимость которой соответствует стоимости добавленного товара.</li>
    </ol>
    <p>Тест нужно написать, используя паттерн Page Object. Для этого вам нужно:</p>
    <ol>
    <li>Добавить новый файл для тест-кейсов, связанных со страницей товара. Например <code>test_product_page.py</code>.</li>
    <li>Создать класс для страницы товара. Опишите его в файле <code>product_page.py</code> в директории <code>pages</code>.</li>
    <li>Реализовать метод для добавления в корзину.</li>
    <li>Реализовать методы-проверки.</li>
    <li>Добавить локаторы к элементам страницы в отдельном классе файла <code>locators.py</code>.</li>
    <li>Реализовать сам тест-кейс. Назовите тест <code>test_guest_can_add_product_to_basket</code>.</li>
    </ol>
    <p>Хорошей практикой является создание новой ветки, отходящей от основной, в которой уже будет реализован новый функционал.
    Так же рекомендуется сперва создавать структуру, а затем уже переходить к реализации. Например, сперва создаются пустые
    файлы и прописываются импорты, затем описываются необходимые локаторы, после чего уже можно переходить к созданию
    объекта страницы и методы-проверки, и только в самом конце писать тесты. Но вы можете выполнять шаги с любого пункта.</p>
    <pre><code class="lang-python">from selenium.common.exceptions <span class="hljs-keyword">import</span> NoAlertPresentException
    
    
    def solve_quiz_and_get_code(self):
        alert = self.browser.switch_to.alert
        x = alert.<span class="hljs-built_in">text</span>.<span class="hljs-built_in">split</span>()[<span class="hljs-number">2</span>]
        answer = <span class="hljs-built_in">str</span>(math.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">abs</span>((<span class="hljs-number">12</span> * math.<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">float</span>(x))))))
        alert.send_keys(answer)
        alert.accept()
        <span class="hljs-keyword">try</span>:
            alert = self.browser.switch_to.alert
            alert_text = alert.<span class="hljs-built_in">text</span>
            <span class="hljs-built_in">print</span>(f<span class="hljs-string">'Code: {alert_text}'</span>)
            alert.accept()
        except NoAlertPresentException:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'No second alert present'</span>)
    </code></pre>
    <p>Напомню, чтобы видеть результаты работы функции <code>print()</code> необходимо запускать Pytest с флагом <code>-s</code>.</p>
    <h2 id="-">Задание: независимость от данных</h2>
    <p>Для эффективных автотестов крайне важно минимизировать зависимости от конкретных данных. Жесткие проверки объектов,
    уникальных для конкретного экземпляра, настоятельно не рекомендуются. Почему? Что ж, данные имеют свойство часто
    меняться, что потребует постоянных фиксов автотестов. Более того, такой подход затрудняет повторное использование
    кода. Например, если мы собираемся запустить тест для нескольких продуктов, нам потребуется создать множество проверок,
    по одной для каждого продукта. В конечном итоге такая практика снижает качество продукта, поскольку эти тесты охватывают
    лишь ограниченное количество страниц.</p>
    <p>Общая рекомендация состоит в том, чтобы убедиться, что ваши тесты не зависят от факторов, находящихся вне вашего
    контроля. Сюда входят данные, хранящиеся в базах данных или сторонних службах, используемых вашим приложением.
    Желательно избегать проверки конкретных данных, если у вас нет специально подготовленной тестовой базы данных, которая
    инициализируется перед каждым запуском теста, или если вы можете добавить необходимые данные непосредственно в базу
    данных или через API приложения. Осуществляя контроль над тестовой средой и данными, вы можете поддерживать более
    надежные и воспроизводимые тесты.</p>
    <p>Запустите тест, который мы написали на предыдущем этапе разработки, со
    ссылкой: <a href="http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=newYear2019">http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=newYear2019</a>.</p>
    <p>Если вы на прошлом шаге проверяли конкретное название товара, то ваш тест упадёт с ошибкой, так как теперь был добавлен
    другой товар. Если тест прошел успешно, то вы написали тест независимый от контекста и правильно сделали.</p>
    <p>Чтобы тест был независимым от контента:</p>
    <ul>
    <li>Измените методы проверки так, чтобы они принимали название товара и цену товара.</li>
    <li>Сделайте метод, который берёт из элемента название товара и возвращает его.</li>
    <li>Сделайте такой же метод для цены.</li>
    <li>Проверьте, что название товара в сообщении совпадает с заголовком товара.</li>
    </ul>
    <p>Вот несколько основных советов, как добиться независимости тестов:</p>
    <ol>
    <li><p>Используйте тестовые данные: вместо того, чтобы полагаться на конкретные данные, существующие в определенном
    контексте, иницциализируйте тестовые данные в самом тесте. Это гарантирует, что тест может выполняться с собственным
    набором данных независимо от контекста.</p>
    </li>
    <li><p>Избегайте &quot;хардкодинга&quot; значений: вместо &quot;хардкодинга&quot; конкретных значений или идентификаторов используйте
    переменные или константы в тестовом коде. Это обеспечивает гибкость при изменении значений без изменения логики
    тестирования.</p>
    </li>
    <li><p>Моделирование внешних зависимостей: если ваши тесты зависят от внешних систем или служб, рассмотрите возможность
    использования фиктивных (mock) фреймворков или методов для имитации этих зависимостей. Таким образом, ваши тесты
    могут выполняться независимо, не полагаясь на доступность или поведение внешних компонентов.</p>
    </li>
    <li><p>Изолируйте тестовые наборы: убедитесь, что каждый тестовый набор является автономным и не зависит от выполнения или
    результатов других тестовых наборов. Избегайте зависимостей между тестами.</p>
    </li>
    <li><p>Используйте методы setup и teardown: используйте методы настройки и очистки срезы, предоставляемые средами
    тестирования, для подготовки необходимой тестовой среды и очистки после теста. Это гарантирует, что каждый тест
    начинается с известного состояния и заканчивается приводя систему в исходное состояние.</p>
    </li>
    <li><p>Инкапсулируйте тестовую логику. Организуйте тестовый код в повторно используемые функции или классы, которые
    инкапсулируют тестовую логику. Это повышает читаемость, поддерживаемость и возможность повторного использования
    ваших тестов.</p>
    </li>
    <li><p>Избегайте зависимостей от внешних файлов конфигурации: если ваши тесты полагаются на файлы конфигурации, рассмотрите
    возможность предоставления специфичных для теста конфигураций в самом тестовом коде или с использованием методов
    имитации конфигурации.</p>
    </li>
    </ol>
    <h2 id="-">Задание: независимость контента, ищем баг</h2>
    <p>Теперь мы будем искать самый настоящий баг у нашего интерент-магазина.</p>
    <p>Итак, вводная: была запущено несколько промо-акций, одна из которых приводит к появлению дефекта. Промо-акция включается
    путем добавления параметра <code>?promo=offerN</code> к ссылке на товар.</p>
    <p>На не придется писать отдельные тесты для каждой ссылки на промо-акцию, чтобы проверить её работоспособность, мы будем
    использовать параметризацию. Вам нужно определить при каком значении параметра акции тест будет падать. Для этого мы
    должны обнаружить проблемный URL, на котором возникает ошибка. Значение <code>N</code> у параметра <code>?promo=offerN</code> изменяется от 0
    до 9.</p>
    <p>Параметризация используется для запуска теста с разными входными данными. Вот пример, как вы можете использовать
    декоратор параметризации:</p>
    <pre><code class="lang-python">@pytest.mark.parametrize(<span class="hljs-string">'link'</span>, [<span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer1"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer2"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer3"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer4"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer5"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer6"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer7"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer8"</span>,
                                      <span class="hljs-string">"http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer9"</span>])
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_add_product_to_basket</span><span class="hljs-params">(browser, link)</span></span>:
        <span class="hljs-comment"># ваша реализация теста</span>
    </code></pre>
    <p>Скажем, что после обнаружения бага, вам сказал, что фиксить баг в этом спринте вы не будете. Вам необходимо отметить
    тест, как ожидаемо падающий, использовав xfail. Мы уже говорили, как использовать эту фичу, вы можете осведить знания в
    памяти <a href="https://pytest.org/en/stable/how-to/skipping.html#skip-xfail-with-parametrize">Skip/xfail with parametrize</a>.</p>
    <p>Ваша задача:</p>
    <ol>
    <li>Параметризовать тест.</li>
    <li>Обнаружить дефект.</li>
    <li>Пометить тест с дефектом, как ожидаемо падающий.</li>
    <li>Зафиксировать изменения коммитом с осмысленным сообщением.</li>
    </ol>
    <h2 id="-">Отрицательные проверки: как проверить отсутствие элемента</h2>
    <p>Иногда при создании автотестов возникают ситуации, когда нам нужно проверить не только наличие элемента на странице, но
    и его отсутствие. Здесь стоит разделить две важные особенности:</p>
    <ol>
    <li>Элемент может быть на странице (но не должен). Например, такое часто касается различных кнопок, которые появляются
    только при выполнении определённых условий. Примером для нашего интернет-магазина может быть проверка отображения
    сообщения об успешном добавлении товара в корзину при открытии корзины. Если мы будем осуществлять поиск элемента при
    негативной проверке без ожидания, то рискуем получить проходящий успешно тест и пропустить баг, если сообщение таки
    отображается, но с небольшой задержкой.</li>
    <li>Элемент отображается на странице и должен исчезнуть через определённое время или в результате действий пользователя.
    Это может быть исчезновение прогрессбара или изображения товара при отводе курсора от его изображения.</li>
    </ol>
    <h3 id="-">Почему нужно писать такие проверки с осторожностью?</h3>
    <p>Во-первых, тестам всегда придётся ждать обнаружения элемента, чтобы убедиться, что элемент действительно отсутствует или
    появляется. Если мы используем нашу написанную функцию <code>is_element_present()</code>, то тест с такой проверкой будет ждать
    полные и честные 5 секунд:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_not_be_success_message</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        assert <span class="hljs-keyword">not</span> <span class="hljs-keyword">self</span>.is_element_present(*ProductPageLocators.SUCCESS_MESSAGE), \
        <span class="hljs-string">'Success message is presented'</span>
    </code></pre>
    <p>Это довольно продолжительное время для позитивного сценария и стоит подобрать для этого теста индивидуальное время путём
    проб и ошибок. А для этих целей оправдано использование явных ожиданий.</p>
    <p>Во-вторых, негативные тесты часто дают ложноположительные результаты, если селектор элемента устарел. Элемента с таким
    селектором на странице нет, а сообщение отображается. Тест при этом выдаст зелёный ответ, что все в порядке. Это плохо!</p>
    <p>Поэтому на каждый негативный тест вы должны написать позитивный тест. В одном тесте проверяете, что элемента нет, в
    соседнем, что элемент есть.</p>
    <p>Про распространённые ошибки составления UI-автотестов вы можете прочитать в
    статье <a href="https://habr.com/ru/companies/badoo/articles/419419/">UI-автотесты: как делать не стоит</a>.</p>
    <h3 id="-">Как же тогда реализовывать такие проверки?</h3>
    <p>Почти всегда вам придётся ориентироваться в конкретной ситуации по разному, но общая рекомендация - использовать явные
    ожидания. Хорошей практикой будет придерживаться исключительно явных ожиданий в рамках проекта и не использовать
    неявные.</p>
    <p>Добавим в BasePage абстрактный метод, который проверяет, что элемент не появляется на странице в течение заданного
    времени:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_not_element_present</span><span class="hljs-params">(self, how, what, timeout=<span class="hljs-number">4</span>)</span>:</span>
        <span class="hljs-keyword">try</span>:
            WebDriverWait(self.browser, timeout).until(EC.presence_of_element_located((how, what)))
        <span class="hljs-keyword">except</span> TimeoutException:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
    </code></pre>
    <p>Использование данного метода для страницы товара будет следующим:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_not_be_success_message</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        assert <span class="hljs-keyword">self</span>.is_not_element_present(*ProductPageLocators.SUCCESS_MESSAGE), \
        <span class="hljs-string">'Success message is presented, but should not be'</span>
    </code></pre>
    <p>Если же мы хотим проверить, что какой-то элемент исчезает, то следует воспользоваться явным ожиданием вместе с функцией
    <code>until_not()</code>, в зависимости от ожидаемого результата:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_disappeared</span><span class="hljs-params">(self, how, what, timeout=<span class="hljs-number">1</span>)</span>:</span>
        <span class="hljs-keyword">try</span>:
            WebDriverWait(self.browser, timeout).until_not(EC.presence_of_element_located((how, what)))
        <span class="hljs-keyword">except</span> TimeoutException:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
    </code></pre>
    <p>Напишите самостоятельно метод-проверку на исчезновение для класса страницы товара
    аналогично <code>should_not_be_success_message()</code>.</p>
    <p>Обратите внимание на разницу между методами <code>is_not_element_present()</code> и <code>is_disappeared()</code>.</p>
    <p>Поскольку к проектированию таких тестов необходимо относиться очень аккуратно и писать дополнительные проверки, то
    рекомендуется их избегать без явной необходимости.</p>
    <h2 id="-">Задание: отрицательные проверки</h2>
    <p>Добавьте к себе в проект функции из предыдущего шага и реализуйте несколько простых тестов:</p>
    <ol>
    <li><p>test_guest_cant_see_success_message_after_adding_product_to_basket:</p>
    </li>
    <li><p>Открыть страницу товара</p>
    </li>
    <li>Добавить товар в корзину</li>
    <li>Проверить, что нет сообщения об успехе с помощью <code>is_not_element_present</code></li>
    </ol>
    <ol>
    <li><p>test_guest_cant_see_success_message:</p>
    </li>
    <li><p>Открыть страницу товара</p>
    </li>
    <li>Проверить, что нет сообщения об успехе с помощью <code>is_not_element_present</code></li>
    </ol>
    <ol>
    <li><p>test_message_disappeared_after_adding_product_to_basket:</p>
    </li>
    <li><p>Открыть страницу товара</p>
    </li>
    <li>Добавить товар в корзину</li>
    <li>Проверить, что нет сообщения об успехе с помощью <code>is_disappeared</code></li>
    </ol>
    <p>Пометьте тесты, которые упали как XFail.</p>
    <p>Не забудьте зификсировать изменения с осмысленным сообщением коммита и запушить в свой репозиторий.</p>
    <h2 id="-">Плюсы наследования: магия ООП</h2>
    <p>Рассмотрим один аспект паражигмы ООП, который мы дос сих пор немного использовали: механизм наследования.</p>
    <p>Мы уже его использовали, когда выделили базовый класс для наших проверок BasePage, а от него уже наследовали остальные
    объекты страниц: LoginPage, MainPage. Сейчас в нашем классе BasePage базовые технические детали - поиск элементов, метод
    для открытия страницы и вспомогательные методы. Но мы можем в него добавить и методы общих для всех страниц.</p>
    <p>Важным моментом будет отделение общего от частного. Таким образом, в элемент базовой страницы должно попасть
    исключительно общее для всех страниц.</p>
    <p>Используя такой подход мы уменьшаем количество дублируемого кода и упрощаем поддержку кода.</p>
    <h2 id="-">Плюсы наследования: пример</h2>
    <p>Вы наверное уже давно заметили, что ссылка на страницу логина присутствует на каждой странице. Если мы хотим добавить
    тест <code>test_guest_can_go_to_login_page</code>, то для избежания дублирования следует перенести соответствующие методы в класс
    BasePage.</p>
    <p>В файле <code>locators.py</code> создаем новый класс BasePageLocators:</p>
    <pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">BasePageLocators</span>():
        <span class="hljs-type">LOGIN_LINK</span> = (<span class="hljs-type">By</span>.<span class="hljs-type">CSS_SELECTOR</span>, '#<span class="hljs-title">login_link'</span>)
        <span class="hljs-type">LOGIN_LINK_INVALID</span> = (<span class="hljs-type">By</span>.<span class="hljs-type">CSS_SELECTOR</span>, '#<span class="hljs-title">login_link_invalid'</span>)</span>
    </code></pre>
    <p>Переносим методы в <code>base_page.py</code>:</p>
    <pre><code class="lang-python">from .locators import BasePageLocators
    
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePage</span>():</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go_to_login_page</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            link = <span class="hljs-keyword">self</span>.browser.find_element(*BasePageLocators.LOGIN_LINK_INVALID)
            link.click()
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            assert <span class="hljs-keyword">self</span>.is_element_present(*BasePageLocators.LOGIN_LINK), <span class="hljs-string">'Login link is not presented'</span>
    </code></pre>
    <p>Обратите внимание, что новые методы должны быть добавлены к уже имеющимся, иначе ваши тесты разучатся находить элементы
    и т.п.</p>
    <p>В классе MainPage у нас не осталось никаких методов, поэтому добавим туда заглушку:</p>
    <pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPage</span>(<span class="hljs-title">BasePage</span>):</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, *args, **kwargs)</span></span>:
            <span class="hljs-keyword">super</span>(MainPage, <span class="hljs-keyword">self</span>).__init_<span class="hljs-number">_</span>(*args, **kwargs)
    </code></pre>
    <p>Добавляем в файл c тестами <code>test_product_page.py</code> новые тесты:</p>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link_on_product_page</span></span>(browser):
        link = 'http:<span class="hljs-comment">//selenium1py.pythonanywhere.com/en-gb/catalogue/the-city-and-the-stars_95/'</span>
        page = ProductPage(browser, link)
        page.open()
        page.should_be_login_link()
    </code></pre>
    <p>Добавьте самостоятельно второй тест</p>
    <p><code>test_guest_can_go_to_login_page_from_product_page</code></p>
    <p>Запустите тесты и убедитесь, что они выполняются положительно. Зафиксируйте изменения коммитом с осмысленным сообщением.</p>
    <h2 id="-">Задание: наследование и отрицательные проверки</h2>
    <p>В файл <code>test_main_page.py</code> добавьте тест с названием <code>test_guest_cant_see_product_in_basket_opened_from_main_page</code>:</p>
    <ol>
    <li>Гость открывает главную страницу</li>
    <li>Переходит в корзину по кнопке в шапке сайта</li>
    <li>Ожидаем, что в корзине нет товаров</li>
    <li>Ожидаем, что есть текст о том что корзина пуста</li>
    </ol>
    <p>В файл <code>test_product_page.py</code> добавьте тест с
    названием <code>test_guest_cant_see_product_in_basket_opened_from_product_page</code>:</p>
    <ol>
    <li>Гость открывает страницу товара</li>
    <li>Переходит в корзину по кнопке в шапке</li>
    <li>Ожидаем, что в корзине нет товаров</li>
    <li>Ожидаем, что есть текст о том что корзина пуста</li>
    </ol>
    <p>В классе BasePage реализуйте соответствующий метод для перехода в корзину.</p>
    <p>Создайте файл <code>basket_page.py</code> и в нем класс BasketPage.
    Реализуйте там необходимые проверки, в том числе негативную.
    Убедитесь, что тесты проходят и зафиксируйте изменения в коммите.</p>
    <h2 id="-setup">Группировка тестов: setup</h2>
    <p>Воспользуемся ООП для организации тестов. Pytest позволяет объединять тесты в тестовые наборы. Зачем это делать и почему
    это удобно?</p>
    <p>Во-первых, вы можете объединить тесты по смыслу, разделив функционал по фичам, компонентам или по какому-либо другому
    признаку. Давайте тесты для MainPage необходимые для проверки логина выделим в отдельный тестовый набор в файле
    <code>test_main_page.py</code> и пометим его меткой login_guest:</p>
    <pre><code class="lang-python">@pytest.mark.login_guest
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLoginFromMainPage</span>:</span>
        <span class="hljs-comment"># не забываем передать первым аргументом self                       </span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_go_to_login_page</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser)</span></span>:
            <span class="hljs-comment"># реализация теста</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser)</span></span>:
            <span class="hljs-comment"># реализация теста</span>
    </code></pre>
    <p>Запустите тестовый набор используя маркировку, необходимо добавить флаг <code>-m</code> и название метки. Обратите внимание, что
    использована всего лишь одна метка, а запущено два теста.</p>
    <p>Во-вторых, можно выделять общие функции для всего тестового набора, чтобы не заниматься дублированием кода. Эти функции
    уже нам знакомы: setup - функция, которая выполняется до запуска теста и teardown - функция, которая запускается после
    каждого теста, как правило в неё помещают методы очистки окружения или его восстановление после теста. Такие функции
    реализуют с помощью фикстур. Важно обратить внимание на область использование фикстуры <code>scope=&quot;function&quot;</code>, что будет
    означать, что фикстура будет исполняться для каждой функции, и на параметр <code>autouse=True</code>, который говорит, что фикстура
    будет использоваться без явного вызова.</p>
    <p>Для обеспечения независимости от контента там, где мы взаимодействуем с товаром, создавать новый товар по API и
    взаимодействовать с ним. Удаляя товар после выполнения тестового сценария. Наш интернет-магазин не поддерживает такой
    опции, но важно понимать важность использования п группировки тестовы и выделения подготовительных и завершающих шагов.</p>
    <p>Давайте посмотрим на пример реализации тестов в подобном случае:</p>
    <pre><code class="lang-python">@pytest.mark.login
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLoginFromProductPage</span>:</span>
        @pytest.fixture(scope=<span class="hljs-string">'function'</span>, autouse=True)
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
            <span class="hljs-keyword">self</span>.product = ProductFactory(title=<span class="hljs-string">'Created book'</span>)
            <span class="hljs-comment"># создание по API</span>
            <span class="hljs-keyword">self</span>.link = <span class="hljs-keyword">self</span>.product.link
            <span class="hljs-keyword">yield</span>
            <span class="hljs-comment"># после этого ключевого слова начинается teardown</span>
            <span class="hljs-comment"># выполнится после каждого теста в классе</span>
            <span class="hljs-comment"># удаляем те данные, которые мы создали </span>
            <span class="hljs-keyword">self</span>.product.delete()
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_can_go_to_login_page_from_product_page</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser)</span></span>:
            page = ProductPage(browser, <span class="hljs-keyword">self</span>.link)
            <span class="hljs-comment"># реализация теста</span>
    
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_guest_should_see_login_link</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, browser)</span></span>:
            page = ProductPage(browser, <span class="hljs-keyword">self</span>.link)
            <span class="hljs-comment"># реализация теста</span>
    </code></pre>
    <h2 id="-setup">Задание: группировка тестов и setup</h2>
    <p>Давайте попрактикуемся в написании сетапов для объединённых в группу тестов. Важно отметить, что этот пример
    исключительно для учебных целей и практики для закрепления теоретических аспектов. В реальной зарзаботке используются
    API методы или база данных для этих целей.</p>
    <p>Настала пора добавить тестовые сценарии не только для гостей нашего интернет-магазина, но и для зарегистрированных
    пользователей.</p>
    <ol>
    <li>В файле <code>test_product_page.py</code> создайте новый класс TestUserAddToBasketFromProductPage.</li>
    <li>Скопируйте в него уже реализованные тесты test_guest_cant_see_success_message и test_guest_can_add_product_to_basket
    и переименуйти в них <code>guest</code> на <code>user</code>. Содержимое этих тестов можно не менять. Всё, что вам нужно будет сделать, -
    это добавить шаг регистрации.</li>
    <li>Реализуйте в LoginPage метод <code>register_new_user(email, password)</code>, который принимает две строки и регистрирует
    пользователя.</li>
    <li>Добавьте в BasePage проверку того, что пользователь залогинен:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">should_be_authorized_user</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:
        assert <span class="hljs-keyword">self</span>.is_element_present(*BasePageLocators.USER_ICON), \
            <span class="hljs-string">'User icon is not presented, probably unauthorised user'</span>
    </code></pre>
    <ol>
    <li>Добавьте локатор соответственно в BasePageLocators:</li>
    </ol>
    <pre><code class="lang-python"><span class="hljs-attr">USER_ICON</span> = (By.CSS_SELECTOR, <span class="hljs-string">'.icon-user'</span>)
    </code></pre>
    <ol>
    <li><p>Добавьте в класс фикстуру setup. В этой функции нужно:</p>
    </li>
    <li><p>открыть страницу регистрации;</p>
    </li>
    <li>зарегистрировать нового пользователя;</li>
    <li>проверить, что пользователь залогинен.</li>
    </ol>
    <p>Убедитесь, что тесты проходят и действительно регистрируют новых пользователей.</p>
    <p>Зафиксируйте изменения с осмысленным сообщением в репозитории.</p>

    <h1 id="-allure">Создание отчётов о тестировании с помощью фреймворка Allure</h1>
    <h2 id="-">Что такое отчёт о тестировании и зачем он нужен?</h2>
    <p>Отчётность - одна из важных составляющих проекта, которая всегда проблематична для составления. Если у вас нет примеров
    для составления подобной документации на проекте, то вы обязательно зададитесь вопросами о том, что в неё написать, как
    описать выполненые действия, зачем это вообще описывать и кто будет читать этот отчёт.</p>
    <p>На самом деле, отчёт важен не только заказчику, чтобы посмотреть в каком состоянии находится выполнение текущего этапа
    проекта, но и самой команде, чтобы разобраться в проблемных местах системы.</p>
    <p>Отчет о результатах тестирования - периодический отчет, в котором документируется подробная информация о выполнении
    теста и его результате. Также он содержит условия, предположения, ограничения теста, какой элемент теста кем
    тестируется. Помимо этого вносится подробная информация об оставшейся работе, чтобы показать, сколько еще работы
    необходимо выполнить в
    проекте. <a href="https://vladislaveremeev.gitbook.io/qa_bible/testovaya-dokumentaciya-i-artefakty-test-deliverablestest-artifacts/vidy-otchetov-reports">Виды отчетов (Reports) QA Bible</a></p>
    <p>Мы будем использовать фреймворк для создания отчётов <a href="https://github.com/allure-framework">Allure Framework</a>, но давайте
    сначала зададимся вопросом &quot;А действительно ли необходимо использовать какой-то инструмент для формирования отчёта?&quot;.</p>
    <h2 id="-">Стоит ли использовать инструменты формирования отчётов?</h2>
    <p>Использование инструмента создания отчетов, такого как Allure, не является обязательным, но оно может дать несколько
    преимуществ, когда речь идет о создании отчётов по тестированию и их анализе. Разберём несколько причин, по которым
    использование инструмента создания отчетов является более целесообразным:</p>
    <ol>
    <li><p>Усовершенствованные отчёты о тестировании. Инструменты создания отчётов предоставляют более структурированные и
    визуально привлекательные отчёты по сравнению с выходными данными программы запуска тестов по умолчанию. Эти отчёты
    могут включать дополнительную информацию, такую как этапы тестирования, вложения (снимки экрана, журналы и т. д.) и
    общее состояние тестирования. Это облегчает понимание результатов тестирования и выявление проблем.</p>
    </li>
    <li><p>Исторические данные и тренды. Инструменты генерации отчётов часто имеют возможность сохранять исторические данные
    испытаний и генерировать отчёты о трендах. Это позволяет вам отслеживать ход ваших тестов с течением времени,
    выявлять закономерности и принимать решения для улучшения тестов на основе данных.</p>
    </li>
    <li><p>Совместная работа и документация. Отчёты могут служить артефактом документации для ваших тестов, облегчая членам
    команды и заинтересованным сторонам просмотр и понимание результатов тестирования. Он способствует совместной работе
    и предоставляет централизованное место для общения и обсуждения результатов тестирования.</p>
    </li>
    <li><p>Интеграция с CI/CD. Многие инструменты генерации отчётов хорошо интегрируются с конвейерами непрерывной
    интеграции/непрерывного развертывания (CI/CD). Они могут автоматически генерировать отчёты после каждого запуска
    тестов и предоставлять сводку результатов. Это обеспечивает плавную интеграцию в существующий рабочий процесс
    разработки.</p>
    </li>
    </ol>
    <p>Хотя использование инструмента создания отчётов не является обязательным, он может значительно улучшить аспекты
    визуализации, анализа и совместной работы при выполнении теста. В конечном итоге это зависит от требований вашего
    проекта и уровня отчётности и анализа, необходимых для ваших тестов.</p>
    <h2 id="-allure">Использование Allure</h2>
    <h3 id="-">Установка зависимостей</h3>
    <p>Вам понадобится сам фреймворк <a href="https://github.com/allure-framework/allure-python/releases">allure-python</a>.</p>
    <p>Мы будем использовать генерацию отчёта в HTML, для этого нам понадобится
    библиотека <a href="https://pypi.org/project/allure-pytest/">allure-pytest</a>.</p>
    <p>После установки зависимостей в вашу виртуальную среду не забудьте добавить их в <code>requirements.txt</code>.</p>
    <h3 id="-">Маркирование шагов, тестовых наборов, фичей и тестов</h3>
    <p>Посмотрим на примение маркировки тестов для страницы <a href="https://demoqa.com/accordian">Accordian DEMOQA</a>.</p>
    <pre><code class="lang-python"><span class="hljs-meta">@allure</span>.suite(<span class="hljs-string">'Alerts Frame Windows tab'</span>)
    <span class="hljs-keyword">class</span> TestAlertsFrameWindows:
        <span class="hljs-string">"""Class represents Alerts, Frame &amp; Windows tab.
        Contains tabs:
        Browser Windows,
        Alerts,
        Frames,
        Nested Frames,
        Modal Dialogs.
        """</span>
        EXPECTED<span class="hljs-number">_T</span>EXT = <span class="hljs-string">'This is a sample page'</span>
    
        <span class="hljs-meta">@allure</span>.feature(<span class="hljs-string">'Browser Windows'</span>)
        <span class="hljs-keyword">class</span> TestBrowserWindows:
            <span class="hljs-string">"""Class represents Browser Windows tab tests."""</span>
            browser<span class="hljs-number">_</span>windows<span class="hljs-number">_p</span>age<span class="hljs-number">_</span>link = <span class="hljs-string">'https://demoqa.com/browser-windows'</span>
    
            <span class="hljs-meta">@allure</span>.title(<span class="hljs-string">'Test opening a new tab and getting the text from it.'</span>)
            def test<span class="hljs-number">_n</span>ew<span class="hljs-number">_</span>tab(self, driver):
                <span class="hljs-string">"""Test opening a new tab and getting the text from it."""</span>
                browser<span class="hljs-number">_</span>windows<span class="hljs-number">_p</span>age = BrowserWindowsPage(driver, self.browser<span class="hljs-number">_</span>windows<span class="hljs-number">_p</span>age<span class="hljs-number">_</span>link)
                browser<span class="hljs-number">_</span>windows<span class="hljs-number">_p</span>age.open()
                <span class="hljs-keyword">new</span><span class="hljs-number">_</span>tab<span class="hljs-number">_</span>text = browser<span class="hljs-number">_</span>windows<span class="hljs-number">_p</span>age.check<span class="hljs-number">_</span>opened(<span class="hljs-string">'tab'</span>)
                <span class="hljs-keyword">assert</span> <span class="hljs-keyword">new</span><span class="hljs-number">_</span>tab<span class="hljs-number">_</span>text == TestAlertsFrameWindows.EXPECTED<span class="hljs-number">_T</span>EXT, \
                f<span class="hljs-string">'New tab text should be \'</span>{TestAlertsFrameWindows.EXPECTED<span class="hljs-number">_T</span>EXT}\<span class="hljs-string">''</span>
    
            f<span class="hljs-string">' but got {new_tab_text}'</span>
    </code></pre>
    <p>Обратите внимание, что мы объявили класс TestAlertsFrameWindows тестовым набором с помощью
    декоратора <code>@allure.suite(&#39;Alerts Frame Windows tab&#39;)</code>, в который входит большой перечень фичей: Browser Windows,
    Alerts, Frames и т.д. Каждую фичу мы должны пометить декоратором <code>@allure.feature()</code> с названием самой фичи. Фича
    представляет собой класс хранящий в себе тесты посвященные определённой тематике. Каждый тест отметим
    декоратором <code>@allure.title()</code> внутри которого стоит указать название нашего теста. Хорошей практикой является
    придерживаться форматов именования тестов, которые приняты на вашем проекте и используются в ручном тестировании.</p>
    <p>Давайте посмотрим на пример декорирования шагов тестового сценария:</p>
    <pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserWindowsPage</span><span class="hljs-params">(BasePage)</span>:</span>
        <span class="hljs-string">"""Browser Windows page object."""</span>
        locators = BrowserWindowsPageLocators()
    
    <span class="hljs-meta">    @allure.step('Check if new tab of window is opened.')</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_opened</span><span class="hljs-params">(self, what_to_open)</span> -&gt; str:</span>
            <span class="hljs-string">"""
            Check if new tab of window is opened.
            :returns: title of new tab or window.
            """</span>
            available_cases = {
                <span class="hljs-string">'tab'</span>: self.locators.NEW_TAB_BUTTON,
                <span class="hljs-string">'window'</span>: self.locators.NEW_WINDOW_BUTTON
            }
            <span class="hljs-keyword">with</span> allure.step(f<span class="hljs-string">'Click on {what_to_open}'</span>):
                self.element_is_clickable(available_cases[what_to_open]).click()
            <span class="hljs-keyword">with</span> allure.step(<span class="hljs-string">'Switch to new tab'</span>):
                self.switch_to_new_tab()
            <span class="hljs-keyword">with</span> allure.step(<span class="hljs-string">'Get title text'</span>):
                text_title = self.element_is_present(self.locators.SAMPLE_TEXT).text
            <span class="hljs-keyword">return</span> text_title
    </code></pre>
    <p>Каждое действие метода-проверки помечается соответствующим декоратором. Не забывайте писать осмысленные сообщения о
    действии в шаге и никогда не пропускайте шаги вашего тест-кейса.</p>
    <h3 id="-">Получение скриншотов экрана</h3>
    <p>Вы можете получать скриншоты экрана с помощью срадств автоматизации и прикреплять их к вашему отчёту. Это будет удобно
    для визуального наблюдения дефекта, когда вы запускаете автотесты в <code>headless</code> режиме или ставите ночной прогон тестов.</p>
    <pre><code class="lang-python"><span class="hljs-meta">@pytest.fixture(scope='function')</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">driver</span><span class="hljs-params">()</span>:</span>
        <span class="hljs-string">"""Google Chrome is used as driver."""</span>
        driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))
        driver.maximize_window()
        <span class="hljs-keyword">yield</span> driver
        screenshot = driver.get_screenshot_as_png()
        allure.attach(screenshot, name=f<span class="hljs-string">'Screenshot {datetime.today()}'</span>,
                      attachment_type=allure.attachment_type.PNG)
        driver.quit()
    </code></pre>
    <h2 id="-">Готовый отчёт о тестировании</h2>
    <p>Используйте приведённые примеры для оформления ваших собственных методов, тестовых наборов и тестов.</p>
    <p>Чтобы получить отчёт о тестировании вам необходимо использовать команду с указанием директории для сохранения файлов
    отчёта: <code>pytest --alluredir=allure_results .\tests</code>, где <code>tests</code> - директория, содержащая все тесты, <code>allure_results</code> -
    директория для сохранения файлов отчёта.</p>
    <p>Чтобы собрать свой отчёт в HTML используйте команду <code>allure serve allure_results</code>.</p>
    <p>Откроется окно браузера, в котором у вас будет готовый отчёт по тестированию.</p>
    <p><img src="img/allure_report.png" height="600" width="1200" alt="final report summary"></p>

    <h1 id="-">Ссылки на дополнительные материалы</h1>
    <h2 id="-">ООП</h2>
    <ul>
    <li><a href="https://python-scripts.com/object-oriented-programming-in-python">Объектно-ориентированное Программирование в Python</a></li>
    <li><a href="https://devpractice.ru/python-lesson-14-classes-and-objects/">Python. Урок 14. Классы и объекты</a></li>
    <li><a href="https://tproger.ru/translations/oop-principles-cheatsheet/">Шпаргалка по принципам ООП</a></li>
    </ul>
    <h2 id="page-objects">Page Objects</h2>
    <ul>
    <li><a href="https://page-objects.readthedocs.io/en/latest/">Page Objects for Python</a></li>
    <li><a href="https://selenium-python.readthedocs.io/page-objects.html">Page Objects</a></li>
    <li><a href="https://www.selenium.dev/documentation/test_practices/encouraged/page_object_models/">Page object models</a></li>
    <li><a href="https://martinfowler.com/bliki/PageObject.html">PageObject</a></li>
    <li><a href="https://medium.com/tech-tajawal/page-object-model-pom-design-pattern-f9588630800b">Page Object Model (POM) | Design Pattern</a></li>
    </ul>
    <h2 id="code-style">Code Style</h2>
    <ul>
    <li><a href="https://docs.python-guide.org/writing/style/">Code Style</a></li>
    <li><a href="https://peps.python.org/pep-0008/">PEP 8 – Style Guide for Python Code</a></li>
    <li><a href="https://peps.python.org/pep-0257/">PEP 257 – Docstring Conventions</a></li>
    <li><a href="https://peps.python.org/pep-0020/">PEP 20 – The Zen of Python</a></li>
    <li><a href="https://habr.com/ru/articles/266969/">Что такое красивый код, и как его писать?</a></li>
    <li><a href="https://habr.com/ru/articles/206868/">Практика хорошего кода</a></li>
    </ul>
    <h2 id="-">Обработка исключений</h2>
    <ul>
    <li><a href="https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html">Исключения в python. Конструкция try - except для обработки исключений</a></li>
    </ul>
    <h2 id="pytest-docs">Pytest docs</h2>
    <ul>
    <li><a href="https://pytest.org/en/stable/how-to/skipping.html#skip-xfail-with-parametrize">Skip/xfail with parametrize</a></li>
    </ul>
    <h2 id="useful-information">Useful information</h2>
    <ul>
    <li><a href="https://habr.com/ru/companies/badoo/articles/419419/">UI-автотесты: как делать не стоит</a></li>
    </ul>
    

</body>
</html>